---
layout: post
title: "[#5] 관계 데이터 모델"
image:
categories: 데이터베이스
tags: 
  - 데이터베이스
sitemap:
  changefreq: daily
  priority: 1.0
---

## 관계 데이터 모델의 개념

**관계 데이터 모델의 기본 개념**

- 개념적 구조를 논리적 구조로 표현하는 논리적 데이터 모델
- 하나의 개체에 대한 데이터를 하나의 릴레이션에 저장
- Relataion은 "관계를 맺다"라는 의미가 아닌 Table의 이름을 Relation이라 말하는 것



| <img src="https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20211011224352.png" alt="image-20211011224352851" style="zoom:50%;" /> |
| :----------------------------------------------------------: |
|                       [고객 릴레이션]                        |



**관계 데이터 모델의 기본 용어**

- 릴레이션(relation)
  - 하나의 개체에 관한 데이터를 2차원 테이블의 구조로 저장한 것
- 속성(attribute)
  - 릴레이션의 열
  - **파일의 field**에 대응하는 개념
- 튜플(tuple)
  - 릴레이션의 행
  - **파일의 record**에 대응하는 개념



**관계 데이터 모델의 기본 용어**

- 도메인(domain)
  - 하나의 속성이 가질 수 있는 모든 값의 집합
  - 일반적으로 속성의 데이터 타입으로 정의
  - 잘못된 연산 시도를 예방해줌
- 널(null)
  - 속성 값을 아직 모르거나 해당되는 값이 없음을 표현
  - 일반적으로 표시하기 위해 공백을 사용
- 차수(degree)
  - 속성의 개수(열의 수)
  - 일반적으로 자주 변하지 않음 (정적인 특징)
- 카디널리티(cardinality)
  - 튜플의 개수(행의 수)
  - 일반적으로 자주 변함 (동적인 특징)



`고객 릴레이션`의 차수 : 6

`고객 릴레이션`의 카디널리티: 4



### 릴레이션의 구성

<img src="https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20211011225919.png" alt="image-20211011225919947" style="zoom:50%;" />

- 릴레이션 스키마 (relation schema)
  - 릴레이션의 논리적 구조
  - 릴레이션의 이름과 릴레이션에 포함된 모든 속성 이름으로 정의
    - i.e., 고객(고객아이디, 고객이름, 나이, 등급, 직업, 적립금)
- 릴레이션 인스턴스 (relation instance)
  - 어느 한 시점에 릴레이션에 존재하는 튜플들의 집합
  - 실체화된 값



**데이터베이스의 구성**

<img src="https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20211011230044.png" alt="image-20211011230044519" style="zoom:50%;" />

- 데이터베이스 스키마 (database schema)
  - 데이터베이스의 전체 구조
  - 데이터베이스를 구성하는 **릴레이션 스키마의 모음**
- 데이터베이스 인스턴스 (database instance)
  - 데이터베이스를 구성하는 **릴레이션 인스턴스의 모음**



**릴레이션의 특성**

- 튜플의 유일성
  - 하나의 릴레이션에는 동일한 튜플이 존재할 수 없다.
  - 튜플들을 유일하게 구별하기 위해 선정되는 속성을 키(key)라고 부른다.
- 튜플의 무순서성
  - 하나의 릴레이션에서 튜플 사이의 순서는 무의미하다.
- 속성의 무순서성
  - 하나의 릴레이션에서 속성 사이의 순서는 무의미하다.
- 속성의 원자성
  - 속성 값으로 원자 값(의미의 분해가 되지 않는 하나의 값)만 사용할 수 있다.
  - 다중 값을 가질 수 없다.



### 키(key)

- 릴레이션에서 튜플들을 유일하게 구별하는 속성 또는 속성들의 집합



**키의 특성**

- 유일성 (uniqueness)
  - 하나의 릴레이션에서 모든 튜플은 서로 다른 키 값을 가져야 함
- 최소성 (minimality)
  - 꼭 필요한 최소한의 속성들로만 키를 구성함



**키의 종류**

- 슈퍼키 (super key)

  - 유일성을 만족하는 속성 또는 속성들의 집합
  - 유일성; 하나의 릴레이션에서 키로 지정된 속성 값은 튜플마다 달라야 한다는 의미
  - i.e., 고객 릴레이션의 `고객아이디`, `(고객아이디, 고객이름)`, `(고객이름, 주소)`
  - 속성들의 집합또한 슈퍼키에 포함되는 개념이므로 불필요한 속성까지 확인하게 되어 비효율적인 경우가 존재
    - 이를 해결하기 위해 후보키의 개념이 필요

- 후보키 (candidate key)

  - 유일성과 최소성을 만족하는 속성 또는 속성들의 집합
  - 최소성; 꼭 필요한 속성들로만 키를 구성한다는 의미
  - i.e., 고객 릴레이션의 `고객아이디`, `(고객이름, 주소)`

- 기본키 (primary key)

  - 후보키 중에서 기본적으로 사용하기 위해 선택한 키
  - 속성 이름에 밑줄을 그어 표현
  - i.e., 고객 릴레이션의 `고객아이디`

- 대체키 (alternate key)

  - 기본키로 선택되지 못한 후보키
  - i.e., 고객 릴레이션의 `(고객이름, 주소)`

  <img src="https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20211011231708.png" alt="image-20211011231708335" style="zoom:33%;" />

- 외래키 (foreign key)

  - 다른 릴레이션의 기본키(대체키)를 참조하는 속성 또는 속성들의 집합
  - 릴레이션들 간의 관계를 표현 (관계 구현의 핵심으로 동작)
  - 하나의 릴레이션에 외래키가 여러 개 존재할 수 있다.
  - 외래키를 기본키로 사용할 수 있다.
  - 외래키 속성과 그것이 참조하는 기본키 속성의 이름은 달라도 되지만, 도메인은 같아야 한다.
  - 같은 릴레이션의 기본키를 참조하는 외래키도 정의할 수 있다.
  - 널 값을 가질 수 있다.
  - 외래키를 가진 릴레이션: 참조하는 릴레이션, 반대는 참조되는 릴레이션



| <img src="https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20211011232248.png" alt="image-20211011232248686" style="zoom: 50%;" /> | <img src="https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20211011232327.png" alt="image-20211011232327493" style="zoom: 33%;" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| <img src="https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20211011232510.png" alt="image-20211011232510254" style="zoom:50%;" /> |                                                              |



**기본키를 선택할 때 고려하면 도움이 되는 기준들**

- 널 값을 가질 수 있는 속성이 포함된 후보키는 기본키로 부적합하다.
  - 기본키가 널 값인 튜플은 다른 튜플들과 구별되지 않으므로 부적합
- 값이 자주 변경될 수 있는 속성이 포함된 후보키는 기본키로 부적합하다.
  - 기본키의 값이 바뀔때마다 그 값이 기본키로 적합한지 검사해야하므로 부적합
- 단순한 후보키를 기본키로 선택한다.
  - 자릿수가 적은 정수, 단순 문자열 속성, 키를 구성하는 속성의 개수가 적은 후보키



## 관계 데이터 모델의 제약

### 무결성 제약조건

- 데이터의 무결성을 보장하고 일관된 상태로 유지하기 위한 규칙
- 무결성: 데이터를 결함이 없는 상태, 즉 정확하고 유효하게 유지하는 것



**개체 무결성 제약조건**

- 기본키를 구성하는 모든 속성은 널 값을 가질 수 없는 규칙



**참조 무결성 제약조건**

- 외래키는 참조할 수 없는 값을 가질 수 없는 규칙

| <img src="https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20211011234448.png" alt="image-20211011234448721" style="zoom:50%;" /> |
| :----------------------------------------------------------: |
|                참조 무결성 제약조건 위배 예시                |



**주의할 점**

- 외래키 속성이 널 값을 가진다고 해서 참조 무결성 제약조건을 위배한 것은 아님
  - i.e., 추천인이라는 외래키 속성이 존재할 때 추천인을 입력하지 않았으면 null이지만 이게 참조 무결성 제약조건 위배는 아니다.

