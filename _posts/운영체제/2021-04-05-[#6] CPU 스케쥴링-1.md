---
layout: post
title: "[#6] CPU 스케쥴링-1"
image:
categories: 운영체제
tags: 
  - 운영체제
  - OS
use_math: true
sitemap:
  changefreq: daily
  priority: 1.0
---

## CPU 스케쥴링

### Add, Load, Store 명령

CPU 명령에는 덧셈을 진행하는 Add, 메모리 접근을 수행하는 Load, Store 명령이 있다. Load, Store 명령어는 Add 명령에 비해서는 느리지만 비교적 짧은 시간이 드는 명령이며, Add 명령과 마찬가지로 사용자 프로그램이 직접 실행할 수 있는 일반명령에 해당한다.



### CPU 버스트와 I/O 버스트

사용자 프로그램은 CPU 작업(CPU busrt)과 I/O 작업(I/O burst)의 반복으로 구성된다. 이는 CPU와 I/O라는 서로 다른 자원을 번갈아 사용하며 프로그램이 수행되는 것으로 볼 수 있다. 대부분의 프로세스는 다수의 짧은 CPU 버스트와 소수의 긴 CPU 버스트로 구성된다. 이렇게 짧은 CPU 버스트가 대부분인 프로세스를 I/O 바운드 프로세스라 하며, 이에 반대되는 프로세스를 CPU 바운드 프로세스라 한다. 



### CPU 스케쥴링의 필요성

각 프로그램마다 CPU 버스트와 I/O 버스트가 차지하는 비율이 다르기 때문에 CPU 스케쥴링 작업이 필요하다.  CPU 버스트가 짧은 프로세스는 대부분 대화형 작업(interactive job)으로 사용자와 인터랙션을 해야하기 때문에 CPU의 빠른 서비스를 필요로 하며 이에 CPU 스케쥴러는 I/O 바운드 프로세스가 우선적으로 CPU를 사용할 수 있도록 해준다. 이 작업은 대화형 프로세스에게 빠른 응답성을 제공해줌과 도시에 I/O 장치의 효율성도 높이는데 I/O 바운드 프로세스는 CPU를 잠깐만 사용한 뒤 다시 I/O 작업을 수행하기 때문이다.



## CPU 스케쥴러

### CPU 스케쥴러의 동작과정

CPU 스케쥴러는 준비 상태에 있는 프로세스들 중 어떤한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드이다. 프로세스 실행 중 타이머 인터럽트가 발생하면 CPU 스케쥴러가 호출된다. 그럼 이 때 CPU 스케쥴러는 준비 큐에서 프로세스를 하나 선택해 CPU를 할당하게 된다.



### CPU 스케쥴링이 필요한 몇 가지 경우들

1. 실행 상태에 있던 프로세스가 I/O 요청 등에 의해 봉쇄 상태로 바뀌는 경우
2. 실행 상태에 있던 프로세스가 타이머 인터럽트 발생에 의해 준비 상태로 바뀌는 경우
3. I/O 요청으로 봉쇄 상태에 있던 프로세스가 I/O 작업이 완료되어 인터럽트가 발생하고 그 결과 이 프로세스의 상태가 준비 상태로 바뀌는 경우
4. CPU에서 실행 상태에 있는 프로세스가 종료되는 경우



### 선점형 방식과 비선점형 방식

CPU 스케쥴링 방식에는 선점형 방식과 비선점형 방식이 있는데 비선점형 방식은 CPU를 획득한 프로세스가 스스로 반납하기 전까지 CPU를 빼앗지 않지만 선점형 방식은 CPU를 강제로 빼앗을 수 있다. 위의 스케쥴링이 필요한 몇 가지 경우 중 1번과 4번은 비선점형 스케쥴링의 예이며, 2번과 3번은 선점형 스케쥴링 방식의 예에 해당한다. 3번은 이번에 I/O 작업이 완료된 프로세스가 인터럽트 당한 프로세스보다 우선순위가 높아서 곧바로 CPU를 획득하는 경우이다.

## 디스패처

### CPU의 이양 작업

어떤 프로세스에게 CPU를 할당할지가 결정되고 나면 선택된 프로세스에게 CPU를 이양하는 작업이 필요하다. 이런 작업을 해주는 운영체제의 코드를 디스패처(dispatcher)라고 부른다.

 

### 디스패처

디스패처는 현재 수행 중이던 프로세스의 문맥을 그 프로세스의 PCB에 저장하고 이번에 CPU를 할당할 프로세스의 PCB로부터 문맥을 복원한 뒤 CPU를 넘겨준다. 프로세스 문맥 복원 뒤에 시스템의 상태를 사용자모드로 전환해 사용자 프로그램에게 CPU 제어권을 넘기게 된다. 디스패처가 하나의 프로세스를 정지시키고 다음 프로세스에게 CPU를 넘기는 과정에서 걸리는 시간을 디스패치 지연시간(dispatch latency)라고 하며 대부분 문맥교환 오버헤드가 디스패치 지연시간을 이루고 있다.
