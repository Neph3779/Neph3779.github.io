<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Neph's Blog</title>
    <description>Write code with my soul.</description>
    <link>https://neph3779.github.io/</link>
    <atom:link href="https://neph3779.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 18 Apr 2021 21:34:02 +0900</pubDate>
    <lastBuildDate>Sun, 18 Apr 2021 21:34:02 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>[#9] 프로세스 동기화-2</title>
        <description>&lt;h2 id=&quot;critical-section-관리-알고리즘의-발전&quot;&gt;Critical Section 관리 알고리즘의 발전&lt;/h2&gt;

&lt;h3 id=&quot;critical-section을-사용하기-위해-만족해야-하는-몇가지-조건들&quot;&gt;Critical Section을 사용하기 위해 만족해야 하는 몇가지 조건들&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Mutual Exclusion(상호 배제)
    &lt;ul&gt;
      &lt;li&gt;프로세스 P_i가 critical section 부분을 수행중이면 다른 모든 프로세스들은 그들의 critical section에 들어가면 안된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Progress(진행)
    &lt;ul&gt;
      &lt;li&gt;아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 프로세스가 있으면 critical section에 들어가게 해주어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Bounded Waiting(유한 대기)
    &lt;ul&gt;
      &lt;li&gt;프로세스가 critical section에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 critical section에 들어가는 횟수에 한계가 있어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;가정&quot;&gt;가정&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;모든 프로세스의 수행 속도는 0보다 크다.&lt;/li&gt;
  &lt;li&gt;프로세스들 간의 상대적인 수행 속도는 가정하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;알고리즘-1&quot;&gt;알고리즘 1&lt;/h3&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// code for P_0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* My turn? */&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... critical section ...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* Now it's P_1's turn */&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... remainder section ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;critical section에 들어가기 위해 본인의 차례인지 확인 (turn이라는 변수를 통해)&lt;/li&gt;
  &lt;li&gt;만약 자신의 차례가 아니라면 기다림&lt;/li&gt;
  &lt;li&gt;자신의 차례가 오면 들어가서 작업 수행, 나올 때 turn을 상대편 차례에 맞게 바꿔줌&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문제점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;critical section에 반드시 교대로 들어가야함. (나 혼자 계속 못들어감, 상대편이 안들어가주면 영원히 내 차례 안옴)&lt;/li&gt;
  &lt;li&gt;critical section에 들어가고자 하는 빈도의 차이가 있을 때 한계점이 분명함.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만족하는 조건 : Mutual Exclusion&lt;/p&gt;

&lt;p&gt;만족하지 못하는 조건: Progress, Bounded Waiting&lt;/p&gt;

&lt;h3 id=&quot;알고리즘-2&quot;&gt;알고리즘 2&lt;/h3&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... critical section ...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...remainder section&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;flag 배열로 입장 가능 여부 관리&lt;/li&gt;
  &lt;li&gt;critical section에 입장하고 싶을 때 flag[i]를 true로 바꾸고 시작함&lt;/li&gt;
  &lt;li&gt;자신의 차례가 와서 작업이 끝났다면 flag[i]를 꺼주고(false로 만들고) 나감&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문제점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;flag를 여러개 들어 놓으면 계속 기다리는 상태가 됨 (critical section에 들어가기 전에 flag를 켜고 시작하므로)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만족하는 조건 : Mutual Exclusion&lt;/p&gt;

&lt;p&gt;만족하지 못하는 조건: Progress, Bounded Waiting&lt;/p&gt;

&lt;h3 id=&quot;피터슨-알고리즘&quot;&gt;피터슨 알고리즘&lt;/h3&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... critical section ...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... remainder section ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;flag는 입장 희망 여부 배열&lt;/li&gt;
  &lt;li&gt;turn은 현재 사용중인 프로세스를 나타냄&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만족하는 조건 : Mutual Exclusion, Progress, Bounded Waiting&lt;/p&gt;

&lt;p&gt;한계 : Busy Waiting 방식이기 때문에 계속 CPU와 memory를 쓰면서 wait&lt;/p&gt;

&lt;h2 id=&quot;하드웨어적-해결&quot;&gt;하드웨어적 해결&lt;/h2&gt;

&lt;h3 id=&quot;하드웨어를-사용한-critical-section-문제해결&quot;&gt;하드웨어를 사용한 critical section 문제해결&lt;/h3&gt;

&lt;p&gt;critical section 관련 문제 발생의 이유 : 메모리에 읽는 작업 + 쓰는 작업을 하나의 instruction으로 쓸 수 없기 때문에&lt;/p&gt;

&lt;p&gt;만약 instruction 하나로 실행할 수 있다면? 문제는 쉽게 해결할 수 있음&lt;/p&gt;

&lt;h3 id=&quot;test_and_set&quot;&gt;Test_and_set&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/OS/9/1.png&quot; alt=&quot;1&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Test_and_set은 읽어오는 작업과 동시에 쓰는 작업을 실행할 수 있음 (하드웨어적 해결)&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Test_and_Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... critical section ...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... remainder section ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;semaphores를-통한-추상화&quot;&gt;Semaphores를 통한 추상화&lt;/h2&gt;

&lt;h3 id=&quot;추상-자료형-semaphore&quot;&gt;추상 자료형 Semaphore&lt;/h3&gt;

&lt;p&gt;Semaphore는 정수 변수를 가질 수 있으며 아래의 두 가지 atomic 연산에 의해서만 접근 가능&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// If positive, decrement &amp;amp; enter&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Othrewise, wait until positive (busy-wait)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;P: 공유 데이터를 획득하는 과정&lt;/p&gt;

&lt;p&gt;S: 공유 데이터를 반납하는 과정&lt;/p&gt;

&lt;h3 id=&quot;semaphore를-사용하는-이유&quot;&gt;Semaphore를 사용하는 이유&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;lock을 걸고 lock을 푸는 것을 간단하게 만들어줌&lt;/li&gt;
  &lt;li&gt;공유자원을 획득, 반납하는 과정을 내부적으로 처리해줌&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;semaphore를-통한-critical-section-문제-해결&quot;&gt;Semaphore를 통한 Critical Section 문제 해결&lt;/h3&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... critical section ...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... remainer section ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로그래머가 일일이 코딩하지 않고 Semaphore를 이용하여 쉽게 해결할 수 있음&lt;/p&gt;

&lt;p&gt;개선 방안&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;효율적이지 못한 busy-wait(spin lock) 방식 대신 Block &amp;amp; Wakeup 방식으로 개선&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;block--wakeup-방식의-semaphore-구현&quot;&gt;Block &amp;amp; Wakeup 방식의 Semaphore 구현&lt;/h2&gt;

&lt;h3 id=&quot;semaphore-자료형의-정의&quot;&gt;Semaphore 자료형의 정의&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/OS/9/2.png&quot; alt=&quot;1&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;process&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Semaphore 때문에 잠들어있는 프로세스들을 연결시키는 큐가 생김&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;block()&lt;/strong&gt; 연산&lt;/p&gt;

&lt;p&gt;커널은 block을 호출한 프로세스를 suspend 시킴&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;wakeup(P)&lt;/strong&gt; 연산&lt;/p&gt;

&lt;p&gt;block 된 프로세스 P를 wakeup 시킴&lt;/p&gt;

&lt;p&gt;이 프로세스의 PCB를 ready queue로 옮김&lt;/p&gt;

&lt;h3 id=&quot;p-연산과-v-연산의-정의&quot;&gt;P 연산과 V 연산의 정의&lt;/h3&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;wakeup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;busy-wait-vs-blockwakeup&quot;&gt;Busy-wait v.s. Block/wakeup&lt;/h2&gt;

&lt;h3 id=&quot;blockwakeup-방식의-단점&quot;&gt;Block/wakeup 방식의 단점&lt;/h3&gt;

&lt;p&gt;block하고 깨우는 과정에서 오버헤드가 발생함&lt;/p&gt;

&lt;h3 id=&quot;busy-wait의-단점&quot;&gt;Busy-wait의 단점&lt;/h3&gt;

&lt;p&gt;critical section의 길이가 길어지면 starvation 현상이 발생함&lt;/p&gt;

&lt;h3 id=&quot;해결방안-섞어쓰기&quot;&gt;해결방안 (섞어쓰기)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Critical section의 길이가 긴 경우에는 Block/wakeup이 적합&lt;/li&gt;
  &lt;li&gt;Critical section의 길이가 매우 짧은 경우에는 Busy-wait 방식이 적합&lt;/li&gt;
  &lt;li&gt;일반적으로는 Block/wakeup을 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;두-가지-종류의-semaphores&quot;&gt;두 가지 종류의 Semaphores&lt;/h2&gt;

&lt;h3 id=&quot;counting-semaphore&quot;&gt;Counting semaphore&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;도메인이 0 이상인 임의의 정수값&lt;/li&gt;
  &lt;li&gt;주로 resource counting에 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;binary-semaphore--mutex&quot;&gt;Binary semaphore (= mutex)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;0 또는 1 값만 가질 수 있는 semaphore&lt;/li&gt;
  &lt;li&gt;주로 mutual exclusion (lock/unlock)에 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;deadlock-and-starvation&quot;&gt;Deadlock and Starvation&lt;/h2&gt;

&lt;h3 id=&quot;deadlock-현상&quot;&gt;Deadlock 현상&lt;/h3&gt;

&lt;p&gt;둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상을 Deadlock 현상이라 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/OS/9/3.png&quot; alt=&quot;1&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 처럼 P연산이 연달아 일어나지만 실행되지 못하고 기다리는 경우&lt;/p&gt;

&lt;p&gt;V연산이 실행되지 못하기 때문에 영원히 기다리는 Deadlock 현상이 발생&lt;/p&gt;

&lt;h3 id=&quot;starvation-현상&quot;&gt;Starvation 현상&lt;/h3&gt;

&lt;p&gt;프로세스가  semaphore 큐에서 빠져나갈 수 없어서 무기한 blocking이 일어나는 경우를 Starvation 현상이라 말한다.&lt;/p&gt;

</description>
        <pubDate>Sun, 18 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/9-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3-%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA-2/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/9-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3-%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA-2/</guid>
        
        <category>OS</category>
        
        <category>운영체제</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>2021년 04월 13일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;시청한 영상: &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2020/10027/&quot;&gt;WWDC20 Modern cell configuration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UITableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cellForRowAt&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IndexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dequeueReusableCell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;withIdentifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;KoreanItemCell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as?&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;KoreanItemCell&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UITableViewCell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;koreanItemData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;koreanItemsData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;itemImageView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;named&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;koreanItemData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imageName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;titleLabel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;koreanItemData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shortDescriptionLabel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;koreanItemData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shortDescription&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;vs&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UITableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cellForRowAt&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IndexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UITableViewCell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;defaultContentConfiguration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;koreanItemData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;koreanItemsData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;named&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;koreanItemData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imageName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;koreanItemData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;secondaryText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;koreanItemData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shortDescription&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contentConfiguration&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Tue, 13 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.13-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.13-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>[#8] 프로세스 동기화-1</title>
        <description>&lt;h2 id=&quot;프로세스-동기화-문제&quot;&gt;프로세스 동기화 문제&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;공유 데이터의 동시 접근은 데이터의 불일치 문제를 발생시킬 수 있다&lt;/li&gt;
  &lt;li&gt;일관성 유지를 위해서는 협력 프로세스 간의 실행 순서를 정해주는 메커니즘이 필요하다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;race-condition&quot;&gt;Race Condition&lt;/h2&gt;

&lt;h3 id=&quot;race-condition이-생기는-경우&quot;&gt;Race Condition이 생기는 경우&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;커널 작업 중 인터럽트 발생 시&lt;/li&gt;
  &lt;li&gt;프로세스가 시스템 콜을 하여 커널 모드로 수행중인데 문맥교환이 일어나는 경우&lt;/li&gt;
  &lt;li&gt;멀티프로세서에서 공유 메모리 내의 커널 데이터&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1-커널-작업중-인터럽트-발생&quot;&gt;1. 커널 작업중 인터럽트 발생&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/OS/8/1.png&quot; alt=&quot;1&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;커널 작업중 인터럽트가 발생하여 커널 내의 같은 변수에 접근하는 경우에는 커널 작업이 끝날때까지 인터럽트를 막음으로써 해결할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;2-시스템-콜-실행중-문맥교환이-일어나는-경우&quot;&gt;2. 시스템 콜 실행중 문맥교환이 일어나는 경우&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/OS/8/2.png&quot; alt=&quot;2&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;P_A가 CPU를 사용하다가 Count라는 변수를 읽도록 지시하였는데 (시스템 콜을 통해) 그 사이에 할당시간이 만료되어 P_B가 CPU를 사용하게 되는 경우가 있다고 가정하자. 이때 P_B도 Count라는 같은 변수에 접근한다면 P_A는 P_B에 의해 바뀐 Count 값이 아닌 (이미 1 증가한 Count 값이 아닌) 기존의 Count 값을 증가한다. 이런 상황을 해결하기 위해 커널 모드에서 작업중인 경우에는 preempt(CPU를 뺏어가는 행위) 하지 않는다. 대신 커널 모드에서 사용자 모드로 돌아갈 때 preempt를 진행한다.&lt;/p&gt;

&lt;h3 id=&quot;3-멀티프로세서에서의-공유데이터-접근문제&quot;&gt;3. 멀티프로세서에서의 공유데이터 접근문제&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/OS/8/3.png&quot; alt=&quot;3&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;멀티프로세서에서의 공유데이터 접근문제는 개별 데이터에 대해 lock을 걸어주는 방법이 있다. 다른 방법으로는 커널은 접근을 매 순간 하나의 CPU만이 할 수 있도록 하는 방법도 존재한다.&lt;/p&gt;

&lt;h2 id=&quot;임계구역-문제&quot;&gt;임계구역 문제&lt;/h2&gt;

&lt;p&gt;임계구역(critical section) 문제는 n개의 프로세스가 공유 데이터를 동시에 사용하길 윈하는 경우에 발생한다.&lt;/p&gt;

&lt;p&gt;각 프로세스의 code segment 에는 공유 데이터를 접근하는 코드인 임계구역이 존재하는데 이 임계구역을 동시에 접근하는 경우 문제가 발생한다. 이러한 문제는 하나의 프로세스가 임계구역에 있을 때 다른 프로세스가 들어가지 못하도록 막음으로써 해결할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sun, 11 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/8-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3-%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA-1/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/8-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3-%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA-1/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>[#7] CPU 스케쥴링-2</title>
        <description>&lt;h2 id=&quot;스케쥴링의-성능-평가&quot;&gt;스케쥴링의 성능 평가&lt;/h2&gt;

&lt;h3 id=&quot;cpu-이용률&quot;&gt;CPU 이용률&lt;/h3&gt;

&lt;p&gt;CPU 이용률은 전체 시간 중에서 CPU가 일을 한 시간의 비율이다. CPU가 일을 하지 않고 휴면(idle) 상태에 머무르는 시간을 최소화하는 것이 스케쥴링의 중요한 목표이다.&lt;/p&gt;

&lt;h3 id=&quot;처리량throughput&quot;&gt;처리량(throughput)&lt;/h3&gt;

&lt;p&gt;처리량은 주어진 시간 동안 CPU 버스트를 완료한 프로세스의 개수를 나타낸다. 즉, CPU를 원하는 프로세스들 중 몇 개가 원하는 만큼의 CPU를 사용하고 CPU 버스트를 끝내서 준비 큐로부터 나갔는지를 측정하는 것이다. 보다 많은 프로세스가 CPU 작업을 완료하기 위해서는 CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 할당하는 것이 유리하다.&lt;/p&gt;

&lt;h3 id=&quot;소요시간turnaround-time&quot;&gt;소요시간(turnaround time)&lt;/h3&gt;

&lt;p&gt;소요시간은 프로세스가 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간을 말한다. 즉, 준비 큐에서 기다린 시간과 실제로 CPU를 사용한 시간의 합을 뜻한다. 소요시간은 CPU 버스트마다 별도로 측정된다.&lt;/p&gt;

&lt;h3 id=&quot;대기시간waiting-time&quot;&gt;대기시간(waiting time)&lt;/h3&gt;

&lt;p&gt;대기시간은 CPU 버스트 기간 중 어떤 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합을 뜻한다. 시분할 방식으로 CPU를 사용하기 때문에 한 번의 CPU 버스트 중에도 준비 큐에서 CPU를 얻기 위해 기다리는 일이 여러번 일어나게 된다. 이 시간들을 전부 합한 것이 대기시간이다.&lt;/p&gt;

&lt;h3 id=&quot;응답시간response-time&quot;&gt;응답시간(response time)&lt;/h3&gt;

&lt;p&gt;응답시간은 프로세스가 준비 큐에 들어온 후 처음으로 CPU를 획득하기까지 기다린 시간을 뜻한다. 대기시간과 다르게 준비큐에 들어온 직후부터 처음으로 CPU를 얻을때까지의 시간만을 측정한다. 타이머 인터럽트가 빈번히 발생할수록 각 프로세스가 CPU를 점유하고 있는 시간이 짧고 처음으로 CPU를 얻기까지 기다리는 시간이 짧아지므로 응답시간이 향상된다. 이를 통해 알 수 있듯 응답시간은 대화형 시스템에 적합한 척도이다.&lt;/p&gt;

&lt;h2 id=&quot;스케쥴링-알고리즘&quot;&gt;스케쥴링 알고리즘&lt;/h2&gt;

&lt;h3 id=&quot;선입선출-스케쥴링first-come-first-served-fcfs&quot;&gt;선입선출 스케쥴링(First-Come First-Served: FCFS)&lt;/h3&gt;

&lt;p&gt;선입선출 스케쥴링은 준비큐에 들어온 순서대로 CPU를 할당하는 방식을 말한다. CPU 버스트가 짧은 프로세스가 긴 프로세스보다 나중에 도착해 오랜 시간을 기다려야 하는 현상을 콘보이 현상(Convoy effect)라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;최단작업-우선-스케쥴링shortest-job-first-sjf&quot;&gt;최단작업 우선 스케쥴링(Shortest-Job First: SJF)&lt;/h3&gt;

&lt;p&gt;최단작업 우선 스케쥴링 알고리즘은 CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식이다. SJF 스케쥴링 알고리즘은 평균 대기시간을 가장 짧게 하는 최적 알고리즘으로 알려져있다. SJF 알고리즘은 비선점형 방식(nonpreemptive)과 선점형 방식(preemptive)으로 구현될 수 있는데 비선점형 방식은 CPU를 획득하면 자진 반납하기 전까지 CPU를 뺏지 않는 방식이다. 반면 선점형 방식은 현재 CPU를 점유하고 있는 프로세스보다 CPU 버스트가 더 짧은 프로세스가 도착하면 CPU를 빼앗는 방식이다. 이러한 SJF의 선점형 구현 방식을 SRTF(Shortest Remaining Time First)라고 부른다.&lt;/p&gt;

&lt;p&gt;프로세스들이 준비 큐에 도착하는 시간이 불규칙적인 환경에서는 SRTF 방식이 프로세스들의 평균 대기시간을 최소화하는 최적의 알고리즘이 된다. 반면 일련의 프로세스들이 한꺼번에 준비 큐에 도착하고 그 후에 추가적인 프로세스가 도착하지 않는 환경에서는 선점형 방식과 비선점형 방식의 성능차이가 없다. 하지만 일반적인 시분할 환경에서는 중간중간 새로운 프로세스가 도착하는 경우가 있으므로 SRTF 방식이 평균 대기시간을 가장 많이 줄일 수 있는 방식이다.&lt;/p&gt;

&lt;p&gt;위에서 설명한 SJF 기법을 이용하여 스케쥴링을 하기 위해서는 프로세스의 CPU 버스트 시간을 미리 알고 있다는 전제가 있어야 한다. 그러나 현실에서 이는 불가능에 가까우므로 예측을 통해 CPU 버스트 시간을 구한다. (n+1)번째 CPU 버스트의 예측시간은 n번째에 예측한 CPU 버스트 시간과 측정해서 얻은 실제 CPU 버스트 시간을 부분적으로 합하여 얻어낸다. 이 때 부분적으로 합하는 과정에서 필요한 각각의 비율(모든 비율을 합하면 1이 나온다.)은 매개변수로 지정해줘야한다. 이를 풀어서 식으로 작성하면 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/OS/6/render.png&quot; alt=&quot;render&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SJF 알고리즘은 평균 대기시간을 최소화하는 알고리즘이지만 시스템에서 단순히 평균치를 줄이는 것이 최선이 아닌 경우도 있다. CPU 버스트가 짧은 프로세스에게만 CPU를 할당할 경우 CPU 버스트가 긴 프로세스는 준비 큐에서 무한히 기다리는 상황이 발생할 수도 있기 때문이다. 이러한 현상을 기아 현상(starvation) 이라 한다.&lt;/p&gt;

&lt;h3 id=&quot;우선순위-스케쥴링priority-scheduling&quot;&gt;우선순위 스케쥴링(priority scheduling)&lt;/h3&gt;

&lt;p&gt;우선순위 스케쥴링이란 준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식을 말한다. 우선순위값(priority numeber)이 작을수록 높은 우선순위를 가지며 우선순위를 결정하는 방식은 다양할 수 있다. SJF 기법과 마찬가지로 우선순위 스케쥴링은 기아 현상을 피하기 어려운데 이를 해결하기 위해 노화(aging) 기법을 사용할 수 있다. 노화 기법이란 기다리는 시간이 길어지면 우선순위를 조금씩 높여 언젠가는 CPU를 할당받을 수 있도록 해주는 기법이다.&lt;/p&gt;

&lt;h3 id=&quot;라운드-로빈-스케쥴링round-robin-scheduling&quot;&gt;라운드 로빈 스케쥴링(Round Robin Scheduling)&lt;/h3&gt;

&lt;p&gt;라운드 로빈 스케쥴링은 시분할 시스템의 성질을 가장 잘 활용한 스케쥴링 기법이다. 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 특정 시간으로 제한되며, 이 시간이 경과하면 다른 프로세스에게 CPU를 할당한다. 이때 각 프로세스마다 한 번에 CPU를 연속적으로 사용할 수 있는 최대시간을 할당시간(time quantum)이라 부르며 할당시간이 너무 길면 FCFS에서의 문제점이 그대로 나타나게 되고 너무 짧으면 문맥교환으로 인한 오버헤드가 지나치게 커지므로 적절한 값을 할당해주어야 한다.&lt;/p&gt;

&lt;p&gt;라운드 로빈 스케쥴링은 이질적인 프로세스가 같이 실행되는 환경에서 효과적이다. n개의 프로세스가 q라는 할당 시간을 가지고 라운드 로빈 스케쥴링을 적용하였다고 가정하면 (n-1)q 시간 안에 반드시 CPU를 할당받는 것이 보장된다. 이와 같은 방식은 대화형 프로세스의 빠른 응답시간을 보장할 수 있다. 각 프로세스의 CPU 버스트 시간에 비례하는 대기시간이 소요되기 때문에 CPU 버스트가 긴 프로세스에게 불이익이 가지도 않는다.&lt;/p&gt;

&lt;h2 id=&quot;멀티레벨-큐&quot;&gt;멀티레벨 큐&lt;/h2&gt;

&lt;h3 id=&quot;멀티레벨-큐-1&quot;&gt;멀티레벨 큐&lt;/h3&gt;

&lt;p&gt;멀티레벨 큐란 준비 큐를 여러 개로 분할해 관리하는 스케쥴링 기법이다. 어떤 줄을 우선적으로 처리할 것인지, 프로세스가 도착했을 때 어떤 줄에 줄을 세워야 할 것인지 등을 결정하는 메커니즘이 필요하다. 성격이 다른 프로세스들을  별도로 관리하고 프로세스의 성격에 맞는 스케쥴링 기법을 적용하기 위해 멀티레벨 큐가 사용된다.&lt;/p&gt;

&lt;h3 id=&quot;전위foreground-큐와-후위background-큐&quot;&gt;전위(foreground) 큐와 후위(background) 큐&lt;/h3&gt;

&lt;p&gt;멀티레벨 큐에서 준비 큐는 대화형 작업을 담기 위한 전위 큐와 계산 위주의 작업을 담는 후위 큐로 분할하여 운영한다. 전위 큐의 경우에는 응답시간을 짧게 하기 위해 라운드 로빈 기법을 사용하는 반면 후위 큐의 경우에는 응답시간이 큰 의미가 없으므로 FCFS 기법을 통해 문맥교환 오버헤드를 줄이도록 한다.&lt;/p&gt;

&lt;h3 id=&quot;큐-자체에-대한-스케쥴링&quot;&gt;큐 자체에 대한 스케쥴링&lt;/h3&gt;

&lt;p&gt;멀티레벨 큐에서는 준비 큐가 여러개이므로 이 큐들에 대한 스케쥴링도 필요하다. 큐에 우선순위를 할당하여 우선순위가 높은 큐를 먼저 서비스하고 우선순위가 낮은 큐는 우선순위가 높은 큐가 비어있을 때만 서비스하게 된다. 이와는 다르게 타임 슬라이스(time slice) 방식을 택하는 경우도 있다. 타임 슬라이스 방식은 각 큐에 CPU 시간을 적절히 비율로 할당해 분배하는 방식으로 기아 현상을 해결할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;멀티레벨-피드백-큐&quot;&gt;멀티레벨 피드백 큐&lt;/h2&gt;

&lt;h3 id=&quot;멀티레벨-피드백-큐-1&quot;&gt;멀티레벨 피드백 큐&lt;/h3&gt;

&lt;p&gt;멀티레벨 피드백 큐는 프로세스를 여러 큐에 줄을 세운다는 점에서 멀티레벨 큐와 동일하지만 프로세스가 하나의 큐에서 다른 큐로 이동이 가능하다는 차이점이 있다. 노화 기법을 사용하여 우선순위가 높은 큐로 프로세스를 승격시키기는 등의 작업이 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;운영-방식&quot;&gt;운영 방식&lt;/h3&gt;

&lt;p&gt;멀티레벨 피드백 큐의 대표적인 방식은 아래의 그림과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/OS/6/MultilevelFeedbackQueues.png&quot; alt=&quot;MultilevelFeedbackQueues&quot; style=&quot;zoom: 33%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림에서 상위로 갈수록 우선순위가 높은 큐이며 상위 두개의 큐는 라운드 로빈 방식을, 가장 하단의 큐는 FCFS 방식을 사용한다고 가정하자. 모든 프로세스는 도착시 최상위 큐에가서 줄을 선다. 만약 할당시간(quantum)동안 작업이 끝나지 않았다면 하위 큐로 이동하여 순서를 기다린다. 이러한 방식을 사용하면 프로세스의 CPU 작업시간을 다단계로 분류함으로써 작업시간이 짧은 프로세스일수록 더욱 빠른 서비스가 가능해지고 작업시간이 긴 프로세스는 문맥교환으로 인한 오버헤드를 최소화 시키며 작업시킬 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;다중처리기-스케쥴링&quot;&gt;다중처리기 스케쥴링&lt;/h2&gt;

&lt;h3 id=&quot;다중처리기-시스템&quot;&gt;다중처리기 시스템&lt;/h3&gt;

&lt;p&gt;다중처리기 시스템(multi-processor-system)이란 CPU가 여러 개인 시스템을 말한다. CPU가 여러 개이므로 프로세스들을 줄을 세운 뒤 각 CPU가 알아서 다음 프로세스를 꺼내가도록 지시한다. 마치 여러 개의 은행 창구에서 손님을 순서대로 맡아 처리하는 것과 유사하다. 하지만 반드시 특정 CPU에서 수행되어야 하는 프로세스가 있는 경우에는 문제가 더 복잡해진다. 이런 상황에는 각 CPU별로 프로세스를 줄세워 문제를 해결할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;다중처리기-스케쥴링-1&quot;&gt;다중처리기 스케쥴링&lt;/h3&gt;

&lt;p&gt;여러 줄로 줄을 세우는 경우 일부 CPU에 작업이 편중되는 현상이 발생할 수 있다. 다중처리기 스케쥴링에서는 이를 해결하기 위해 CPU별 부하를 적절히 분산되도록 관리한다. 이를 부하균형(load balancing) 메커니즘이라 하며 대칭형 다중처리(symmetric)와 비대칭형 다중처리(asymmetric)로 분류할 수 있다. 대칭형 다중 처리는 각 CPU가 각자 알아서 스케쥴링르 결정하는 방식이고, 비대칭형 다중처리는 하나의 CPU가 모든 CPU의 스케쥴링 및 데이터 접근을 책임지고 나머지 CPU는 그에 따라 움직이는 방식을 말한다.&lt;/p&gt;

&lt;h2 id=&quot;실시간-스케쥴링&quot;&gt;실시간 스케쥴링&lt;/h2&gt;

&lt;h3 id=&quot;hard-real-time-system-soft-real-time-system&quot;&gt;Hard real-time system, Soft real-time system&lt;/h3&gt;

&lt;p&gt;하드 리얼 타임 시스템은 반드시 지켜져야 하는 데드라인이 존재하는 프로그램에 사용된다. 미사일 발사, 원자로 제어 등 정확한 시간을 지킬 것이 요구되는 경우가 대표적이다. 반면 소프트 리얼 타임 시스템은 데드라인이 존재하지만 데드라인을 지키지 못하더라도 위험한 상황이 발생하지 않는 시스템이다. 위에서 살펴본 스케쥴링 방식들은 데드라인이 정해져 있지 않았지만 실시간 환경에서의 스케쥴링은 평균적으로 빠른 서비스보다도 데드라인을 지키는 서비스가 더 중요할 수도 있다. 이런 경우에는 보통 EDF(Earliest Deadline Frist) 스케쥴링을 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;스케쥴링-알고리즘의-평가&quot;&gt;스케쥴링 알고리즘의 평가&lt;/h2&gt;

&lt;h3 id=&quot;큐잉모델&quot;&gt;큐잉모델&lt;/h3&gt;

&lt;p&gt;스케쥴링 알고리즘의 성능을 평가하는 방식 중 하나인 큐잉모델은 주로 이론가들이 확률분포를 통해 프로세스들의 도착률과 CPU 처리율을 바탕으로 각종 성능지표인 CPU 처리량, 프로세스의 평균 대기시간 등을 구하여 성능을 평가하는 방식이다.&lt;/p&gt;

&lt;h3 id=&quot;구현-및-실측&quot;&gt;구현 및 실측&lt;/h3&gt;

&lt;p&gt;구현 및 실측은 큐잉모델과는 반대로 구현가들이 수행할 수 있는 방식으로 실행시간을 직접 측정하여 알고리즘의 성능을 평가하는 방식이다.&lt;/p&gt;

&lt;h3 id=&quot;시뮬레이션&quot;&gt;시뮬레이션&lt;/h3&gt;

&lt;p&gt;시뮬레이션은 실제 시스템에 구현해 수행시켜보는 것이 아닌 가상으로 CPU 스케쥴링 프로그램을 작성한 후 프로그램의 CPU 요청을 입력값으로 넣어 어떤 결과가 나온느지를 확인하는 방법이다 . 입력값은 가상의 값일 수도 있고 실제 시스템에서의 CPU 요청 내역을 추출하여 사용할 수도 있다. 이때 시스템에서 추출한 입력값을 트레이스(trace)라고 한다.&lt;/p&gt;
</description>
        <pubDate>Sun, 11 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/7-CPU-%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%B2%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC-2/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/7-CPU-%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%B2%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC-2/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>2021년 04월 09일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;h3 id=&quot;scroll-view를-코드로-구현하는-법에-대해-공부했습니다&quot;&gt;Scroll View를 코드로 구현하는 법에 대해 공부했습니다.&lt;/h3&gt;

&lt;p&gt;스토리보드로 구성하는 방법과 (애플 공식 가이드) 코드로 짜는 방법이 상당히 달라서 고전했습니다.&lt;/p&gt;

&lt;p&gt;코드로 스크롤뷰를 구성하는 경우 Content View를 Scroll View 위에 별도로 올릴 필요가 없습니다.&lt;/p&gt;

&lt;p&gt;Scroll View 위에 view들을 추가시켜주되 &lt;strong&gt;가장 하단의 view를 Scroll View의 bottom constraint와 관계를 맺어주는 작업을 반드시 진행해줘야합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 작업을 진행해줘야 스크롤이 가능하다는 사실을 여러번의 시행착오와 흰의 도움을 통해 알게되었습니다. (고마워요 흰!)&lt;/p&gt;

&lt;p&gt;크게 두가지 방법이 있는데&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;content view를 생성하는 경우
    &lt;ol&gt;
      &lt;li&gt;content view의 anchor들을 scroll view와 이어줌 (bottom anchor를 꼭 이어줘야함)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;바로 ScrollView 위에 얹는 경우
    &lt;ol&gt;
      &lt;li&gt;view들을 차례로 얹고 마지막 view를 scroll view의 bottom anchor와 연결해줌&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;가로로 스크롤 할거라면 당연 trailing anchor에 연결해주면 될 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;stack-view에-대해-알아봤습니다&quot;&gt;Stack View에 대해 알아봤습니다.&lt;/h3&gt;

&lt;p&gt;addArrangedSubview는 arrangedSubviews에 포함되어있는 instance에 대해서는 작동하지 않는다는 사실을 알게되었습니다.&lt;/p&gt;

&lt;p&gt;The stack view ensures that the &lt;a href=&quot;https://developer.apple.com/documentation/uikit/uistackview/1616232-arrangedsubviews&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arrangedSubviews&lt;/code&gt;&lt;/a&gt; array is always a subset of its &lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiview/1622614-subviews&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subviews&lt;/code&gt;&lt;/a&gt; array. This method automatically adds the provided view as a subview of the stack view, if it is not already. If the view is already a subview, this operation does not alter the subview ordering.&lt;/p&gt;

&lt;p&gt;오픈카톡방에서 이를 어떻게 해결할지 여쭤봤고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;라이노&lt;/code&gt;님의 답변을 통해 똑같이 생긴 view라고 같은 instance를 쓰는건 잘못됐다는 사실을 알게되었습니다.&lt;/p&gt;
</description>
        <pubDate>Fri, 09 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.09-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.09-TIL/</guid>
        
        <category>Scroll View</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>2021년 04월 08일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;h3 id=&quot;accessibility에-대해-공부했습니다&quot;&gt;Accessibility에 대해 공부했습니다&lt;/h3&gt;

&lt;p&gt;어떻게하면 시각 장애인들도 앱을 사용할 수 있을까? 와 같은 의문에 대답하는 것이 접근성입니다. 화면에 있는 item들을 순서대로 읽어주는 기능을 자체적으로 가지고 있지만 프로그래머가 accessibility 관련 설정을 해주지 않으면 사용하기 어렵습니다. 지난 쥬스 메이커 프로젝트의 accessibilityLabel과 accessibilityValue를 설정해주어봤습니다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;StockLabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UILabel&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Fruit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;FruitType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strawberry&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;accessibilityLabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newValue&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;accessibilityValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;개&quot;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newValue&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dynamic-types&quot;&gt;Dynamic types&lt;/h3&gt;

&lt;p&gt;시스템 설정에서 글자 크기를 조절했을 때 나의 앱에서 글자 크기가 변경되도록 해주려면 dynamic type에 대해 알고 있어야합니다. 글자를 담고 있는 layer가 글자의 크기를 견디지 못할수도 있으며, 글자의 크기가 너무 커져서 중요한 그림 혹은 버튼이 화면에서 사라질수도 있습니다. 이것을 priority를 통해 적절히 해결해야합니다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;strawBananaButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;titleLabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adjustsFontSizeToFitWidth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;strawBananaButton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;titleLabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;minimumScaleFactor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.3&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;custom font를 사용하는 경우에는 설정해줘야하는 부분들이 매우 많아 잘 사용하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;adjustsFontSizeToFitWidth&lt;/code&gt;를 통해 layer의 크기에 맞게 font 사이즈를 조절해줄수 있으며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;minimumScaleFactor&lt;/code&gt;를 통해 원본의 몇 %까지만 글자가 작아지도록 설정할수도 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;autolayout-강의를-수강하고-정리해봤습니다&quot;&gt;AutoLayout 강의를 수강하고 정리해봤습니다&lt;/h3&gt;

&lt;p&gt;코드로 UI를 작성하는 방법에 대해 알아보고 실습을 진행해봤습니다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;setTitle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Button&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;setTitleColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;backgroundColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;systemGreen&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addSubview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;//AutoresizingMask란걸 constraint로 자동으로 전환해줄거야? 물어보는 프로퍼티&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//나중에 공부해보자!&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;translatesAutoresizingMaskIntoConstraints&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;safeArea&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;safeAreaLayoutGuide&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// safe Area의 영역을 나타내는 가이드&lt;/span&gt;
        
        &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leadingAnchor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;constraint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;equalTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safeArea&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leadingAnchor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;constant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isActive&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// NSLayoutConstraint의 객체를 만들어주고 바로 활성화&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//constraint는 활성화 상태와 비활성화 상태가 있음&lt;/span&gt;
        
        &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trailingAnchor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;constraint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;equalTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safeArea&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trailingAnchor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;constant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isActive&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;safebottomAnchor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bottomAnchor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;constraint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;equalTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safeArea&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bottomAnchor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
        &lt;span class=&quot;n&quot;&gt;safebottomAnchor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isActive&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;safebottomAnchor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priority&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defaultHigh&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//init으로 바꿔줄수도 있음&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;viewBottomAnchor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bottomAnchor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;constraint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;lessThanOrEqualTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bottomAnchor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;constant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
        &lt;span class=&quot;n&quot;&gt;viewBottomAnchor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isActive&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;NSLayout의 이니셜라이저를 사용하는 방법과 constraint 속성을 사용하는 방법이 있다는걸 알게 되었습니다.&lt;/p&gt;
</description>
        <pubDate>Thu, 08 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.08-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.08-TIL/</guid>
        
        <category>Scroll View</category>
        
        <category>Table View</category>
        
        <category>Accessibility</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>2021년 04월 06일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;json-파일을-디코딩하는-방법에-대해-공부했습니다&quot;&gt;JSON 파일을 디코딩하는 방법에 대해 공부했습니다.&lt;/h3&gt;

&lt;p&gt;JSON 파일이 어떻게 구성되어있는지 파악한 뒤  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Decodable&lt;/code&gt;프로토콜을 채용한 타입을 JSON 파일 구성에 맞게 제작하는 방식으로 디코딩이 이루어지는 것을 알게되었습니다. Swift는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;camleCasing&lt;/code&gt;을 지향하지만 JSON 파일은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;snakeCasing&lt;/code&gt;으로 작성된 경우가 많습니다. 이를 해결하기 위해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CodingKey&lt;/code&gt;라는 프로토콜을 채택하여 원하는 꼴로 모양을 맞춰줄 수 있었습니다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Decodable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;imageName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;shortDescription&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CodingKeys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CodingKey&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imageName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;image_name&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shortDescription&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;short_desc&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;description&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;desc&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;고민중인-부분&quot;&gt;고민중인 부분&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;JSON 파일을 프로그래머가 일일이 분석해서 타입을 만들어야되는 것일까? 에 대한 의문이 있습니다.&lt;/li&gt;
  &lt;li&gt;Asset 폴더를 통채로 넣었을 때 파일 경로를 통한 탐색이 진행되어야 할 줄 알았는데 Xcode가 자동으로 이미지와 json파일을 분류해줬습니다. 이것이 이미지 파일명 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;folds~universal@1x.png&lt;/code&gt;)를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;idiom&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scale&lt;/code&gt;을 자동으로 분류해주는 것으로 추측되지만 자세한건 내일 더 알아보기로 했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;error-핸들링에-대해-더-알아보았습니다&quot;&gt;Error 핸들링에 대해 더 알아보았습니다.&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://rhino-developer.tistory.com/entry/Swift-ErrorHandling&quot;&gt;라이노님의 글&lt;/a&gt;과 &lt;a href=&quot;https://wlaxhrl.tistory.com/53&quot;&gt;찜토끼님의 글&lt;/a&gt;을 통해 error case에 associated value를 줄 수 있는 방법에 대해 알게되었고 이에 대해 공부하고 있습니다. 이번 만국박람회 프로젝트에서 사용해보기로 했습니다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JsonDecodingError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dataCorrupted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;keyNotFound&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;valueNotFound&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Tue, 06 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.06-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.06-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>[#6] CPU 스케쥴링-1</title>
        <description>&lt;h2 id=&quot;cpu-스케쥴링&quot;&gt;CPU 스케쥴링&lt;/h2&gt;

&lt;h3 id=&quot;add-load-store-명령&quot;&gt;Add, Load, Store 명령&lt;/h3&gt;

&lt;p&gt;CPU 명령에는 덧셈을 진행하는 Add, 메모리 접근을 수행하는 Load, Store 명령이 있다. Load, Store 명령어는 Add 명령에 비해서는 느리지만 비교적 짧은 시간이 드는 명령이며, Add 명령과 마찬가지로 사용자 프로그램이 직접 실행할 수 있는 일반명령에 해당한다.&lt;/p&gt;

&lt;h3 id=&quot;cpu-버스트와-io-버스트&quot;&gt;CPU 버스트와 I/O 버스트&lt;/h3&gt;

&lt;p&gt;사용자 프로그램은 CPU 작업(CPU busrt)과 I/O 작업(I/O burst)의 반복으로 구성된다. 이는 CPU와 I/O라는 서로 다른 자원을 번갈아 사용하며 프로그램이 수행되는 것으로 볼 수 있다. 대부분의 프로세스는 다수의 짧은 CPU 버스트와 소수의 긴 CPU 버스트로 구성된다. 이렇게 짧은 CPU 버스트가 대부분인 프로세스를 I/O 바운드 프로세스라 하며, 이에 반대되는 프로세스를 CPU 바운드 프로세스라 한다.&lt;/p&gt;

&lt;h3 id=&quot;cpu-스케쥴링의-필요성&quot;&gt;CPU 스케쥴링의 필요성&lt;/h3&gt;

&lt;p&gt;각 프로그램마다 CPU 버스트와 I/O 버스트가 차지하는 비율이 다르기 때문에 CPU 스케쥴링 작업이 필요하다.  CPU 버스트가 짧은 프로세스는 대부분 대화형 작업(interactive job)으로 사용자와 인터랙션을 해야하기 때문에 CPU의 빠른 서비스를 필요로 하며 이에 CPU 스케쥴러는 I/O 바운드 프로세스가 우선적으로 CPU를 사용할 수 있도록 해준다. 이 작업은 대화형 프로세스에게 빠른 응답성을 제공해줌과 도시에 I/O 장치의 효율성도 높이는데 I/O 바운드 프로세스는 CPU를 잠깐만 사용한 뒤 다시 I/O 작업을 수행하기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;cpu-스케쥴러&quot;&gt;CPU 스케쥴러&lt;/h2&gt;

&lt;h3 id=&quot;cpu-스케쥴러의-동작과정&quot;&gt;CPU 스케쥴러의 동작과정&lt;/h3&gt;

&lt;p&gt;CPU 스케쥴러는 준비 상태에 있는 프로세스들 중 어떤한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드이다. 프로세스 실행 중 타이머 인터럽트가 발생하면 CPU 스케쥴러가 호출된다. 그럼 이 때 CPU 스케쥴러는 준비 큐에서 프로세스를 하나 선택해 CPU를 할당하게 된다.&lt;/p&gt;

&lt;h3 id=&quot;cpu-스케쥴링이-필요한-몇-가지-경우들&quot;&gt;CPU 스케쥴링이 필요한 몇 가지 경우들&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;실행 상태에 있던 프로세스가 I/O 요청 등에 의해 봉쇄 상태로 바뀌는 경우&lt;/li&gt;
  &lt;li&gt;실행 상태에 있던 프로세스가 타이머 인터럽트 발생에 의해 준비 상태로 바뀌는 경우&lt;/li&gt;
  &lt;li&gt;I/O 요청으로 봉쇄 상태에 있던 프로세스가 I/O 작업이 완료되어 인터럽트가 발생하고 그 결과 이 프로세스의 상태가 준비 상태로 바뀌는 경우&lt;/li&gt;
  &lt;li&gt;CPU에서 실행 상태에 있는 프로세스가 종료되는 경우&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;선점형-방식과-비선점형-방식&quot;&gt;선점형 방식과 비선점형 방식&lt;/h3&gt;

&lt;p&gt;CPU 스케쥴링 방식에는 선점형 방식과 비선점형 방식이 있는데 비선점형 방식은 CPU를 획득한 프로세스가 스스로 반납하기 전까지 CPU를 빼앗지 않지만 선점형 방식은 CPU를 강제로 빼앗을 수 있다. 위의 스케쥴링이 필요한 몇 가지 경우 중 1번과 4번은 비선점형 스케쥴링의 예이며, 2번과 3번은 선점형 스케쥴링 방식의 예에 해당한다. 3번은 이번에 I/O 작업이 완료된 프로세스가 인터럽트 당한 프로세스보다 우선순위가 높아서 곧바로 CPU를 획득하는 경우이다.&lt;/p&gt;

&lt;h2 id=&quot;디스패처&quot;&gt;디스패처&lt;/h2&gt;

&lt;h3 id=&quot;cpu의-이양-작업&quot;&gt;CPU의 이양 작업&lt;/h3&gt;

&lt;p&gt;어떤 프로세스에게 CPU를 할당할지가 결정되고 나면 선택된 프로세스에게 CPU를 이양하는 작업이 필요하다. 이런 작업을 해주는 운영체제의 코드를 디스패처(dispatcher)라고 부른다.&lt;/p&gt;

&lt;h3 id=&quot;디스패처-1&quot;&gt;디스패처&lt;/h3&gt;

&lt;p&gt;디스패처는 현재 수행 중이던 프로세스의 문맥을 그 프로세스의 PCB에 저장하고 이번에 CPU를 할당할 프로세스의 PCB로부터 문맥을 복원한 뒤 CPU를 넘겨준다. 프로세스 문맥 복원 뒤에 시스템의 상태를 사용자모드로 전환해 사용자 프로그램에게 CPU 제어권을 넘기게 된다. 디스패처가 하나의 프로세스를 정지시키고 다음 프로세스에게 CPU를 넘기는 과정에서 걸리는 시간을 디스패치 지연시간(dispatch latency)라고 하며 대부분 문맥교환 오버헤드가 디스패치 지연시간을 이루고 있다.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/6-CPU-%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%B2%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC-1/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/6-CPU-%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%B2%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC-1/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>[#5] 프로세스 관리 - 2</title>
        <description>&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;
&lt;ol id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#목차&quot; id=&quot;markdown-toc-목차&quot;&gt;목차&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#프로세스의-생성&quot; id=&quot;markdown-toc-프로세스의-생성&quot;&gt;프로세스의 생성&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#부모-프로세스와-자식-프로세스&quot; id=&quot;markdown-toc-부모-프로세스와-자식-프로세스&quot;&gt;부모 프로세스와 자식 프로세스&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#자원의-획득과-프로세스의-수행모델&quot; id=&quot;markdown-toc-자원의-획득과-프로세스의-수행모델&quot;&gt;자원의 획득과 프로세스의 수행모델&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#주소-공간&quot; id=&quot;markdown-toc-주소-공간&quot;&gt;주소 공간&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#프로세스의-생성-절차&quot; id=&quot;markdown-toc-프로세스의-생성-절차&quot;&gt;프로세스의 생성 절차&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#프로세스의-종료-절차&quot; id=&quot;markdown-toc-프로세스의-종료-절차&quot;&gt;프로세스의 종료 절차&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#프로세스의-강제-종료가-이루어지는-경우&quot; id=&quot;markdown-toc-프로세스의-강제-종료가-이루어지는-경우&quot;&gt;프로세스의 강제 종료가 이루어지는 경우&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#자식-프로세스를-생성하는-과정&quot; id=&quot;markdown-toc-자식-프로세스를-생성하는-과정&quot;&gt;자식 프로세스를 생성하는 과정&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#프로세스-간의-협력&quot; id=&quot;markdown-toc-프로세스-간의-협력&quot;&gt;프로세스 간의 협력&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#독립적-프로세스&quot; id=&quot;markdown-toc-독립적-프로세스&quot;&gt;독립적 프로세스&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#협력-프로세스와-협력-메커니즘&quot; id=&quot;markdown-toc-협력-프로세스와-협력-메커니즘&quot;&gt;협력 프로세스와 협력 메커니즘&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ipc--메시지-전달-방식&quot; id=&quot;markdown-toc-ipc--메시지-전달-방식&quot;&gt;IPC :: 메시지 전달 방식&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#메시지-전달-방식&quot; id=&quot;markdown-toc-메시지-전달-방식&quot;&gt;메시지 전달 방식&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#직접통신과-간접통신&quot; id=&quot;markdown-toc-직접통신과-간접통신&quot;&gt;직접통신과 간접통신&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ipc--공유메모리-방식&quot; id=&quot;markdown-toc-ipc--공유메모리-방식&quot;&gt;IPC :: 공유메모리 방식&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#주소공간의-공유&quot; id=&quot;markdown-toc-주소공간의-공유&quot;&gt;주소공간의 공유&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#일관성-문제&quot; id=&quot;markdown-toc-일관성-문제&quot;&gt;일관성 문제&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;프로세스의-생성&quot;&gt;프로세스의 생성&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;부모-프로세스와-자식-프로세스&quot;&gt;부모 프로세스와 자식 프로세스&lt;/h3&gt;

&lt;p&gt;시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만 그다음부터는 이미 존재하던 프로세스가 다른 프로세스를 복제 생성한다. 프로세스는 항상 자식 프로세스가 먼저 종료되고나서 부모 프로세스가 종료된다. 후손이 여러개인 (자식의 자식으로 이어지는 계층도가 긴) 프로세스의 경우에는 연쇄적으로 모든 후손 프로세스들을 종료시킨 뒤에 종료된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;자원의-획득과-프로세스의-수행모델&quot;&gt;자원의 획득과 프로세스의 수행모델&lt;/h3&gt;

&lt;p&gt;생성된 프로세스가 작업을 수행하기 위해서는 자원이 필요하다. 운영체제로부터 &lt;strong&gt;직접 자원을 할당받는 경우&lt;/strong&gt;도 있고 &lt;strong&gt;부모 프로세스와 자식 프로세스가 자원을 공유하는 경우&lt;/strong&gt;(일부만 공유하는 경우, 전부를 공유하는 경우로 나뉨)도 있다. 프로세스가 수행되는 모델도 &lt;strong&gt;부모와 자식이 공존하며 수행되는 모델&lt;/strong&gt;이 있고, &lt;strong&gt;부모가 자식이 종료될때까지 기다리는 모델&lt;/strong&gt;도 있다. 전자의 경우에는 CPU 획득을 위해 서로 경쟁하는 관계가 된다. 반면 후자의 경우에는 자식 프로세스가 종료되기 전까지 부모 프로세스는 봉쇄 상태에 머물러 있다가 자식 프로세스가 종료되면 준비 상태가 되어 CPU를 얻을 권한이 생기게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;주소-공간&quot;&gt;주소 공간&lt;/h3&gt;

&lt;p&gt;프로세스가 생성되면 독자적인 주소 공간을 갖게 된다. 부모 프로세스와 자식 프로세스는 별도의 주소 공간을 가지게 되는데 자식 프로세스는 부모 프로세스의 주소 공간 내용을 그대로 복사하여 생성된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스의-생성-절차&quot;&gt;프로세스의 생성 절차&lt;/h3&gt;

&lt;p&gt;유닉스에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt; 시스템 콜을 통해 새로운 프로세스를 생성할 수 있는데 프로세스 ID를 제외한 모든 정보 즉, 운영체제 커널 내의 정보(PCB, 자원 등)와 주소 공간의 정보를 그대로 복사한다. 복제가 완료되면 그 위에 새로운 프로그램을 덮어씌울 수도 있는데 이 작업은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec()&lt;/code&gt; 시스템 콜을 통해 이루어진다. (exec 작업은 필수가 아님)&lt;/p&gt;

&lt;p&gt;자식 프로세스가 부모 프로세스와 달라지지 않는다면 굳이 복사를 진행할 필요가 없다. 따라서 자식 프로세스에서 변경이 진행될 때 복사를 진행하는 방식을 Copy-On-Write(a.k.a. COW)라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스의-종료-절차&quot;&gt;프로세스의 종료 절차&lt;/h3&gt;

&lt;p&gt;프로세스의 종료는 크게 자발적 종료와 비자발적 종료로 구분된다. 자발적 종료가 이루어지는 경우, 프로세스는 명령을 모두 수행한 후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit()&lt;/code&gt;이라는 시스템 콜을 진행한다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit()&lt;/code&gt;은 프로그래머가 명시적으로 호출하지 않아도 프로그램 종료 지점에 컴파일러가 자동으로 삽입). 운영체제에게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit()&lt;/code&gt;을 통해 자신이 종료될 수 있음을 알리면 운영체제는 자원을 회수하고 시스템 내에서 프로세스를 정리한다. 반면 비자발적 종료의 경우에는 부모 프로세스가 자식 프로세스의 수행을 강제로 종료하는데 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abort()&lt;/code&gt;라는 함수를 통해 이루어진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스의-강제-종료가-이루어지는-경우&quot;&gt;프로세스의 강제 종료가 이루어지는 경우&lt;/h3&gt;

&lt;p&gt;프로세스가 강제 종료되는 경우는 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;자식 프로세스가 한계치를 넘는 자원을 요구할 때&lt;/li&gt;
  &lt;li&gt;자식 프로세스에게 할당된 작업이 더 이상 필요하지 않을 때&lt;/li&gt;
  &lt;li&gt;부모 프로세스가 종료되는 경우&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위와 다르게 부모 프로세스가 종료된 이후에도 실행되어야 할 프로세스가 있다면 해당 프로세스를 다른 프로세스의 자식으로 이양하는 작업이 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;자식-프로세스를-생성하는-과정&quot;&gt;자식 프로세스를 생성하는 과정&lt;/h3&gt;

&lt;p&gt;운영체제는 자식 프로세스의 생성을 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt; 시스템 콜을 제공한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt; 시스템 콜을 하게 되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt; 함수를 호출한 프로세스와 똑같은 프로세스가 생성된다. 이렇게 생성된 자식 프로세스는 부모 프로세스의 모든 문맥을 동일하게 가지고 있으며 부모 프로세스의 주소 공간을 비롯해 프로그램 카운터 등 레지스터 상태, PCB 및 커널 스택 등 모든 문맥을 그대로 복제해 자식 프로세스의 문맥을 형성한다. 즉, 자식 프로세스는 부모 프로세스의 처음부터 수행하는 것이 아니라 현재 수행한 시점(PC 지점)부터 수행하게 된다. 이 둘을 구분하기 위해 부모 프로세스 식별자(pid)는 양수이며 자식 프로세스의 식별자는 0이라는 차이가 존재한다.&lt;/p&gt;

&lt;p&gt;자식 프로세스가 부모와 다른 독자적 프로그램을 수행하도록 만들기 위해선 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec()&lt;/code&gt; 시스템 콜이 필요하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec()&lt;/code&gt; 시스템 콜은 지금까지 수행했던 상태를 잊어버리고 그 주소 공간을 완전히 새로운 프로그램으로 덮어씌운 후 처음부터 시작하도록 만들어준다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec()&lt;/code&gt; 이전 시점까지 프로그램을 실행하다 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec()&lt;/code&gt;을 만나면 새로운 프로그램으로 넘어가서 그 프로그램을 실행하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt; 시스템 콜을 통해 부모 프로세스와 자식 프로세스 간의 동기화가 가능하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt; 시스템 콜이 이루어지면 부모 프로세스는 자식 프로세스가 종료될 때까지 봉쇄상태에 들어가는데 일반적인 봉쇄 상태에서와는 다르게 자원을 기다리며 줄 서 있지 않고 자식 프로세스가 종료될 때까지 수면 상태에 머무른다. 자식 프로세스가 종료되는 순간 준비 큐에 재진입하여 CPU를 얻을 권한을 획득한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로세스-간의-협력&quot;&gt;프로세스 간의 협력&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;독립적-프로세스&quot;&gt;독립적 프로세스&lt;/h3&gt;

&lt;p&gt;프로세스는 자신만의 주소 공간을 가지고 수행되며 다른 프로세스의 주소공간을 참조하는 것은 허용되지 않는다. 프로세스 복제 과정에서 부모 프로세스의 주소 공간을 자식 프로세스가 복제하지만 생성 이후에는 독자적인 주소 공간만을 참조해 코드를 수행하므로 독립적인 관계가 된다.&lt;/p&gt;

&lt;h3 id=&quot;협력-프로세스와-협력-메커니즘&quot;&gt;협력 프로세스와 협력 메커니즘&lt;/h3&gt;

&lt;p&gt;경우에 따라서는 프로세스들이 협력할 때 업무의 효율성이 증진될 수 있다. 이런 프로세스 간 협력 메커니즘은 대표적으로 운영체제가 제공하는 IPC(Inter-Process Communication)가 있다. IPC는 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간의 통신을 의미하며 이러한 통신은 의사소통 기능과 동기화를 보장한다. 공유 데이터를 서로 다른 두 프로세스가 사용할 때 데이터 불일치의 문제를 예방하기 위해 하나의 프로세스가 공유 데이터의 값을 변경하는 동안 다른 프로세스는 그 데이터에 접근할 수 없도록 해야한다. IPC의 대표적인 방법으로는 메시지 전달 방식과 공유메모리 방식이 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ipc--메시지-전달-방식&quot;&gt;IPC :: 메시지 전달 방식&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;메시지-전달-방식&quot;&gt;메시지 전달 방식&lt;/h3&gt;

&lt;p&gt;메시지 전달 방식은 공유 데이터를 사용하지 않고 커널이 메시지를 간접적으로 전달하는 방식이다. 메시지 통신을 하는 시스템은 커널에 의해 send(message)와 receive(message)를 제공받는데 이 두 연산을 통해 시스템 콜 방식으로 정보를 주고받는다.&lt;/p&gt;

&lt;p&gt;통신이 필요한 두 프로세스는 커뮤니케이션 링크를 생성한 후 send()와 receive()를 통해 메시지를 주고받는다. 커뮤니케이션 링크는 물리적으로 구현될수도 있고 논리적으로 구현될수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;직접통신과-간접통신&quot;&gt;직접통신과 간접통신&lt;/h3&gt;

&lt;p&gt;메시지 전달을 통해 통신하는 방식에는 직접통신(direct communication)과 간접통신(indirect communication)이 있다. 이 둘의 차이는 연산의 인터페이스의 차이일 뿐 실제 메시지 전송이 이루어지는 내부 구현은 커널의 중재에 의해 사실상 동일하게 이루어진다.&lt;/p&gt;

&lt;p&gt;직접통신에서는 통신하려는 프로세스의 이름을 명시적으로 표시한다. 커뮤니케이션 링크는 자동적으로 생성되고, 하나의 링크는 오직 한 쌍의 프로세스에게만 할당된다. 또한 각 쌍의 프로세스에는 오직 하나의 링크만이 존재하고 링크는 단방향성인 경우와 양방향성인 경우가 있지만 대부분 양방향성이다.&lt;/p&gt;

&lt;p&gt;간접통신에는 메시지를 메일박스(mail box) 또는 포트(port)로부터 전달받는다. 각 메일박스에는 고유의 ID가 있으며 메일박스를 공유하는 프로세스들만 서로 통신할 수 있다. 간접통신의 경우 커뮤니케이션 링크는 프로세스 간에 메일 박스를 공유하는 경우에만 생성되는데 하나의 링크가 여러 프로세스들에게 할당될 수 있으며 각 프로세스의 쌍은 여러 링크를 공유할 수 있다. 링크는 단방향성과 양방향성 모두 존재하며 send/receive연산, 메일박스 삭제 연산 등이 지원된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ipc--공유메모리-방식&quot;&gt;IPC :: 공유메모리 방식&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;주소공간의-공유&quot;&gt;주소공간의 공유&lt;/h3&gt;

&lt;p&gt;공유메모리 방식에서는 프로세스들이 주소 공간의 일부를 공유한다. 원칙적으로는 각자 독립적인 주소 공간을 가지지만 운영체제가 시스템 콜을 통해 프로세스들이 주소 공간 중 일부를 공유할 수 있도록 해준다. 실제 구현은 두 프로세스가 서로 독자적인 주소 공간을 가지고 있지만 이 주소 공간이 물리적 메모리에 매핑될 때 공유메모리 주소 영역에 대해서는 동일한 물리적 메모리 주소로 매핑된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;일관성-문제&quot;&gt;일관성 문제&lt;/h3&gt;

&lt;p&gt;공유메모리 방식은 프로세스간의 통신을 수월하게 해주지만 서로의 데이터에 일관성 문제가 발생할 수 있다. 이에 대해서는 커널이 책임을 지지 않으므로 프로세스들끼리 직접 공유메모리 접근에 대한 동기화 문제를 해결해야한다.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/5-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3-%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5-2/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/5-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3-%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5-2/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>2021년 04월 05일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;운영체제-5번째-6번째-정리본-업로드-및-스터디-참여&quot;&gt;운영체제 5번째, 6번째 정리본 업로드 및 스터디 참여&lt;/h3&gt;

&lt;p&gt;어느덧 벌써 4번째 스터디가 진행되었습니다. 이번 스터디에서는 5장 프로세스 관리의 후반부와 6장인 CPU 스케쥴링의 전반부를 공부했습니다. 자세한 정리는 아래의 링크들을 참고해주시면 감사하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/5-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC-2/&quot;&gt;5번째 정리글&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/6-CPU-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-1/&quot;&gt;6번째 정리글&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/i-study-OS/BHK/tree/main/OS4&quot;&gt;스터디 repo 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;table-view와-json에-대해-알아보았습니다&quot;&gt;Table View와 JSON에 대해 알아보았습니다&lt;/h3&gt;

&lt;p&gt;JSON 파일을 디코딩하는 방법과 디코딩한 데이터를 Table View의 Cell에 넣는 방법에 대해 공부하고 있습니다. 배운 내용은 추후에 정리해서 블로그에 업로드하겠습니다.&lt;/p&gt;

</description>
        <pubDate>Mon, 05 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.05-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.05-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
  </channel>
</rss>
