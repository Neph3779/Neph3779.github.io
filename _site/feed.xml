<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Neph's Blog</title>
    <description>Write code with my soul.</description>
    <link>https://neph3779.github.io/</link>
    <atom:link href="https://neph3779.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 10 Jun 2021 00:48:35 +0900</pubDate>
    <lastBuildDate>Thu, 10 Jun 2021 00:48:35 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>[#16] File System-2</title>
        <description>&lt;h2 id=&quot;페이지-캐시-버퍼-캐시&quot;&gt;페이지 캐시, 버퍼 캐시&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210606195907.png&quot; alt=&quot;image-20210606195905344&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210606195939.png&quot; alt=&quot;image-20210606195936242&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;페이지-캐시&quot;&gt;페이지 캐시&lt;/h3&gt;

&lt;p&gt;스왑 영역에 있는가? 아닌가? 를 기준으로 캐싱 됨/안됨을 구분하는 방식&lt;/p&gt;

&lt;p&gt;페이지 캐시의 단위: 페이지의 크기 (4Kb)&lt;/p&gt;

&lt;h3 id=&quot;버퍼-캐시&quot;&gt;버퍼 캐시&lt;/h3&gt;

&lt;p&gt;파일 데이터가 파일 저장소에 저장되어있는가? 아니면 운영체제의 버퍼 캐시에 올라와 있는가? 를 기준으로 캐싱 됨/안됨을 구분하는 방식&lt;/p&gt;

&lt;p&gt;버퍼 캐시의 단위: 논리적인 블록 (섹터)의 크기 (512b, disk I/O 단위)&lt;/p&gt;

&lt;h3 id=&quot;유니파이드-버퍼-캐시&quot;&gt;유니파이드 버퍼 캐시&lt;/h3&gt;

&lt;p&gt;페이지 캐시와 버퍼 캐시의 구분 없이 똑같이 페이지 단위로 관리하면서&lt;/p&gt;

&lt;p&gt;필요에 따라 페이지 캐시의 용도, 버퍼 캐시의 용도로 바꿔가며 사용하는 방식&lt;/p&gt;

&lt;h3 id=&quot;memory-mapped-io&quot;&gt;Memory-Mapped I/O&lt;/h3&gt;

&lt;p&gt;프로세스의 주소 공간 중 일부를 파일에 mapping 해두어서 파일 입출력을 메모리 접근 연산을 통해 실행할 수 있는 방식&lt;/p&gt;

&lt;h2 id=&quot;unified-buffer-cache-전과-후&quot;&gt;Unified Buffer Cache 전과 후&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210606200600.png&quot; alt=&quot;image-20210606200557293&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;기존-방식&quot;&gt;기존 방식&lt;/h3&gt;

&lt;p&gt;버퍼 캐시에 요청한 파일이 있으면 복사를 통해 전달, 없으면 read/write 시스템 콜을 이용해 디스크 파일 시스템으로부터 읽어와서 사용자 프로그램에 전달&lt;/p&gt;

&lt;p&gt;memory mapped&lt;/p&gt;

&lt;p&gt;자신의 주소공간 중 일부를 파일에 mapping해놓음&lt;/p&gt;

&lt;p&gt;디스크에 있는 파일을 버퍼 캐시에 읽어오고 그 내용을 페이지 캐시(메모리 영역)에 복사함&lt;/p&gt;

&lt;p&gt;이 이후에는 운영체제 간섭 없이 메모리 접근만을 통해 읽고 쓰기가 가능해짐&lt;/p&gt;

&lt;h3 id=&quot;유니파이드-버퍼캐시&quot;&gt;유니파이드 버퍼캐시&lt;/h3&gt;

&lt;p&gt;read write 시스템 콜을 하는 것은 기존과 같음&lt;/p&gt;

&lt;p&gt;요청한게 이미 메모리에 있으면 그냥 전달해주고 없으면 읽어와서 전달함&lt;/p&gt;

&lt;p&gt;주소 영역 중 일부를 파일에다 매핑하는 것 이후로는 사용자 프로그램의 주소 영역에 페이지 캐시가 매핑이 됨&lt;/p&gt;

&lt;p&gt;(페이지 캐시 자체가 사용자 프로세스의 주소 영역에 있음)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210606201758.png&quot; alt=&quot;image-20210606201755182&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;코드 부분은 read only이기 때문에 메모리에 올라갔다가 쫓겨날때는 swap 영역에 가지 않고 파일 시스템에 파일 형태로만 존재함&lt;/p&gt;

&lt;p&gt;code영역에 접근하다 page fault 발생시 swap area로 내려가는게 아니라 file system에 가서 가져와야 함&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210606202650.png&quot; alt=&quot;image-20210606202647047&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 데이터를 자신의 주소공간 중 일부에 mapping하여 운영체제의 도움없이 바로바로 사용할 수도 있다.&lt;/p&gt;

&lt;p&gt;여기서 memory mapped I/O를 사용하면 메모리 상에서 읽고 쓰는 것도 가능해진다.&lt;/p&gt;

&lt;h2 id=&quot;disk-structure--management&quot;&gt;Disk Structure &amp;amp; Management&lt;/h2&gt;

&lt;h3 id=&quot;logical-block&quot;&gt;logical block&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;디스크의 외부에서 보는 디스크의 단위 정보 공간&lt;/li&gt;
  &lt;li&gt;주소를 가진 1차원 배열처럼 취급&lt;/li&gt;
  &lt;li&gt;정보를 전송하는 최소 단위&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sector&quot;&gt;Sector&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Logical block이 물리적 디스크에 매핑된 위치&lt;/li&gt;
  &lt;li&gt;Sector 0은 최외곽 실린더의 첫 트랙에 있는 첫 번째 sector (부팅 정보가 들어있음)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;disk-management&quot;&gt;Disk Management&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210606203117.png&quot; alt=&quot;image-20210606203114765&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;physical formatting&lt;/strong&gt; : 디스크를 섹터 단위로 나누는 과정&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;header, trailer&lt;/strong&gt; : error correction code, 주소 매핑을 위한 sector번호 등의 metadata의 역할을 하는 것들이 저장되는 곳&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;partitioning&lt;/strong&gt; : 물리적 디스크를 논리적 디스크 여러개로 나누는 작업&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;logical formatting&lt;/strong&gt; : 파일 시스템을 만드는 과정&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;booting&lt;/strong&gt; : 메모리 영역 중 전원이 나가도 내용이 유지되는 ROM에 loader라는 부팅을 위한 내용이 저장해놓음, 이후 boot block을 이용해 boot&lt;/p&gt;

&lt;h2 id=&quot;disk-scheduling&quot;&gt;Disk Scheduling&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210606203651.png&quot; alt=&quot;image-20210606203638344&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;접근시간의-구성&quot;&gt;접근시간의 구성&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;탐색시간 (이것을 최소화 하는 것이 목적. 회전지연시간, 전송시간은 작을뿐더러 운영체제가 개입하기 어려움)&lt;/li&gt;
  &lt;li&gt;회전지연시간&lt;/li&gt;
  &lt;li&gt;전송시간&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Disk bandwidth&lt;/strong&gt; : 단위 시간 당 전송되는 데이터의 양&lt;/p&gt;

&lt;h3 id=&quot;알고리즘의-종류&quot;&gt;알고리즘의 종류&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;FCFS&lt;/p&gt;

    &lt;p&gt;말그대로 First come first served&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SSTF&lt;/p&gt;

    &lt;p&gt;Shortest seek time first로 가장 빨리 갈 수 있는 위치부터 차례대로 탐색&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SCAN&lt;/p&gt;

    &lt;p&gt;한쪽 끝까지 탐색 후 다른쪽 끝까지 탐색하는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;C-SCAN&lt;/p&gt;

    &lt;p&gt;한쪽 끝까지 탐색 후 아무 탐색 없이 다시 원점으로 돌아온 뒤 다시 탐색을 시작하는 방법 (탐색시간의 편차를 줄여줌)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;N-SCAN&lt;/p&gt;

    &lt;p&gt;기본적으로는 scan 방식, arm이 움직이기 시작하면 그 이후에 도착한 일들은 나중에 처리하는 방식&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LOOK&lt;/p&gt;

    &lt;p&gt;한쪽으로 쭉 가다가 더 가도 탐색할게 없으면 유턴해오는 방식&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;C-LOOK&lt;/p&gt;

    &lt;p&gt;LOOK 방식인데 C-SCAN 처럼 마지막 스캔 위치까지 갔다가 다시 원점으로 와서 다시 반복하는 방식&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;디스크-스케쥴링-알고리즘의-결정&quot;&gt;디스크 스케쥴링 알고리즘의 결정&lt;/h3&gt;

&lt;p&gt;현대에는 스캔 기반의 알고리즘을 많이 쓰고 있음&lt;/p&gt;

&lt;p&gt;file을 어떻게 할당하느냐에 따라 디스크 스케쥴링 성능에 영향을 끼침&lt;/p&gt;

&lt;p&gt;디스크 스케쥴링 알고리즘은 필요할 경우 변경하기 편하도록 OS와 별도의 모듈로 작성되는 것이 좋음&lt;/p&gt;

&lt;h2 id=&quot;swap-space-management&quot;&gt;Swap Space Management&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210606204602.png&quot; alt=&quot;image-20210606204600001&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;디스크를-사용하는-이유&quot;&gt;디스크를 사용하는 이유&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;메모리의 휘발성&lt;/li&gt;
  &lt;li&gt;메모리 공간의 부족&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;스왑-영역&quot;&gt;스왑 영역&lt;/h3&gt;

&lt;p&gt;스왑 영역은 공간 효율성보다 시간 효율성이 중요한데&lt;/p&gt;

&lt;p&gt;큰 단위로 데이터를 올리고 내리고 반복해줌&lt;/p&gt;

&lt;h3 id=&quot;raid&quot;&gt;RAID&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210606205107.png&quot; alt=&quot;image-20210606205104641&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;###&lt;/p&gt;

&lt;p&gt;디스크 여러개를 묶어서 같이 사용하는 방식&lt;/p&gt;

&lt;p&gt;여러개의 디스크에 데이터를 얼마나 중복저장, 분산저장할 것인가를 결정해야함&lt;/p&gt;

&lt;p&gt;**장점 **&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디스크 처리 속도가 향상됨&lt;/li&gt;
  &lt;li&gt;중복 저장으로 인해 신뢰성이 향상됨(failure 발생해도 다른 디스크에서 읽어올 수 있음)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 06 Jun 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/16-File-System-2/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/16-File-System-2/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>2021년 06월 04일 공부일지</title>
        <description>&lt;h3 id=&quot;의존성-관리도구란-무엇일까&quot;&gt;의존성 관리도구란 무엇일까?&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;애플리케이션 기능을 개발하기 위해 외부 라이브러리를 사용할 때 프로젝트와 해당 라이브러리의 상관관계를 용이하게 관리해주는 도구&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;의존성-관리도구의-종류에는-뭐가-있을까&quot;&gt;의존성 관리도구의 종류에는 뭐가 있을까?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;코코아팟 (CocoaPods)&lt;/li&gt;
  &lt;li&gt;카르타고 (Carthage)&lt;/li&gt;
  &lt;li&gt;Swift Package Manager&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;의존성-관리도구를-안쓰면-뭐가-안좋을까&quot;&gt;의존성 관리도구를 안쓰면 뭐가 안좋을까?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;쓰기로 한 외부 라이브러리&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;필요로 하는 여러가지 라이브러리들&lt;/code&gt;을 일일이 import 해줘야 됨.&lt;/li&gt;
  &lt;li&gt;라이브러리가 업데이트가 되었을 때, 각각의 라이브러리를 직접 바꿔주어야함.&lt;/li&gt;
  &lt;li&gt;의존성 관리는 새 버전이 나왔는지 매번 확인하기 어렵고, 보안 취약점이 생겼을 때 알아차리기 어려워 관리하기 쉽지 않음.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.notion.so/7d792829c79b44b585f575617a5db893&quot;&gt;iOS 의존성 관리도구 장단점 비교&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;번외-동적-라이브러리-vs-정적-라이브러리&quot;&gt;번외) 동적 라이브러리 vs 정적 라이브러리&lt;/h3&gt;

&lt;p&gt;빌드 때 필요한건 정적&lt;/p&gt;

&lt;p&gt;빌드 때는 필요없고 실행시에 필요한건 동적&lt;/p&gt;

&lt;p&gt;Q) 의존성의 의존성 문제를 관리한다는 말의 의미는?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;외부 라이브러리가 필요로 하는 외부 라이브러리를 알아서 관리한다는 의미&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;PackageDescription&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Package&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;AlamofireImage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                      &lt;span class=&quot;nv&quot;&gt;platforms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;iOS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                                  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;macOS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v10_12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                                  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tvOS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                                  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;watchOS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)],&lt;/span&gt;
                      &lt;span class=&quot;nv&quot;&gt;products&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;AlamofireImage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;targets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;AlamofireImage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])],&lt;/span&gt;
                      &lt;span class=&quot;nv&quot;&gt;dependencies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;https://github.com/Alamofire/Alamofire.git&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                              &lt;span class=&quot;nv&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;5.4.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)],&lt;/span&gt;
                      &lt;span class=&quot;nv&quot;&gt;targets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;AlamofireImage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                        &lt;span class=&quot;nv&quot;&gt;dependencies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Alamofire&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
                                        &lt;span class=&quot;nv&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Source&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)],&lt;/span&gt;
                      &lt;span class=&quot;nv&quot;&gt;swiftLanguageVersions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;참고-링크&quot;&gt;참고 링크&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;[&lt;a href=&quot;https://yagom.net/courses/open-source-library/&quot;&gt;야곰닷넷] 오픈소스 라이브러리 만들기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;[&lt;a href=&quot;https://github.com/bluelocate/boostcamp_iOS_5InQueue/blob/master/week5/DependencyManager.md&quot;&gt;github] 의존성 관리 도구 정리&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.codementor.io/blog/swift-package-manager-5f85eqvygj#why-should-i-use-it&quot;&gt;의존성 관리도구 비교&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;git과-함께-의존성-관리도구-사용시-발생할-수-있는-문제점들&quot;&gt;Git과 함께 의존성 관리도구 사용시 발생할 수 있는 문제점들&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;이전 버전의 프로젝트에서 외부 라이브러리의 ‘최신화’를 유지한 경우 (pod file에서 버전을 명시해주지 않으면 자동으로 최신 버전 유지가 된다.)
    &lt;ul&gt;
      &lt;li&gt;이전 버전의 프로젝트를 사용하려는 경우에 (종종 발생하고는 한다.) 코드는 이전 라이브러리에 맞추어져있지만, 라이브러리는 최신 버전이어서 하위 호환이 안될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로젝트 main 브랜치에서 라이브러리를 ‘고정’시켜놓은 경우
    &lt;ul&gt;
      &lt;li&gt;develop 브랜치에서 라이브러리를 업데이트 시키는 경우 나중에 배포를 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 브랜치로 병합할 때, 라이브러리의 버전이 달라 충돌이 일어날 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;두 개의 라이브러리를 채택한다고 할 때, 각 라이브러리가 같은 하위 라이브러리를 채택하지만 두 라이브러리가 버전이 다른 경우 충돌이 날 것 같음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;정리&quot;&gt;정리&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;외부 라이브러리의 코드를 commit에 남길 필요가 없으므로 podfile은 gitignore 파일에 넣어주는 것이 좋음&lt;/li&gt;
  &lt;li&gt;만약 gitignore에 넣지 않으면 라이브러리 코드가 업데이트될 때마다 새로운 diff(difference)가 생김&lt;/li&gt;
  &lt;li&gt;코드가 github에 열려있는한 외부 라이브러리의 코드는 언제든 가져올 수 있기 때문에 굳이 프로젝트 파일에 넣어주지 않아도 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;crud가-뭘까&quot;&gt;CRUD가 뭘까?&lt;/h3&gt;

&lt;p&gt;CRUD : Create Retrieve Update Delete의 약자로 데이터를 관리하는 것을 총체적으로 이르는 말&lt;/p&gt;

&lt;p&gt;user default를 통해서든 key chain을 통해서든 core data를 통해서든.. 다양하게 이루어질 수 있다&lt;/p&gt;
</description>
        <pubDate>Thu, 03 Jun 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.06.03-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.06.03-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>2021년 06월 01일 공부일지</title>
        <description>&lt;h3 id=&quot;table-view-cell에-내용-이쁘게-넣는-방법-inset-설정하기&quot;&gt;table view cell에 내용 이쁘게 넣는 방법 (inset 설정하기)&lt;/h3&gt;

&lt;p&gt;view에다 바로 addSubview, setConstraint 하지 말고&lt;/p&gt;

&lt;p&gt;cell.contentview에 addSubview하고 constraint 세우기&lt;/p&gt;

&lt;p&gt;이렇게 해야 accessory view랑 겹치지도 않고 inset 설정도 쉽다!&lt;/p&gt;

&lt;h4 id=&quot;heavy_plus_sign-오늘의-삽질&quot;&gt;:heavy_plus_sign: 오늘의 삽질&lt;/h4&gt;

&lt;p&gt;cell의 textLabel에 디폴트 값이 없는채로 auto resizing하면&lt;/p&gt;

&lt;p&gt;tableViewCell의 높이가 막 0으로 생성됨 (매우 끔찍)&lt;/p&gt;

&lt;p&gt;그래서 label.text에 디폴트 값 주는 작업 꼭 필요함&lt;/p&gt;

&lt;h3 id=&quot;first-baseline-last-baseline-anchor를-써보자&quot;&gt;first baseline, last baseline anchor를 써보자!&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Since the appropriate spacing around text depends on properties of the font being used; the first baseline of the headline label is constrained to use a system spacing to the top of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contentView&lt;/code&gt;, rather than a regular top-anchor to top-anchor constraint.&lt;/p&gt;

  &lt;p&gt;Similarly, the &lt;em&gt;last&lt;/em&gt; baseline of the body label is constrained to use a system spacing to the bottom of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contentView&lt;/code&gt;, rather than a bottom-anchor to bottom-anchor constraint.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;애플이 이렇다 하네.. 언젠가 써볼게~ (system Spacing은 또 뭐야.. 몰라 무서워)&lt;/p&gt;

&lt;p&gt;출처 : &lt;a href=&quot;https://developer.apple.com/documentation/uikit/uifont/creating_self-sizing_table_view_cells&quot;&gt;Self Sizing Cell 예제 앱&lt;/a&gt;의 주석&lt;/p&gt;

&lt;h3 id=&quot;하려다-말았던-오늘의-질문-split-view로-시작화면-구성하기&quot;&gt;하려다 말았던 오늘의 질문 (Split View로 시작화면 구성하기)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;안녕하세요 올라프 질문이 있어서 DM드려요
이번 프로젝트에서 화면의 horizontalSizeClass가 Regular일 경우에는 split view로, 아닐 경우에는 일반 view로 나타내길 요구하고 있는데
아이폰 Pro Max 같이 landscape에서는 horizontalSizeClass가 regular, portrait에서는 compact인 경우를 어떻게 처리해주어야 할지 잘 모르겠어요&lt;/p&gt;

  &lt;p&gt;app 시작시에 horizontalSizeClass를 확인하여 Regular인 경우에는 rootViewController를 splitViewController로 지정해주는 방식으로
Split View를 구현하였는데 이 문제를 해결할 방법이 있을까요?
시간 되실때 조언주시면 감사하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;시작할 때 splitView로 할건지 안할건지 설정하는게 아니구 그냥 아싸리 죄다 splitView로 시작한 다음에&lt;/p&gt;

&lt;p&gt;splitview의 property와 delegate 메서드로 지지고 볶고 해줘야 하는 거였다!&lt;/p&gt;

&lt;h3 id=&quot;heavy_plus_sign-검색-키워드&quot;&gt;:heavy_plus_sign: 검색 키워드&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;splitView의 delegate (splitView의 primary, secondary 중 primary를 위로 올리고 시작하려면 delegate 필요함!)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;splitView의 preferredDisplaymode (이것저것 해보면 감이 잡히는 녀석)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;겁나-열받는-textview-scrollbar-시작-위치&quot;&gt;겁나 열받는 textView scrollBar 시작 위치&lt;/h3&gt;

&lt;p&gt;자꾸 textView의 scrollBar가 제 위치에 가있지 않는 현상 발생 (navigationBar 밑에 textView가 붙어야되는데 미리 constraint 잡고 text를 나중에 넣다보니까 그런가.. navigationBar 뒤쪽에 text가 들어차 있었고 scroll Bar는 그만큼 내려가 있었음)&lt;/p&gt;

&lt;p&gt;content offset을 조절해서 textView가 넘어가는걸 막아주어서 해결!&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLayoutSubviews&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;descriptionTextView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contentOffset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zero&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;현재-view의-sizeclass를-구해보자&quot;&gt;현재 View의 sizeClass를 구해보자!&lt;/h3&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;UITraitCollection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;horizontalSizeClass&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;uibarbuttonitem-추가하는-방법-맨날-까먹어&quot;&gt;UIBarButtonItem 추가하는 방법 (맨날 까먹어)&lt;/h3&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;navigationItem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rightBarButtonItem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIBarButtonItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;barButtonSystemItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;system-button-모음집&quot;&gt;&lt;a href=&quot;https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/system-icons/&quot;&gt;System button 모음집&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;참고로 동그라미 안에 땡땡땡 있는 기호는 ellipsis.circle라는 system image임&lt;/p&gt;

&lt;h3 id=&quot;uisplitviewcontrollerdisplaymodeonebesidesecondary&quot;&gt;UISplitViewController.DisplayMode.oneBesideSecondary&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;This display mode shows one sidebar tiled next to the secondary view controller. The sidebar shown is the primary column for &lt;a href=&quot;doc://com.apple.documentation/documentation/uikit/uisplitviewcontroller/style/doublecolumn&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UISplitViewController.Style.doubleColumn&lt;/code&gt;&lt;/a&gt;interfaces and the supplementary column for &lt;a href=&quot;doc://com.apple.documentation/documentation/uikit/uisplitviewcontroller/style/triplecolumn&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UISplitViewController.Style.tripleColumn&lt;/code&gt;&lt;/a&gt; interfaces. The sidebar is displayed on the side specified by &lt;a href=&quot;doc://com.apple.documentation/documentation/uikit/uisplitviewcontroller/2875524-primaryedge&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;primaryEdge&lt;/code&gt;&lt;/a&gt;, followed by the secondary view controller. The secondary view controller’s view is fully interactive.&lt;/p&gt;

  &lt;p&gt;This display mode is available for the &lt;a href=&quot;doc://com.apple.documentation/documentation/uikit/uisplitviewcontroller/splitbehavior/tile&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UISplitViewController.SplitBehavior.tile&lt;/code&gt;&lt;/a&gt;and &lt;a href=&quot;doc://com.apple.documentation/documentation/uikit/uisplitviewcontroller/splitbehavior/displace&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UISplitViewController.SplitBehavior.displace&lt;/code&gt;&lt;/a&gt; split behaviors.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이거 해줘야 원하는 모양으로 나옴 (왼쪽 사이드바에 table view 있고 옆은 memo인 꼴)&lt;/p&gt;

&lt;p&gt;다른 mode들도 실험해보자! (재밌다!)&lt;/p&gt;

&lt;h3 id=&quot;textview에-inset을-넣어보자&quot;&gt;textView에 inset을 넣어보자!&lt;/h3&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;descriptionTextView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;textContainerInset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIEdgeInsets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;bottom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(대충 textView의 container에 넣어야 하는게 핵심이라는 소리)&lt;/p&gt;

</description>
        <pubDate>Tue, 01 Jun 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.06.01-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.06.01-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>[#16] File System-1</title>
        <description>&lt;h2 id=&quot;file-and-file-system&quot;&gt;File and File System&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530165749.png&quot; alt=&quot;image-20210530165746939&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;메모리-vs-파일&quot;&gt;메모리 vs 파일&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;메모리&lt;/strong&gt;: 주소를 통해서 접근하는 장치&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;파일&lt;/strong&gt;: 디스크에 일반적으로 저장되며 이름을 통해 접근함, 비휘발성인 하드디스크에 저장됨, 데이터를 저장하는 목적으로만 사용하는 것이 아닌 리눅스와 같은 운영체제에서는 장치들을 관리하기 위해서도 file이라는 이름을 사용해 관리하기도 함&lt;/p&gt;

&lt;h3 id=&quot;연산들&quot;&gt;연산들&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;create / delete&lt;/li&gt;
  &lt;li&gt;read / write&lt;/li&gt;
  &lt;li&gt;lseek : 파일의 특정 부분부터 읽고싶을 때 현재 접근 위치를 수정해주는 연산&lt;/li&gt;
  &lt;li&gt;open / close : open(file의 meta data를 올려놓는 작업)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;metadata&quot;&gt;metadata&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;metadata(attribute)&lt;/strong&gt; : file 자체의 내용이 아닌 file을 관리하기 위한 정보&lt;/p&gt;

&lt;p&gt;음악 file을 예시로 들면 음악 data 자체는 file이지만 음악의 이름, 파일의 위치 등등은 파일을 관리하기 위한 내용&lt;/p&gt;

&lt;h3 id=&quot;file-system&quot;&gt;File system&lt;/h3&gt;

&lt;p&gt;파일에는 파일 자체의 내용과 metadata를 같이 저장함&lt;/p&gt;

&lt;p&gt;디렉토리를 제공하여 관리의 용이성 증대&lt;/p&gt;

&lt;p&gt;파일을 어떻게 저장할지, 어떻게 관리할지를 담당&lt;/p&gt;

&lt;h2 id=&quot;directory-and-logical-disk&quot;&gt;Directory and Logical Disk&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530171103.png&quot; alt=&quot;스크린샷&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;directory&quot;&gt;Directory&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Directory file&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하위 디렉토리의 metadata&lt;/code&gt;를 내용으로 가지는 file (모든 metadata가 저장되어 있지는 않다)&lt;/p&gt;

&lt;h3 id=&quot;partition-논리-디스크&quot;&gt;Partition (논리 디스크)&lt;/h3&gt;

&lt;p&gt;운영체제가 보는 디스크는 Partition이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file system&lt;/code&gt;을 설치하거나 virtual memory의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swap area&lt;/code&gt;로도 사용할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;open-연산&quot;&gt;open 연산&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530171952.png&quot; alt=&quot;image-20210530171949680&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;open(): file의 metadata를 메모리로 올려놓는 연산&lt;/p&gt;

&lt;p&gt;논리적인 disk안에 file system이 있으면 그 file system에 metadata와 file의 내용이 저장되어 있음&lt;/p&gt;

&lt;p&gt;file의 metadata 중에는 file의 내용을 가리키는 포인터도 같이 저장되어 있음&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530172047.png&quot; alt=&quot;image-20210530172044838&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;abc를-open하는-과정&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/a/b/c&lt;/code&gt;를 open하는 과정&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530175643.png&quot; alt=&quot;image-20210530175640769&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt;: file descriptor&lt;/p&gt;

&lt;p&gt;c의 metadata를 메모리로 가져오고 싶은 상황이므로 이를 위해 directory path를 search한다.&lt;/p&gt;

&lt;p&gt;root directory의 metadata는 미리 알고 있으며, root의 metadata를 가져와서 열어보면 root data의 실제 위치를 알 수 있는데 이 내용은 하위 디렉토리의 metadata이다.&lt;/p&gt;

&lt;p&gt;이 metadata를 통해 순차적으로 따라 내려가다보면 원하는 파일의 위치정보를 얻을 수 있고&lt;/p&gt;

&lt;p&gt;이 위치정보는 PCB에 저장되기 때문에 프로세스가 살아있는 동안 계속해서 사용할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;file-protection&quot;&gt;File Protection&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530180216.png&quot; alt=&quot;image-20210530180213252&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;접근권한을 가지고 있는 user에 대한 정보와 지원되는 접근 연산에 대한 정보 를 같이 가지고 있어야 한다.&lt;/p&gt;

&lt;h3 id=&quot;access-control-matrix&quot;&gt;Access Control Matrix&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Matrix (Array)&lt;/p&gt;

    &lt;p&gt;행렬에 사용자와 파일의 이름을 행과 열에 나열하고 권한에 대해 표시한다.&lt;/p&gt;

    &lt;p&gt;사용하지 않는 부분은 놀기 때문에 효율이 좋지 않다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ACL (Linked List): 파일별로 누구에게 어떤 접근 권한이 있는지 표시&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Capa bility (Linked List): 사용자별로 자신이 접근 권한을 가진 파일 및 해당 권한 표시&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;모든 접근 파일의 접근 권한을 제어하는 것이 가능하다.&lt;/p&gt;

&lt;p&gt;하지만 부가적인 오버헤드가 너무 크기 때문에 일반적인 운영체제에서 잘 사용하지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;grouping&quot;&gt;Grouping&lt;/h3&gt;

&lt;p&gt;모든 파일에 대해 접근권한을 가지고 있는 것이 아닌&lt;/p&gt;

&lt;p&gt;유저를 owner, group, public 세 가지로 구분하여 사용하는데&lt;/p&gt;

&lt;p&gt;이 경우 총 9비트만 있으면 파일에 대한 접근 권한을 알 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;password&quot;&gt;Password&lt;/h3&gt;

&lt;p&gt;파일이나 디렉토리마다 password를 걸어 관리하는 방법도 가능하다.&lt;/p&gt;

&lt;p&gt;암기 문제, 관리 문제로 인해 잘 사용되지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;mounting&quot;&gt;Mounting&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530190745.png&quot; alt=&quot;image-20210530190742476&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하나의 물리적 디스크를 파티션을 통해 여러 디스크로 나누어 놓은 모습&lt;/p&gt;

&lt;p&gt;각각의 물리적 디스크에는 파일 시스템을 설치하여 사용할 수 있음.&lt;/p&gt;

&lt;p&gt;만약 다른 파티션의 파일시스템에 접근해야하는 상황이 온다면?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530190853.png&quot; alt=&quot;image-20210530190850175&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그것을 제공하기 위한 연산이 Mounting&lt;/p&gt;

&lt;p&gt;루트 파일 시스템의 특정 디렉토리의 이름에 또 다른 파티션(B)의 파일시스템을 가져다 붙여주면&lt;/p&gt;

&lt;p&gt;B의 루트에 접근하는 것과 같은 효과를 누릴 수 있게 됨&lt;/p&gt;

&lt;h2 id=&quot;파일-접근-방법&quot;&gt;파일 접근 방법&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530191033.png&quot; alt=&quot;스크린샷-2369407&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파일 접근 방법에는 순차 접근과 직접 접근이 있다.&lt;/p&gt;

&lt;p&gt;매체에 따라 순차 접근만 지원할수도, 직접 접근만 지원할수도 있다.&lt;/p&gt;

&lt;h2 id=&quot;디스크로의-파일-데이터의-저장-방법&quot;&gt;디스크로의 파일 데이터의 저장 방법&lt;/h2&gt;

&lt;p&gt;파일을 저장할 때는 동일한 크기의 sector 단위로 나누어서 저장을 한다.&lt;/p&gt;

&lt;p&gt;동일한 크기의 저장 단위를 논리적인 block이라 한다.&lt;/p&gt;

&lt;h3 id=&quot;contiguous-allocation-연속할당&quot;&gt;Contiguous Allocation (연속할당)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530193330.png&quot; alt=&quot;image-20210530193326379&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연속할당: 하나의 파일이 디스크상에 연속적으로 저장되는 방법&lt;/p&gt;

&lt;p&gt;ppt의 list를 예시로 들면 28번째부터 4개의 공간만큼 list의 내용이 할당되어 있는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;빠른 I/O의 가능 
(하드디스크의 접근시간의 대부분은 디스크 헤드가 움직이는데 소요되는 시간이며 크기는 그닥 상관이 없다.) 
즉, 한 번의 이동으로 많은 양의 데이터를 한번에 가져올 수 있는 것&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;직접 접근의 가능&lt;/p&gt;

    &lt;p&gt;길이가 긴 파일의 특정 block을 보고싶을 때 굳이 앞의 block 내용을 다 보지 않아도 뒷부분에 바로 접근이 가능하다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;외부 조각의 발생 (비어있는 block들이 일정한 크기를 가지지 않으므로)&lt;/li&gt;
  &lt;li&gt;파일의 크기를 키우는데 제약이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;linked-allocation&quot;&gt;Linked Allocation&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530194724.png&quot; alt=&quot;image-20210530194721665&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연속적 배치가 아닌 빈 위치에 아무렇게나 배치할 수 있다. 다음 block의 위치를 계속해서 적음으로써&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;외부조각이 발생하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;random access가 불가능하다&lt;/li&gt;
  &lt;li&gt;한 부분의 데이터만 없어져도 뒷부분의 데이터를 잃게된다. (의존성 문제)&lt;/li&gt;
  &lt;li&gt;pointer를 위한 공간이 block의 일부분을 차지하므로 공간 효율성이 낮아진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Linked Allocation의 변형&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;File allocation table (FAT) 파일 시스템 : 포인터를 별도의 위치에 보관하여 의존성 문제와 공간 효율성 문제를 해결하는 방식&lt;/p&gt;

&lt;h3 id=&quot;indexed-allocation&quot;&gt;Indexed Allocation&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530195316.png&quot; alt=&quot;image-20210530195314362&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어느 위치에 파일의 내용이 저장되어있는지에 대한 정보를 하나의 block에 담아놓는 방식으로 이루어져있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;외부조각이 생기지 않음&lt;/li&gt;
  &lt;li&gt;직접 접근 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;작은 크기의 파일의 경우 공간을 낭비하게 됨 (하나의 block이 더 필요한 것이므로)&lt;/li&gt;
  &lt;li&gt;너무 큰 파일의 경우 하나의 block에 index들을 전부 담을 수 없어서 곤란&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;개선 방안&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;linked scheme: 놀게 되는 index (-1 index) 자리에 다른 파일의 index를 저장해놓는 방법&lt;/li&gt;
  &lt;li&gt;multi level index: index가 또 다른 index를 가리키게 하여 큰 파일을 표현할 수 있다. (page table처럼)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;unix-파일시스템의-구조&quot;&gt;UNIX 파일시스템의 구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530195754.png&quot; alt=&quot;image-20210530195751054&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530195928.png&quot; alt=&quot;image-20210530195926307&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Boot block&lt;/p&gt;

    &lt;p&gt;부팅에 필요한 정보를 담고있는 block으로 0번째 block은 Boot block으로 하는 것이 모든 파일시스템의 약속&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Super block&lt;/p&gt;

    &lt;p&gt;다른 block들의 위치와 같은 파일 시스템의 전반적인 정보를 담고 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Inode (index node)&lt;/p&gt;

    &lt;p&gt;파일 하나당 inode가 하나씩 할당되며  file의 metadata 중 file의 이름을 제외한 모든 metadata를 가지고 있다.&lt;/p&gt;

    &lt;p&gt;(file의 이름은 directory가 가지고 있음)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Data block&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;fat-file-system&quot;&gt;FAT File System&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530201331.png&quot; alt=&quot;image-20210530201328526&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;metadata 중 파일의 위치정보만 FAT에 담아두고 나머지는 directory가 가지고 있다.&lt;/p&gt;

&lt;p&gt;다음위치를 별도의 FAT이라는 공간에 담음으로써 directory 파일의 공간 낭비를 줄이고 이후 block을 찾는 과정에서 이존 block 의존성을 없앤 방식이다.&lt;/p&gt;

&lt;p&gt;linked allocation 방식과 다르게 random access가 가능하고 FAT에 보통 하나의 copy가 아닌 두개의 copy를 저장해놓으므로 data 유실에 대한 걱정도 적다.&lt;/p&gt;

&lt;h2 id=&quot;free-space-management&quot;&gt;Free Space Management&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530201946.png&quot; alt=&quot;image-20210530201943408&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비어있는 공간을 관리하는 방법에는 여러가지가 있다.&lt;/p&gt;

&lt;h3 id=&quot;bit-map-or-bit-vector&quot;&gt;Bit map or Bit vector&lt;/h3&gt;

&lt;p&gt;비트맵은 비어있는 block을 표시해줌&lt;/p&gt;

&lt;p&gt;부가적인 공간이 필요하지만 그렇게 큰 공간의 낭비는 아님&lt;/p&gt;

&lt;p&gt;가능하면 연속적인 공간에 할당해주는 것이 좋음&lt;/p&gt;

&lt;h3 id=&quot;linked-list&quot;&gt;Linked List&lt;/h3&gt;

&lt;p&gt;모든 free block을 연결해놓는 방식이다.&lt;/p&gt;

&lt;p&gt;특정 크기의 연속적인 가용공간을 찾는게 쉽지 않다는 단점이 있지만 공간의 낭비가 적다&lt;/p&gt;

&lt;h3 id=&quot;grouping-1&quot;&gt;Grouping&lt;/h3&gt;

&lt;p&gt;Linked List의 변형 버전이다.&lt;/p&gt;

&lt;p&gt;첫번째 free block이 n개의 pointer를 가지며 그 pointer를 따라가면 실제 free data block들이 있다.&lt;/p&gt;

&lt;p&gt;마지막 pointer는 또 다시 n개의 pointer를 가지는 block이다.&lt;/p&gt;

&lt;h3 id=&quot;counting&quot;&gt;Counting&lt;/h3&gt;

&lt;p&gt;빈 블록의 위치를 가리킴과 동시에 몇개의 빈 블록이 연결되어 있는지 알려주는 방법이다.&lt;/p&gt;

&lt;h2 id=&quot;디렉토리의-구현&quot;&gt;디렉토리의 구현&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530202439.png&quot; alt=&quot;image-20210530202436695&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;linear-list&quot;&gt;Linear list&lt;/h3&gt;

&lt;p&gt;구현이 간단하지만 시간복잡도가 크다&lt;/p&gt;

&lt;h3 id=&quot;hash-table&quot;&gt;Hash Table&lt;/h3&gt;

&lt;p&gt;탐색 시간이 없어지는 장점이 있다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530202854.png&quot; alt=&quot;image-20210530202851077&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파일의 이름이 일정 길이보다 길면 일정 길이 이상은 metadata에 보관하며, 이를 포인터를 통해 관리한다.&lt;/p&gt;

&lt;h2 id=&quot;vfs-and-nfs&quot;&gt;VFS and NFS&lt;/h2&gt;

&lt;h3 id=&quot;virtual-file-system&quot;&gt;Virtual File System&lt;/h3&gt;

&lt;p&gt;서로 다양한 file system에 대해 동일한 시스템 콜 API를 통해 접근할 수 있도록 해주는 OS의 layer&lt;/p&gt;

&lt;h3 id=&quot;network-file-system&quot;&gt;Network File System&lt;/h3&gt;

&lt;p&gt;분산 시스템에서는 네트워크를 통해 파일이 공유될 수 있음&lt;/p&gt;

&lt;p&gt;NFS는 분산 환경에서의 대표적인 파일 공유 방법&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530203255.png&quot; alt=&quot;image-20210530203252561&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;page-cache와-buffer-cache&quot;&gt;Page Cache와 Buffer Cache&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530203841.png&quot; alt=&quot;image-20210530203837137&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;page frame이 backing store에 비해 빠르므로 cache&lt;/p&gt;

&lt;p&gt;위와 같은 것을 파일 시스템 관점에서는 buffer cache라 부름&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210530204310.png&quot; alt=&quot;image-20210530204305715&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 30 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/15-File-System-1/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/15-File-System-1/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>[#14] 가상 메모리</title>
        <description>&lt;h2 id=&quot;demand-paging&quot;&gt;Demand Paging&lt;/h2&gt;

&lt;h3 id=&quot;요구-페이징의-원리&quot;&gt;요구 페이징의 원리&lt;/h3&gt;

&lt;p&gt;요구 페이징: 모든 페이지를 한꺼번에 메모리에 올리는게 아닌 당장 사용될 페이지만 올리는 방식&lt;/p&gt;

&lt;p&gt;CPU가 특정 페이지를 요청하면 그 때 해당 페이지를 메모리에 적재&lt;/p&gt;

&lt;p&gt;요구페이징의 이점: 메모리 사용량 감소, 메모리에 올리는데 소요되는 오버헤드 감소&lt;/p&gt;

&lt;p&gt;어떤 페이지가 메모리에 존재하고 어떤 페이지가 스왑 영역에 존재하는지 알기 위해 페이지 테이블의 유효-무효 비트를 둠&lt;/p&gt;

&lt;h3 id=&quot;page-fault--처리&quot;&gt;Page Fault  처리&lt;/h3&gt;

&lt;p&gt;Page Fault: 참조를 시도했는데 페이지 테이블의 유효-무효 비트가 “무효”인 경우에 발생하는 오류&lt;/p&gt;

&lt;p&gt;Page Fault가 발생하면 페이지 부재 트랩이 발생하며 디스크에서 부재 페이지를 빈 프레임으로 적재하고 페이지 테이블을 업데이트 함, 이 작업은 오래걸리기 때문에 CPU 빼앗기고 봉쇄상태에 진입&lt;/p&gt;

&lt;h3 id=&quot;요구-페이징의-성능&quot;&gt;요구 페이징의 성능&lt;/h3&gt;

&lt;p&gt;Page Fault가 적을수록 좋은 알고리즘&lt;/p&gt;

&lt;p&gt;요구 페이징의 성능척도: 유효 접근시간&lt;/p&gt;

&lt;p&gt;유효 접근시간 = (1-P) * 메모리 접근시간 + P * (페이지 부재 발생 처리 오버헤드 + 메모리에 빈 프레임이 없는 경우 스왑 아웃 오버헤드 + 요청된 페이지의 스왑 인 오버헤드 + 프로세스의 재시작 오버헤드)&lt;/p&gt;

&lt;p&gt;여기서 P는 Page Fault 발생비율&lt;/p&gt;

&lt;h2 id=&quot;page-replacement&quot;&gt;Page Replacement&lt;/h2&gt;

&lt;p&gt;페이지 부재가 발생했을 때 부재하는 페이지를 디스크로부터 읽어와서 메모리(프레임)에 적재해야 함&lt;/p&gt;

&lt;p&gt;근데 이 때 물리적 메모리에 빈 프레임이 없을 수도 있음&lt;/p&gt;

&lt;p&gt;이럴 때 페이지 중 하나를 디스크로 쫓아낸 뒤에 읽어와야 됨&lt;/p&gt;

&lt;p&gt;이걸 페이지 교체라고 함&lt;/p&gt;

&lt;p&gt;어떤 페이지를 쫓아낼건지를 결정하는 알고리즘을 교체 알고리즘이라 함&lt;/p&gt;

&lt;h3 id=&quot;최적-페이지-교체&quot;&gt;최적 페이지 교체&lt;/h3&gt;

&lt;p&gt;빌레디의 최적 알고리즘은 알고리즘의 성능에 대한 상한선을 제공함&lt;/p&gt;

&lt;p&gt;빌레디의 최적 알고리즘은 미래에 어떤 페이지가 어떠한 순서로 참조될지 미리 알고 있다는 전제하에 알고리즘을 운영함&lt;/p&gt;

&lt;p&gt;따라서 오프라인에 최적화된 알고리즘이며 온라인에는 부적합함&lt;/p&gt;

&lt;p&gt;알고리즘의 동작 방식은 가장 먼 미래에 참조될 페이지를 내쫓는 것&lt;/p&gt;

&lt;h3 id=&quot;fifo&quot;&gt;FIFO&lt;/h3&gt;

&lt;p&gt;가장 먼저 올라온 페이지를 내쫓는 알고리즘&lt;/p&gt;

&lt;h3 id=&quot;lru&quot;&gt;LRU&lt;/h3&gt;

&lt;p&gt;시간지역성: 최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질&lt;/p&gt;

&lt;p&gt;LRU 알고리즘에서는 가장 오래전에 참조된 페이지를 쫓아냄&lt;/p&gt;

&lt;h3 id=&quot;lfu&quot;&gt;LFU&lt;/h3&gt;

&lt;p&gt;페이지의 참조 횟수로 교체시킬 페이지를 결정함&lt;/p&gt;

&lt;p&gt;물리적 메모리 내에 존재하는 페이지 중 과거에 참조된 횟수가 가장 적은 것을 내쫓음&lt;/p&gt;

&lt;p&gt;같은 횟수를 가진 것들이 있다면 상대적으로 오래 전에 참조된 것을 내쫓는 것이 효율적&lt;/p&gt;

&lt;p&gt;LFU는 Incache-LFU와 Perfect-LFU로 나뉨&lt;/p&gt;

&lt;p&gt;Incache-LFU는 물리적 메모리에 올라온 시점을 기준으로 1부터 count함 (내쫓기기 이전 기록 없음)&lt;/p&gt;

&lt;p&gt;Perfect-LFU는 메모리에 올라와있는지에 관계없이 과거 이력만 가지고 내쫓을 것 선정함 (기록보관으로 인한 오버헤드 큼)&lt;/p&gt;

&lt;p&gt;LFU는 LRU보다 오랜 시간 동안의 참조 기록을 반영할 수 있다는 장점 있음&lt;/p&gt;

&lt;p&gt;하지만 시간에 따른 페이지 참조의 변화를 반영할 수 없고 LRU에 비해 구현이 복잡함&lt;/p&gt;

&lt;h3 id=&quot;clock&quot;&gt;Clock&lt;/h3&gt;

&lt;p&gt;LRU와 LFU는 참조 시각, 참조 횟수를 유지하고 비교해야 하므로 알고리즘의 운영에 시간적 오버헤드 발생함&lt;/p&gt;

&lt;p&gt;클럭 알고리즘은 하드웨어의 도움을 받아 이것을 줄임&lt;/p&gt;

&lt;p&gt;클럭 알고리즘은 LRU를 근사시킨 알고리즘으로 NotUsedRecently, NotRecentlyUsed 알고리즘이라고도 불림&lt;/p&gt;

&lt;p&gt;최근에 참조되지 않은 페이지를 교체 대상으로 선정하는 것은 LRU와 유사하지만 교체되는 페이지의 참조 시점이 가장 오래되었다는 것을 보장하지는 못함&lt;/p&gt;

&lt;p&gt;하지만 대신 하드웨어의 도움을 받으므로 빠르고 효율적, 이러한 이유로 대부분의 클럭 알고리즘을 사용함&lt;/p&gt;

&lt;p&gt;클럭 알고리즘은 교체 페이지 선정을 위해 페이지 프레임들의 참조비트를 순차적으로 조사함&lt;/p&gt;

&lt;p&gt;참조 비트는 각 프레임마다 하나씩 존재하며 참조될 때 1로 세팅됨&lt;/p&gt;

&lt;p&gt;클럭이 돌 때 1인건 0으로 바꾸고 지나가고 0인거 발견하면 그것을 교체함&lt;/p&gt;

&lt;p&gt;간단히 말해서 시계바늘 한바퀴 돌아가는 동안 참조 안된 페이지 있으면 그걸 교체하는 방식&lt;/p&gt;

&lt;h2 id=&quot;page-frame-allocation&quot;&gt;Page Frame Allocation&lt;/h2&gt;

&lt;p&gt;멀티 프로세스 환경에서는 각 프로세스에 얼마만큼의 메모리 공간을 할당할 것인지 결정해야함&lt;/p&gt;

&lt;h3 id=&quot;균등할당&quot;&gt;균등할당&lt;/h3&gt;

&lt;p&gt;모든 프로세스에게 페이지 프레임을 균등하게 할당하는 방식&lt;/p&gt;

&lt;h3 id=&quot;비례할당&quot;&gt;비례할당&lt;/h3&gt;

&lt;p&gt;프로세스의 크기에 비례해 할당하는 방식&lt;/p&gt;

&lt;h3 id=&quot;우선순위-할당&quot;&gt;우선순위 할당&lt;/h3&gt;

&lt;p&gt;당장 CPU에서 실행될 프로세스에 더 많은 프레임을 할당하는 방식&lt;/p&gt;

&lt;p&gt;이런 알고리즘만 가지고는 페이지의 참조 특성을 제대로 반영하지 못할 수 있음&lt;/p&gt;

&lt;p&gt;반복문 구성시에는 모든 페이지를 한꺼번에 올리는게 좋은데, 반복문을 구성하는 수보다 적은 양의 프레임을 할당한다면 매 반복마다 적어도 한 번 이상의 페이지 부재가 발생하기 때문&lt;/p&gt;

&lt;p&gt;최소한으로 필요한 메모리 양은 시간에 따라 달라질 수 있으므로 이를 고려하여 각 프로세스에 할당되는 페이지 프레임의 수를 결정할 필요가 있음&lt;/p&gt;

&lt;h2 id=&quot;global-replacement--local-replacement&quot;&gt;Global Replacement &amp;amp; Local Replacement&lt;/h2&gt;

&lt;p&gt;전역교체는 모든 페이지의 프레임이 교체대상이 될 수 있는 방법&lt;/p&gt;

&lt;p&gt;지역교체는 현재 수행중인 프로세스에게 할당된 프레임 내에서만 교체될 수 있는 방법&lt;/p&gt;

&lt;p&gt;지역교체 방법은 프로세스마다 페이지 프레임을 미리 할당하는 것을 전제로 함&lt;/p&gt;

&lt;p&gt;전역교체 방법은 프로세스마다 메모리를 할당하는 것이 아니라 전체 메모리를 각 프로세스가 공유해서 사용하고 교체 알고리즘에 근거해서 할당되는 메모리 양이 가변적으로 변하는 방식&lt;/p&gt;

&lt;p&gt;LRU, LFU를 프로세스별로 운영하면 지역교체 방법을 사용하게 되는 것, 그냥 이용하면 전역교체 방법을 사용하게 되는 것&lt;/p&gt;

&lt;h2 id=&quot;thrasing&quot;&gt;Thrasing&lt;/h2&gt;

&lt;p&gt;스레싱: 참조되는 페이지들의 집합을 메모리에 한꺼번에 적재하지 못해 CPU 이용률이 떨어지는 현상&lt;/p&gt;

&lt;p&gt;CPU 이용률이 낮다는 것은 준비 큐가 비는 경우가 발생한다는 것&lt;/p&gt;

&lt;p&gt;MPD: 메모리에 동시에 올라가 있는 프로세스의 수 (= 다중 프로그래밍의 정도)&lt;/p&gt;

&lt;p&gt;CPU 이용률이 낮다? MPD를 높이면 됨&lt;/p&gt;

&lt;p&gt;하지만 MPD가 과도하게 높아지면 각 프로세스에게 할당되는 메모리 지나치게 감소함&lt;/p&gt;

&lt;p&gt;MPD를 적절히 조절해서 CPU이용률을 높이는 알고리즘에는 워킹셋, 페이지 부재 빈도 알고리즘이 있음&lt;/p&gt;

&lt;h3 id=&quot;워킹셋-알고리즘&quot;&gt;워킹셋 알고리즘&lt;/h3&gt;

&lt;p&gt;참조되는 페이지들의 집합을 지역성 집합이라 함&lt;/p&gt;

&lt;p&gt;이러한 지역성 집합(워킹셋)을 동시에 올리도록 하는 알고리즘이 워킹셋 알고리즘&lt;/p&gt;

&lt;p&gt;워킹셋 윈도우내의 모든 페이지를 메모리에 올려놓음&lt;/p&gt;

&lt;p&gt;윈도우가 너무 크면 MPD가 감소하여 CPU 이용률이 낮아짐&lt;/p&gt;

&lt;p&gt;윈도우가 너무 작으면 지역성 집합을 모두 수용하지 못할 수 있음&lt;/p&gt;

&lt;h3 id=&quot;페이지-부재-빈도-알고리즘&quot;&gt;페이지 부재 빈도 알고리즘&lt;/h3&gt;

&lt;p&gt;페이지 부재율을 주기적으로 조사하고 이 값에 근거해서 프로세스에 할당할 메모리 양을 동적으로 결정하는 알고리즘&lt;/p&gt;

&lt;p&gt;미리 정해놓은 부재 상한선을 넘으면 더 많은 프레임을 추가로 할당해줌&lt;/p&gt;

&lt;p&gt;미리 정해놓은 하한값보다 내려가면 올라가 있는 프레임을 스왑아웃 시킴&lt;/p&gt;

</description>
        <pubDate>Sun, 23 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/14-Virtual-Memory-2/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/14-Virtual-Memory-2/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>2021년 05월 17일, 18일 공부일지</title>
        <description>&lt;h2 id=&quot;공부한-내용&quot;&gt;공부한 내용&lt;/h2&gt;

&lt;h3 id=&quot;collection-view에-대해-공부&quot;&gt;Collection View에 대해 공부&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;CollectionView의 Cell vs TableView의 Cell
    &lt;ul&gt;
      &lt;li&gt;테이블뷰 셀의 구조는 콘텐츠 영역과 액세서리뷰 영역으로 나뉘었지만, 컬렉션뷰 셀은 배경뷰와 실제 콘텐츠를 나타내는 콘텐츠뷰로 나뉘어 있음&lt;/li&gt;
      &lt;li&gt;테이블뷰 셀은 목록형태로만 레이아웃 되지만, 컬렉션뷰 셀은 다양한 레이아웃을 지원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;protocol을-통한-커플링-제거-및-네트워크-테스트&quot;&gt;Protocol을 통한 커플링 제거 및 네트워크 테스트&lt;/h3&gt;

&lt;p&gt;지난 Bank Manager 프로젝트에서 처음으로 시도해봤던 Protocol을 통한 객체간의 책임분리를 이번 Open Market 프로젝트에서도 시도해봤다. 방식은 지난번과 동일하게 객체의 책임을 분리한 뒤 빈 껍데기에 가까운 protocol을 채택하여 test해야하는 메서드를 요구사항으로 가지고 있으면 protocol을 채택하는 Mock객체를 만들어서 독립적인 테스트를 진행해줄 수 있었다.&lt;/p&gt;

&lt;p&gt;다만 이번에는 기존에 있던 type (URLSession)의 dataTask에 의존하지 않고 독립적으로 테스트하기 위해 extension을 통해 URLSessionProtocol이라는 protocol을 URLSession이 채택하도록 하였다. 활용 양상은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLSessionProtocol&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dataTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                  &lt;span class=&quot;nv&quot;&gt;completionHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLSessionDataTask&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLSession&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLSessionProtocol&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;URLSessionProtocol은 request를 통해 dataTask를 반환하던 dataTask 메서드를 요구사항으로 가지게 하여 dataTask가 빈 껍데기처럼 쓰일 수 있도록 (독립적인 테스트를 위해) 하였다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이번 프로젝트에서는 &lt;a href=&quot;https://github.com/Alamofire/Alamofire/tree/master/Source&quot;&gt;Alamofire의 소스코드&lt;/a&gt;도 많이 참고했다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;싱글톤-패턴의-장단점&quot;&gt;싱글톤 패턴의 장단점&lt;/h3&gt;

&lt;h4 id=&quot;장점&quot;&gt;장점&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;메모리 낭비를 방지할 수 있다.&lt;/li&gt;
  &lt;li&gt;서로 다른 객체들이 데이터를 공유하기 쉽다.&lt;/li&gt;
  &lt;li&gt;객체 로딩 시간이 줄어든다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;단점&quot;&gt;단점&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;thread unsafe하다.&lt;/li&gt;
  &lt;li&gt;개방 폐쇄 원칙, 단일 책임 원칙 등을 위배하여 Test하기가 까다로워진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;any가-nil인지-체크하는-방법&quot;&gt;Any가 nil인지 체크하는 방법&lt;/h3&gt;

&lt;p&gt;Any와 Optional&amp;lt;Any&amp;gt;가 구분되어 있음에도 불구하고 Any에는 nil이 들어갈 수 있다.&lt;/p&gt;

&lt;p&gt;그렇다면 Any에 들어있는 값이 nil인지는 어떻게 체크해야할까?&lt;/p&gt;

&lt;p&gt;if case 라는 구문을 통해 실마리를 잡을 수 있었다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Any&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Any&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Any&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;none&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b is nil!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;if case 구문은 enum type에서 하나의 case만 검사하는 구문이다&lt;/p&gt;

&lt;p&gt;쓸 일이 많지는 않겠지만 알아둬서 나쁠건 없으니.. 정리..&lt;/p&gt;

&lt;h3 id=&quot;클로저-캡쳐에-대해서&quot;&gt;클로저 캡쳐에 대해서&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://alisoftware.github.io/swift/closures/2016/07/25/closure-capture-1/&quot;&gt;글1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@kimdo2297/%ED%81%B4%EB%A1%9C%EC%A0%B8-%EC%BA%A1%EC%B3%90%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-about-closure-capture&quot;&gt;글2&lt;/a&gt; (댓글에 반가운 얼굴들이..)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/Closures.html#ID103&quot;&gt;공식문서(swift.org)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;잡다하게-알게된-내용들&quot;&gt;잡다하게 알게된 내용들&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;HIG에서 switch는 table row에서만 사용할 것을 요구하고 있다. (wow) (&lt;a href=&quot;https://developer.apple.com/design/human-interface-guidelines/ios/controls/switches/&quot;&gt;해당문서 링크&lt;/a&gt;)&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Use switches in table rows only. Switches are intended for use in tables, such as in a list of settings that can be toggled on and off. If you need similar functionality in a toolbar or navigation bar, use a button instead, and provide two distinct icons that communicate the states.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;URLSessionDataTask의 completionHandler를 통해 전달되는 error는 서버에서 client쪽에서 발생한 error이다. 만약 서버의 error가 발생했다면 HTTP Response StatusCode를 통해 알려준다. (400번대, 500번대)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하나의 Label안에서도 text에 여러개의 attribute를 줄 수 있다. &lt;a href=&quot;https://zeddios.tistory.com/300&quot;&gt;zedd님의 정리글&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FlowLayout이 뭘까? &lt;a href=&quot;https://seoyoung612.tistory.com/entry/swift-%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8-UICollectionViewFlowLayout?category=790470&quot;&gt;글1&lt;/a&gt;, &lt;a href=&quot;https://k-elon.tistory.com/26&quot;&gt;글2&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;지금은 collection view가 많이 발전해서 조금 이야기가 달라졌을 &lt;a href=&quot;https://medium.com/@nitpaxy/swift-3-uicollectionview-vs-uitableview-9909bbc0ec66&quot;&gt;collectionView vs TableView 글&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;tableview + scrollview, collectionview, stackview + scrollview 수많은 선택지 중에 적절한 하나를 선택해서 써야한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;야곰닷넷에 올라온 질문글과 답변 &lt;a href=&quot;https://yagom.net/forums/topic/%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-listviewuitableview-uicollectionview%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%A0-%EA%B2%BD%EC%9A%B0-%EA%B5%AC%ED%98%84%EB%B0%A9%EB%B2%95%EC%97%90/&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그냥 vivi가 여기 강의로 스터디하시길래 일단 저장해놓는 &lt;a href=&quot;https://www.pointfree.co/collections&quot;&gt;링크&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;드디어 조금 이해하기 쉬워진 &lt;a href=&quot;https://www.raywenderlich.com/3244963-urlsession-tutorial-getting-started&quot;&gt;URLSessionTutorial&lt;/a&gt; by 레이웬더리치&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;조건을 이어붙이는 문법인 ,와 &amp;amp;&amp;amp;의 차이에 대한 &lt;a href=&quot;https://soojin.ro/blog/swift-comma-vs-and-operator&quot;&gt;글1&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/43366994/are-and-the-same-in-swift&quot;&gt;글2&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UICollectionView Tutorial by 레이웬더리치 &lt;a href=&quot;https://velog.io/@hanseop95/%EB%B2%88%EC%97%AD-UICollectionView-Tutorial-Prefetching-APIs&quot;&gt;번역글&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;type(of: )를 통해 쉽게 type 확인 가능!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;accessory view를 직접 다룰 수 있다 (accessory type을 사용했을 경우 accessory view 프로퍼티는 자동으로 nil이었다)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Opaque return type.. 신기하다.. 나중에 공부해봐야지 &lt;a href=&quot;https://unnnyong.me/2020/05/11/swift-%EB%B6%88%ED%88%AC%EB%AA%85-%EB%B0%98%ED%99%98-%ED%83%80%EC%9E%85-opaque-return-type/&quot;&gt;글&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 18 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.05.1718-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.05.1718-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>[#13] 메모리 관리-2</title>
        <description>&lt;h2 id=&quot;multilevel-paging-and-performance&quot;&gt;MultiLevel Paging and Performance&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516123827.png&quot; alt=&quot;image-20210516123811067&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;페이지 테이블은 2단계로만 쓸 수 있는게 아닌 여러 단계의 페이지 테이블을 쓰는게 가능하다.&lt;/p&gt;

&lt;p&gt;다단계 페이지 테이블은 페이지 테이블이 사용하는 공간을 더 많이 줄일 수 있지만 변환작업을 여러번 거쳐야 하고, 주소 변환을 위해 메모리에 여러번 접근해야하기 때문에 오버헤드를 커진다.&lt;/p&gt;

&lt;p&gt;하지만 TLB라는 주소변환을 전담하는 일종의 cash 메모리 덕분에 대부분의 주소변환은 TLB를 통해 이루어지기 때문에 다단계 페이지 테이블을 사용하더라도 오버헤드가 크지 않다.&lt;/p&gt;

&lt;h2 id=&quot;valid-v--invalid-i-bit-in-a-page-table&quot;&gt;Valid (v) / Invalid (i) Bit in a Page Table&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516124142.png&quot; alt=&quot;image-20210516124138507&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;논리주소의 페이지 개수만큼 페이지 테이블의 엔트리가 존재하고 페이지가 물리적 메모리의 어떤 페이지 frame에 올라가 있는지 주소변환 정보가 들어있다고 배웠었다.&lt;/p&gt;

&lt;p&gt;하지만 페이지 테이블에는 이 외에도 부가적인 비트가 엔트리마다 저장되고 있는데 이 중 하나가 valid-invalid bit이다.&lt;/p&gt;

&lt;p&gt;메모리에 의미있는 값을 집어넣든 않든간에 6,7 등의 0은 의미있는 값으로 해석될 것이다. 프로그램이 가질 수 있는 maximum size 만큼 페이지 테이블의 엔트리가 생겨야하는데 (페이지 테이블의 특성상 위에서부터 순서대로 적어야하기 때문에 필요) 여기서  사용하지 않는 영역을 invalid로 표시한다. (32bit 운영체제라면 최대 1Mb짜리 페이지 테이블이 필요하다. )&lt;/p&gt;

&lt;h2 id=&quot;memory-protection&quot;&gt;Memory Protection&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516124543.png&quot; alt=&quot;image-20210516124540476&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;protection-bit&quot;&gt;Protection Bit&lt;/h3&gt;

&lt;p&gt;여기서는 접근해서 안될 페이지를 막아주는 protection의 의미가 아니다.&lt;/p&gt;

&lt;p&gt;페이지 테이블을 통해 이동한 것이므로 자기 자신의 페이지에만 접근할 수 있으므로 애초에 다른 프로그램의 공간에는 접근할 수 없다.&lt;/p&gt;

&lt;p&gt;여기서의 protection의 의미는 어떤 연산에 대한 접근 권한이다. 프로세스의 영역에는 code만 담고 있는 부분도 있을 것이고 (read only로 있어야 하는 부분) data 영역이나 stack 영역 같은 곳은 read&amp;amp;write 권리를 모두 가지고 있어야 하므로 이를 지정해주는 bit가 필요하다.&lt;/p&gt;

&lt;h3 id=&quot;valid-invalid-bit&quot;&gt;Valid-Invalid Bit&lt;/h3&gt;

&lt;p&gt;프로세스가 아예 주소를 사용하지 않거나 해당 페이지가 backing store에 가있는 경우 invalid로 표시된다.&lt;/p&gt;

&lt;h2 id=&quot;inverted-page-table&quot;&gt;Inverted Page Table&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516125524.png&quot; alt=&quot;image-20210516125520349&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516125629.png&quot; alt=&quot;image-20210516125626602&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Page table은 너무 많은 메모리 공간을 차지한다는 문제가 있다. 프로세스마다 각각 주소변환이 이루어져야 하기 때문에 공간 오버헤드가 큰데 이를 해결하기 위해 존재하는 것이 inverted page table이다.&lt;/p&gt;

&lt;p&gt;원래 페이지 테이블을 통한 주소의 변환을 거꾸로 뒤집어 놓은 inverted page table은 기존의 프로세스마다 필요했던 page table이 아닌 시스템 안에 page table이 딱 하나만 존재하며 page table의 엔트리가 프로세스의 page 개수만큼이 아닌 물리적인 메모리의 page 개수만큼 존재한다. page table의 첫 엔트리는 physical memory의 첫 엔트리를 나타내고 마지막 엔트리는 physical memory의 마지막 엔트리를 담당하는 식이다.&lt;/p&gt;

&lt;p&gt;기존의 page table은 주소변환을 위해 page 번호를 보고 위에서부터 page 번호만큼 떨어진 엔트리에 가서 주소변환을 하는 방법을 썼었는데 inverted의 경우 그것이 불가능하다. 원래는 논리적인 page 번호가 있으면 해당하는 엔트리에 가서 페이지 테이블에 가면 페이지 frame 번호가 몇번이지 나왔는데 역방향의 경우에는 page frame 개수만큼 엔트리가 존재하며 첫번째 entry에는 첫번째 page frame에 들어가는 논리적 page 번호가 들어있고 두번재 entry에는 두번째 page entry에 들어가는 논리적 번호가 들어있다. page frame의 f번째 entry에 가면 논리적인 page table의 번호가 나오게 되어있는게 inverted page table architecture의 구조이다.&lt;/p&gt;

&lt;p&gt;pid : 어떤 프로세스의 page인지를 저장하는 공간 (논리적 주소는 프로그램마다 별도로 존재하므로 f번째에 올라가있는 page가 어떤 프로그램의 p번째 page인지를 나타내야 함)&lt;/p&gt;

&lt;h2 id=&quot;shared-page&quot;&gt;Shared Page&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516131502.png&quot; alt=&quot;image-20210516131459581&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516131521.png&quot; alt=&quot;image-20210516131518876&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서로 다른 프로세스가 같은 코드를 가지고 프로그램을 돌린다 하면 프로그램의 코드 부분은 같은 내용이니 shared code를 이용할 수 있다. 이런 경우에는 각각의 코드를 모두 메모리에 올리는 것이 하나만 read only state로 올려서 이를 공유할 수 있다.&lt;/p&gt;

&lt;p&gt;shared code는 모든 프로세스에서 동일한 logical address상에 있어야 한다.&lt;/p&gt;

&lt;p&gt;shared code는 re-entrant code, pure code라고도 부른다.&lt;/p&gt;

&lt;p&gt;:exclamation:shared code는 공유 데이터와는 다른 개념이다. (공유 데이터와 다르게 shared code는 Read-Only이기 때문)&lt;/p&gt;

&lt;h2 id=&quot;segmentation&quot;&gt;Segmentation&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516134426.png&quot; alt=&quot;image-20210516134423619&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;segment는 프로그램을 의미가 있는 단위로 자른 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516134506.png&quot; alt=&quot;image-20210516134504076&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;세그먼트별로 주소변환이 이루어져야하기 때문에 segmentation table이 있으며, segment table의 길이가 limit register에 들어가게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516134558.png&quot; alt=&quot;image-20210516134555965&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;s는 세그먼트의 번호, d는 떨어진 위치에 해당하는 offset이다.&lt;/p&gt;

&lt;p&gt;paging과 다르게 물리적인 메모리상의 시작위치 외에도 limit이라는 segment의 길이를 가지고 있는데 page와 다르게 segment마다의 길이가 다를 수 있기 때문에 필요한 내용이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램이 가지고 있는 segment 개수보다 큰 segment를 요청하면 trap&lt;/li&gt;
  &lt;li&gt;segment의 길이보다 segment에서 떨어진 offset값이 크면 trap&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516135020.png&quot; alt=&quot;image-20210516135016652&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;segmentation 기법은 page 기법과 다르게 크기가 균일하지 않기 때문에 생기는 문제점들을 가지고 있음&lt;/p&gt;

&lt;p&gt;하지만 의미 단위의 일을 하기 위해서는 매우 효과적 (실행권리 권한부여의 구역을 나누기 쉽기 때문)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516134940.png&quot; alt=&quot;image-20210516134937476&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516135044.png&quot; alt=&quot;image-20210516135041217&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;segment와 page를 비교했을 때 table에 의한 공간 낭비가 큰 쪽은 paging 기법쪽이다.&lt;/p&gt;

&lt;h2 id=&quot;segmentation-with-paging&quot;&gt;Segmentation with Paging&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516202942.png&quot; alt=&quot;image-20210516202939549&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;[정리]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;물리적인 메모리를 나누는 방법으로 크게 연속 할당과 불연속 할당 기법이 있었다. 이 중 불연속 할당 기법에 이용할 수 있는 방법으로는 paging, segmentation, paged segmentation이 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Paged Segmentation 기법을 사용하면 segment가 page로 쪼개져서 올라가기 때문에 segmentation의 조각 문제가 발생하지 않는다.&lt;/p&gt;

&lt;p&gt;자세한 작동방식은 글로 풀어쓰기보다는 위의 순서도를 이해해보는게 나을 것 같다.&lt;/p&gt;
</description>
        <pubDate>Sun, 16 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/13-Memory-Management-2/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/13-Memory-Management-2/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>2021년 05월 13일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;TalbeView Cell의 재활용에 대해 공부&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;prepare for reuse&lt;/li&gt;
      &lt;li&gt;data prefetch&lt;/li&gt;
      &lt;li&gt;나중에 받아온 data 어떻게 원하는 위치에 꽂아줄까? (feat: closure capture)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;modern cell configuration에 대해 공부&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;cell의 기본 imageView 같은 경우에는 사이즈를 임의로 조절할 수 없다 (구려!)&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2020/10027/&quot;&gt;modern cell configuration WWDC&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;escaping closure에 대해 공부&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;함수가 종료된 후에 completionHandler가 호출될 때 escaping이 필요!
        &lt;ul&gt;
          &lt;li&gt;이게 어떻게 가능할까? -&amp;gt; 오래걸리는 작업을 다른 스레드로 보내서 비동기 작업을 할 때 벌어질 수 있음&lt;/li&gt;
          &lt;li&gt;동기작업[…] -&amp;gt; 비동기[completionHandler] -&amp;gt; 함수 종료 -&amp;gt; 이후에 비동기 작업 실행 or 완료&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;flatmapError에 대해 공부&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;예제코드&lt;/p&gt;

        &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;flatMapError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ResponsedPage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SessionManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataIsNotJSON&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataIsNotJSON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;kt&quot;&gt;XCTFail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;invalidURL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Error인 경우만 뽑아서 후처리를 해준 뒤 return을 통해 Result type으로 넘겨줄 수 있다(success로 넘겨줄 수도 있다는 말)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 13 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/2021.05.13-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/2021.05.13-TIL/</guid>
        
        
      </item>
    
      <item>
        <title>HTTP 기본 개념 정리 with swift</title>
        <description>&lt;h2 id=&quot;http란&quot;&gt;HTTP란?&lt;/h2&gt;

&lt;p&gt;CSS, HTML, 이미지 등이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Server와&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Client가&lt;/code&gt; 서로 주고받는 Content라면&lt;/p&gt;

&lt;p&gt;Content를 주고받기 위해 서로가 알아들을 수 있는 공통의 약속(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Protocol&lt;/code&gt;)이 필요하다.&lt;/p&gt;

&lt;p&gt;이 약속이 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP&lt;/code&gt;(Hyper Text Tranfer Protocol)이다.&lt;/p&gt;

&lt;h2 id=&quot;request와-response&quot;&gt;Request와 Response&lt;/h2&gt;

&lt;p&gt;HTTP는 크게 Request와 Response로 구분된다.&lt;/p&gt;

&lt;p&gt;Client가 Request 메세지를 작성해서 Server에 보내면 Server는 Response를 보내준다.&lt;/p&gt;

&lt;p&gt;Request와 Response Message는 각각 Header와 Body로 구분된다.&lt;/p&gt;

&lt;h2 id=&quot;http-message-구조&quot;&gt;HTTP Message 구조&lt;/h2&gt;

&lt;p&gt;Request의 Message는 다음과 같은 구조로 이루어져 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210511230558.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Header와 Body로 구분되며 그 사이에는 반드시 blank line이 들어가야한다.&lt;/p&gt;

&lt;h3 id=&quot;header의-구조&quot;&gt;Header의 구조&lt;/h3&gt;

&lt;p&gt;가장 첫 줄은 Request Line으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP Method Name&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;요청할 파일의 형식/요청할 파일의 이름&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사용할 HTTP 버전&lt;/code&gt;으로 이루어져있다.&lt;/p&gt;

&lt;p&gt;Request Line을 제외한 나머지 부분을 Request Header라고 부르는데 필수로 적어야하는 Host Header를 제외하면 다른 Header는 꼭 있어야 하는건 아니다.&lt;/p&gt;

&lt;p&gt;이번 프로젝트에서 중요하게 이용되는 HTTP Header인  Conten-type에는  Body에 들어갈 Message의 MIME(Multipurpose Internet Mail Extensions) type을 적어줄 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;body의-구조&quot;&gt;Body의 구조&lt;/h3&gt;

&lt;p&gt;MIME type은 여러가지 종류가 있는데 가장 대표적인 것은 HTML 코드이며,  이번 프로젝트에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multipart/form-data&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt;을 사용한다. JSON에 비해 상대적으로 익숙하지 않은 multipart/form-data를 아래에 정리해보았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MIME Type에 대해 설명하고 있는 mozilla 문서: &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types&quot;&gt;MIME 타입&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;더 많은 MIME Type은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types&quot;&gt;이 링크&lt;/a&gt;에서 볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;multipartform-data&quot;&gt;multipart/form-data&lt;/h3&gt;

&lt;p&gt;multipart/form-data는 HTML Form의 내용을 전송할 때 사용할 수 있는 문서 형식이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&lt;/code&gt;로 시작되는 문자열인 boundary로 구분되는 서로 다른 파트들로 구성되며, 각각의 파트는 그 자체로서 개체이며 자신만의 HTTP 헤더를 가진다. 파일 업로드 필드를 위한 헤더로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Disposition&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Type&lt;/code&gt;이 있다.&lt;/p&gt;

&lt;p&gt;Content-type Header에 boundary parameter를 포함해야하며 이 boundary parameter는 메세지 파트의 구분(multipart를 서로 구분해주는 역할)과 메세지의 시작과 끝을 나타내는 역할을 한다.&lt;/p&gt;

&lt;p&gt;첫번째 Boundary 이전의 Body는 MIME을 지원하지 않는 클라이언트를 위해 제공되는 영역이다.&lt;/p&gt;

&lt;p&gt;boundary parameter에 들어갈 문자열을 프로그래머가 무작위 문자를 선택해서 작성한다. 이 때 보통 앞부분에는 WebkitFormBoundary… 등과 같이 프로그래머가 인식할 수 있는 문자를 삽입하며 뒷부분에 무작위 문자열을 붙여서 Boundary가  unique하도록 만들어 본문과의 충돌을 피한다.&lt;/p&gt;

&lt;h2 id=&quot;http-코드를-보며-이해해보자&quot;&gt;HTTP 코드를 보며 이해해보자&lt;/h2&gt;

&lt;div class=&quot;language-http highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;POST&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;/item&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;HTTP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1.1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;camp-open-market-2.herokuapp.com&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Content-Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW&lt;/span&gt;

----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;title&quot;

귀여운 딸기
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;descriptions&quot;

귀여운 딸기입니다.
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;price&quot;

1000
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;currency&quot;

KRW
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;stock&quot;

10
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;images[]&quot;; filename=&quot;Strawberry-removebg-preview.png&quot;
Content-Type: image/png

(data)
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;password&quot;

neph1234
----WebKitFormBoundary7MA4YWxkTrZu0gW--
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;request-line&quot;&gt;Request Line&lt;/h3&gt;

&lt;div class=&quot;language-http highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;POST&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;/item&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;HTTP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1.1&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;가장 첫 줄에는 Request Line이 적혀있는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;POST는 HTTP Method 중 하나이며 더 많은 메서드에 대한 정보는 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Methods&quot;&gt;이 링크&lt;/a&gt;에서 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;request-headers&quot;&gt;Request Headers&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Host: camp-open-market-2.herokuapp.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Request Header에는 여러가지 Header가 선택적으로 들어갈 수 있으며 이 코드에서는 Host와 Content-Type Header가 들어가 있다.&lt;/p&gt;

&lt;p&gt;Content-Type의 내용으로는 multipart/form-data와 boundary parameter가 전달된다.&lt;/p&gt;

&lt;p&gt;boundary parameter로는 임의의 문자열이 전달되면 된다 (보통 swift에서는 UUID를 활용)&lt;/p&gt;

&lt;h3 id=&quot;request-body&quot;&gt;Request Body&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;title&quot;

귀여운 딸기
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;descriptions&quot;

귀여운 딸기입니다.
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;price&quot;

1000
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;currency&quot;

KRW
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;stock&quot;

10
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;images[]&quot;; filename=&quot;Strawberry-removebg-preview.png&quot;
Content-Type: image/png

(data)
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;password&quot;

neph1234
----WebKitFormBoundary7MA4YWxkTrZu0gW--
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Request Body내의 하나의 단락의 시작은 boundary로 시작한다.&lt;/p&gt;

&lt;p&gt;밑줄에는 Content-Disposition을 적어주고&lt;/p&gt;

&lt;p&gt;blank line을 하나 삽입한 뒤&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;에 명시된 공간에 들어갈 내용을 적어준다&lt;/p&gt;

&lt;p&gt;즉, 아래의 코드가 하나의 단락이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;title&quot;

귀여운 딸기
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;주의할 점은 (data)라고 적힌 공간에는 문자열로 변환된 data가 들어있다.&lt;/p&gt;

&lt;p&gt;이미지의 문자열로의 변환은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIImageJPEGRepresentation&lt;/code&gt;메서드를 통해 진행해줄 수 있다.&lt;/p&gt;

&lt;p&gt;Body의 마지막에는 boudary를 적어주며, 꼭 따라야하는 것은 아니지만 관례적으로 boudary 뒤에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&lt;/code&gt;를 붙여줌으로써 구분이 쉽도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;swift-코드를-통해-multipartform-data-코드-만들기&quot;&gt;Swift 코드를 통해 multipart/form-data 코드 만들기&lt;/h2&gt;

&lt;p&gt;처음 multipart/form-data 코드를 만드려하면 참 난감하다.&lt;/p&gt;

&lt;p&gt;그래서 위에 작성한 multipart/form-data를 swift 코드로 변환해주는 함수를 작성하여 아래에 남겨두었다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;convertTextField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fieldString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;--&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;boundary&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fieldString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Content-Disposition: form-data; name=&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)\&quot;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fieldString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fieldString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fieldString&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 아래의 multipart/form-data 예제 단락을 통해 이해해보자&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;title&quot;

귀여운 딸기
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 parameter로 받아오는 key는 아래의 예시에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;title&lt;/code&gt;에 해당한다.&lt;/p&gt;

&lt;p&gt;그리고 value로 넣어줄 값은 “귀여운 딸기”라는 String이다.&lt;/p&gt;

&lt;p&gt;첫 줄에는 “–(boundary)\r\n”라는 값을 넣어 단락의 시작을 알린다.&lt;/p&gt;

&lt;p&gt;그 뒤로는 Content-Disposition과 value 값을 각각 fieldString이라는 문자열에 넣어 마무리한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;\n은 newline인 것을 알겠다지만 \r은 대체 왜 필요한지 의문이 들었다.&lt;/p&gt;

  &lt;p&gt;나와 같은 의문을 품을 독자를 위해 해당 의문에 대해 어느정도 답이 된 &lt;a href=&quot;https://m.blog.naver.com/taeil34/221325864981&quot;&gt;글&lt;/a&gt;을 첨부한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;참고한-링크&quot;&gt;참고한 링크&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP 헤더의 종류들에 대해 잘 설명해놓은 글: &lt;a href=&quot;http://go-colly.org/articles/scraping_related_http_headers/&quot;&gt;The most important HTTP headers for scraping&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;swift를 통한 URLSession Tutorial: &lt;a href=&quot;https://www.donnywals.com/uploading-images-and-forms-to-a-server-using-urlsession/&quot;&gt;Uploading images and forms to a server using URLSession&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;mozilla의 Content-Type Document: &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Type&quot;&gt;Content-Type&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;mozilla의 HTTP Methods Document: &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Methods&quot;&gt;HTTP 요청 메서드&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\r&lt;/code&gt;은 왜써야할까? : &lt;a href=&quot;https://m.blog.naver.com/taeil34/221325864981&quot;&gt;CR(\r), LF(\n)이란 무엇인가?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 12 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/HTTPBasicWithSwift/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/HTTPBasicWithSwift/</guid>
        
        <category>HTTP</category>
        
        <category>multipart/form-data</category>
        
        
        <category>네트워크</category>
        
      </item>
    
      <item>
        <title>2021년 05월 10, 11일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;h3 id=&quot;프로젝트-open-market&quot;&gt;프로젝트: Open Market&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP Response, Request에 대해 알아봄&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;작성한 글 &lt;a href=&quot;https://neph3779.github.io/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/HTTPBasicWithSwift/&quot;&gt;HTTP 기본 개념 정리 with swift&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JSONSerialization을 이용하는 방안 알아봄&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;JSONSerialization을 사용하면 API 문서를 읽고 JSON 문서에 맞는 Type을 굳이 제작하지 않아도 Key 값만 알고 있다면 Value를 꺼내서 쓸 수 있다는 장점이 있다!&lt;/p&gt;

        &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;json&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JSONSerialization&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;jsonObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as?&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UML을 통해 구조 설계를 미리 진행해봄&lt;/p&gt;

    &lt;p&gt;팀원인 덕복의 하드캐리와 함께 UML 작성이 이루어졌다.&lt;/p&gt;

    &lt;p&gt;네트워크 관련 지식이 너무 없었고 Request Header의 구성과 multipart/form-data의 구성을 전혀 몰랐던 터라 많이 답답했는데 같이 공부하면서 정말 많이 배웠다.&lt;/p&gt;

    &lt;p&gt;구조는 큰 틀로 보자면 내부에서 사용할 model이 있고 (Get을 통해 받아온 JSON 형태의 Data를 Decoding) Post와 Patch 등을 위해 있는 API model이 있다. FormData라는 프로토콜을 만들어서 Postman class에서 API통신을 수월하게 할 수 있도록 제작하였다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210512013152.png&quot; alt=&quot;OpenMarket-API&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210512013157.png&quot; alt=&quot;OpenMarket-API model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210512013205.png&quot; alt=&quot;OpenMarket-model&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 11 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.05.11-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.05.11-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
  </channel>
</rss>
