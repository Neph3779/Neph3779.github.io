<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Neph's Blog</title>
    <description>Write code with my soul.</description>
    <link>https://neph3779.github.io/</link>
    <atom:link href="https://neph3779.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 17 May 2021 01:22:09 +0900</pubDate>
    <lastBuildDate>Mon, 17 May 2021 01:22:09 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>[#13] 메모리 관리-2</title>
        <description>&lt;h2 id=&quot;multilevel-paging-and-performance&quot;&gt;MultiLevel Paging and Performance&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516123827.png&quot; alt=&quot;image-20210516123811067&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;페이지 테이블은 2단계로만 쓸 수 있는게 아닌 여러 단계의 페이지 테이블을 쓰는게 가능하다.&lt;/p&gt;

&lt;p&gt;다단계 페이지 테이블은 페이지 테이블이 사용하는 공간을 더 많이 줄일 수 있지만 변환작업을 여러번 거쳐야 하고, 주소 변환을 위해 메모리에 여러번 접근해야하기 때문에 오버헤드를 커진다.&lt;/p&gt;

&lt;p&gt;하지만 TLB라는 주소변환을 전담하는 일종의 cash 메모리 덕분에 대부분의 주소변환은 TLB를 통해 이루어지기 때문에 다단계 페이지 테이블을 사용하더라도 오버헤드가 크지 않다.&lt;/p&gt;

&lt;h2 id=&quot;valid-v--invalid-i-bit-in-a-page-table&quot;&gt;Valid (v) / Invalid (i) Bit in a Page Table&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516124142.png&quot; alt=&quot;image-20210516124138507&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;논리주소의 페이지 개수만큼 페이지 테이블의 엔트리가 존재하고 페이지가 물리적 메모리의 어떤 페이지 frame에 올라가 있는지 주소변환 정보가 들어있다고 배웠었다.&lt;/p&gt;

&lt;p&gt;하지만 페이지 테이블에는 이 외에도 부가적인 비트가 엔트리마다 저장되고 있는데 이 중 하나가 valid-invalid bit이다.&lt;/p&gt;

&lt;p&gt;메모리에 의미있는 값을 집어넣든 않든간에 6,7 등의 0은 의미있는 값으로 해석될 것이다. 프로그램이 가질 수 있는 maximum size 만큼 페이지 테이블의 엔트리가 생겨야하는데 (페이지 테이블의 특성상 위에서부터 순서대로 적어야하기 때문에 필요) 여기서  사용하지 않는 영역을 invalid로 표시한다. (32bit 운영체제라면 최대 1Mb짜리 페이지 테이블이 필요하다. )&lt;/p&gt;

&lt;h2 id=&quot;memory-protection&quot;&gt;Memory Protection&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516124543.png&quot; alt=&quot;image-20210516124540476&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;protection-bit&quot;&gt;Protection Bit&lt;/h3&gt;

&lt;p&gt;여기서는 접근해서 안될 페이지를 막아주는 protection의 의미가 아니다.&lt;/p&gt;

&lt;p&gt;페이지 테이블을 통해 이동한 것이므로 자기 자신의 페이지에만 접근할 수 있으므로 애초에 다른 프로그램의 공간에는 접근할 수 없다.&lt;/p&gt;

&lt;p&gt;여기서의 protection의 의미는 어떤 연산에 대한 접근 권한이다. 프로세스의 영역에는 code만 담고 있는 부분도 있을 것이고 (read only로 있어야 하는 부분) data 영역이나 stack 영역 같은 곳은 read&amp;amp;write 권리를 모두 가지고 있어야 하므로 이를 지정해주는 bit가 필요하다.&lt;/p&gt;

&lt;h3 id=&quot;valid-invalid-bit&quot;&gt;Valid-Invalid Bit&lt;/h3&gt;

&lt;p&gt;프로세스가 아예 주소를 사용하지 않거나 해당 페이지가 backing store에 가있는 경우 invalid로 표시된다.&lt;/p&gt;

&lt;h2 id=&quot;inverted-page-table&quot;&gt;Inverted Page Table&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516125524.png&quot; alt=&quot;image-20210516125520349&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516125629.png&quot; alt=&quot;image-20210516125626602&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Page table은 너무 많은 메모리 공간을 차지한다는 문제가 있다. 프로세스마다 각각 주소변환이 이루어져야 하기 때문에 공간 오버헤드가 큰데 이를 해결하기 위해 존재하는 것이 inverted page table이다.&lt;/p&gt;

&lt;p&gt;원래 페이지 테이블을 통한 주소의 변환을 거꾸로 뒤집어 놓은 inverted page table은 기존의 프로세스마다 필요했던 page table이 아닌 시스템 안에 page table이 딱 하나만 존재하며 page table의 엔트리가 프로세스의 page 개수만큼이 아닌 물리적인 메모리의 page 개수만큼 존재한다. page table의 첫 엔트리는 physical memory의 첫 엔트리를 나타내고 마지막 엔트리는 physical memory의 마지막 엔트리를 담당하는 식이다.&lt;/p&gt;

&lt;p&gt;기존의 page table은 주소변환을 위해 page 번호를 보고 위에서부터 page 번호만큼 떨어진 엔트리에 가서 주소변환을 하는 방법을 썼었는데 inverted의 경우 그것이 불가능하다. 원래는 논리적인 page 번호가 있으면 해당하는 엔트리에 가서 페이지 테이블에 가면 페이지 frame 번호가 몇번이지 나왔는데 역방향의 경우에는 page frame 개수만큼 엔트리가 존재하며 첫번째 entry에는 첫번째 page frame에 들어가는 논리적 page 번호가 들어있고 두번재 entry에는 두번째 page entry에 들어가는 논리적 번호가 들어있다. page frame의 f번째 entry에 가면 논리적인 page table의 번호가 나오게 되어있는게 inverted page table architecture의 구조이다.&lt;/p&gt;

&lt;p&gt;pid : 어떤 프로세스의 page인지를 저장하는 공간 (논리적 주소는 프로그램마다 별도로 존재하므로 f번째에 올라가있는 page가 어떤 프로그램의 p번째 page인지를 나타내야 함)&lt;/p&gt;

&lt;h2 id=&quot;shared-page&quot;&gt;Shared Page&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516131502.png&quot; alt=&quot;image-20210516131459581&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516131521.png&quot; alt=&quot;image-20210516131518876&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서로 다른 프로세스가 같은 코드를 가지고 프로그램을 돌린다 하면 프로그램의 코드 부분은 같은 내용이니 shared code를 이용할 수 있다. 이런 경우에는 각각의 코드를 모두 메모리에 올리는 것이 하나만 read only state로 올려서 이를 공유할 수 있다.&lt;/p&gt;

&lt;p&gt;shared code는 모든 프로세스에서 동일한 logical address상에 있어야 한다.&lt;/p&gt;

&lt;p&gt;shared code는 re-entrant code, pure code라고도 부른다.&lt;/p&gt;

&lt;p&gt;:exclamation:shared code는 공유 데이터와는 다른 개념이다. (공유 데이터와 다르게 shared code는 Read-Only이기 때문)&lt;/p&gt;

&lt;h2 id=&quot;segmentation&quot;&gt;Segmentation&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516134426.png&quot; alt=&quot;image-20210516134423619&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;segment는 프로그램을 의미가 있는 단위로 자른 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516134506.png&quot; alt=&quot;image-20210516134504076&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;세그먼트별로 주소변환이 이루어져야하기 때문에 segmentation table이 있으며, segment table의 길이가 limit register에 들어가게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516134558.png&quot; alt=&quot;image-20210516134555965&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;s는 세그먼트의 번호, d는 떨어진 위치에 해당하는 offset이다.&lt;/p&gt;

&lt;p&gt;paging과 다르게 물리적인 메모리상의 시작위치 외에도 limit이라는 segment의 길이를 가지고 있는데 page와 다르게 segment마다의 길이가 다를 수 있기 때문에 필요한 내용이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램이 가지고 있는 segment 개수보다 큰 segment를 요청하면 trap&lt;/li&gt;
  &lt;li&gt;segment의 길이보다 segment에서 떨어진 offset값이 크면 trap&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516135020.png&quot; alt=&quot;image-20210516135016652&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;segmentation 기법은 page 기법과 다르게 크기가 균일하지 않기 때문에 생기는 문제점들을 가지고 있음&lt;/p&gt;

&lt;p&gt;하지만 의미 단위의 일을 하기 위해서는 매우 효과적 (실행권리 권한부여의 구역을 나누기 쉽기 때문)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516134940.png&quot; alt=&quot;image-20210516134937476&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516135044.png&quot; alt=&quot;image-20210516135041217&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;segment와 page를 비교했을 때 table에 의한 공간 낭비가 큰 쪽은 paging 기법쪽이다.&lt;/p&gt;

&lt;h2 id=&quot;segmentation-with-paging&quot;&gt;Segmentation with Paging&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210516202942.png&quot; alt=&quot;image-20210516202939549&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;[정리]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;물리적인 메모리를 나누는 방법으로 크게 연속 할당과 불연속 할당 기법이 있었다. 이 중 불연속 할당 기법에 이용할 수 있는 방법으로는 paging, segmentation, paged segmentation이 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Paged Segmentation 기법을 사용하면 segment가 page로 쪼개져서 올라가기 때문에 segmentation의 조각 문제가 발생하지 않는다.&lt;/p&gt;

&lt;p&gt;자세한 작동방식은 글로 풀어쓰기보다는 위의 순서도를 이해해보는게 나을 것 같다.&lt;/p&gt;
</description>
        <pubDate>Sun, 16 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/13-Memory-Management-2/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/13-Memory-Management-2/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>2021년 05월 13일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;TalbeView Cell의 재활용에 대해 공부&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;prepare for reuse&lt;/li&gt;
      &lt;li&gt;data prefetch&lt;/li&gt;
      &lt;li&gt;나중에 받아온 data 어떻게 원하는 위치에 꽂아줄까? (feat: closure capture)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;modern cell configuration에 대해 공부&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;cell의 기본 imageView 같은 경우에는 사이즈를 임의로 조절할 수 없다 (구려!)&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2020/10027/&quot;&gt;modern cell configuration WWDC&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;escaping closure에 대해 공부&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;함수가 종료된 후에 completionHandler가 호출될 때 escaping이 필요!
        &lt;ul&gt;
          &lt;li&gt;이게 어떻게 가능할까? -&amp;gt; 오래걸리는 작업을 다른 스레드로 보내서 비동기 작업을 할 때 벌어질 수 있음&lt;/li&gt;
          &lt;li&gt;동기작업[…] -&amp;gt; 비동기[completionHandler] -&amp;gt; 함수 종료 -&amp;gt; 이후에 비동기 작업 실행 or 완료&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;flatmapError에 대해 공부&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;예제코드&lt;/p&gt;

        &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;flatMapError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ResponsedPage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SessionManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataIsNotJSON&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataIsNotJSON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;kt&quot;&gt;XCTFail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;invalidURL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Error인 경우만 뽑아서 후처리를 해준 뒤 return을 통해 Result type으로 넘겨줄 수 있다(success로 넘겨줄 수도 있다는 말)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 13 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/2021.05.13-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/2021.05.13-TIL/</guid>
        
        
      </item>
    
      <item>
        <title>HTTP 기본 개념 정리 with swift</title>
        <description>&lt;h2 id=&quot;http란&quot;&gt;HTTP란?&lt;/h2&gt;

&lt;p&gt;CSS, HTML, 이미지 등이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Server와&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Client가&lt;/code&gt; 서로 주고받는 Content라면&lt;/p&gt;

&lt;p&gt;Content를 주고받기 위해 서로가 알아들을 수 있는 공통의 약속(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Protocol&lt;/code&gt;)이 필요하다.&lt;/p&gt;

&lt;p&gt;이 약속이 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP&lt;/code&gt;(Hyper Text Tranfer Protocol)이다.&lt;/p&gt;

&lt;h2 id=&quot;request와-response&quot;&gt;Request와 Response&lt;/h2&gt;

&lt;p&gt;HTTP는 크게 Request와 Response로 구분된다.&lt;/p&gt;

&lt;p&gt;Client가 Request 메세지를 작성해서 Server에 보내면 Server는 Response를 보내준다.&lt;/p&gt;

&lt;p&gt;Request와 Response Message는 각각 Header와 Body로 구분된다.&lt;/p&gt;

&lt;h2 id=&quot;http-message-구조&quot;&gt;HTTP Message 구조&lt;/h2&gt;

&lt;p&gt;Request의 Message는 다음과 같은 구조로 이루어져 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210511230558.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Header와 Body로 구분되며 그 사이에는 반드시 blank line이 들어가야한다.&lt;/p&gt;

&lt;h3 id=&quot;header의-구조&quot;&gt;Header의 구조&lt;/h3&gt;

&lt;p&gt;가장 첫 줄은 Request Line으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP Method Name&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;요청할 파일의 형식/요청할 파일의 이름&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사용할 HTTP 버전&lt;/code&gt;으로 이루어져있다.&lt;/p&gt;

&lt;p&gt;Request Line을 제외한 나머지 부분을 Request Header라고 부르는데 필수로 적어야하는 Host Header를 제외하면 다른 Header는 꼭 있어야 하는건 아니다.&lt;/p&gt;

&lt;p&gt;이번 프로젝트에서 중요하게 이용되는 HTTP Header인  Conten-type에는  Body에 들어갈 Message의 MIME(Multipurpose Internet Mail Extensions) type을 적어줄 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;body의-구조&quot;&gt;Body의 구조&lt;/h3&gt;

&lt;p&gt;MIME type은 여러가지 종류가 있는데 가장 대표적인 것은 HTML 코드이며,  이번 프로젝트에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multipart/form-data&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt;을 사용한다. JSON에 비해 상대적으로 익숙하지 않은 multipart/form-data를 아래에 정리해보았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MIME Type에 대해 설명하고 있는 mozilla 문서: &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types&quot;&gt;MIME 타입&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;더 많은 MIME Type은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types&quot;&gt;이 링크&lt;/a&gt;에서 볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;multipartform-data&quot;&gt;multipart/form-data&lt;/h3&gt;

&lt;p&gt;multipart/form-data는 HTML Form의 내용을 전송할 때 사용할 수 있는 문서 형식이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&lt;/code&gt;로 시작되는 문자열인 boundary로 구분되는 서로 다른 파트들로 구성되며, 각각의 파트는 그 자체로서 개체이며 자신만의 HTTP 헤더를 가진다. 파일 업로드 필드를 위한 헤더로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Disposition&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Type&lt;/code&gt;이 있다.&lt;/p&gt;

&lt;p&gt;Content-type Header에 boundary parameter를 포함해야하며 이 boundary parameter는 메세지 파트의 구분(multipart를 서로 구분해주는 역할)과 메세지의 시작과 끝을 나타내는 역할을 한다.&lt;/p&gt;

&lt;p&gt;첫번째 Boundary 이전의 Body는 MIME을 지원하지 않는 클라이언트를 위해 제공되는 영역이다.&lt;/p&gt;

&lt;p&gt;boundary parameter에 들어갈 문자열을 프로그래머가 무작위 문자를 선택해서 작성한다. 이 때 보통 앞부분에는 WebkitFormBoundary… 등과 같이 프로그래머가 인식할 수 있는 문자를 삽입하며 뒷부분에 무작위 문자열을 붙여서 Boundary가  unique하도록 만들어 본문과의 충돌을 피한다.&lt;/p&gt;

&lt;h2 id=&quot;http-코드를-보며-이해해보자&quot;&gt;HTTP 코드를 보며 이해해보자&lt;/h2&gt;

&lt;div class=&quot;language-http highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;POST&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;/item&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;HTTP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1.1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;camp-open-market-2.herokuapp.com&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Content-Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW&lt;/span&gt;

----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;title&quot;

귀여운 딸기
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;descriptions&quot;

귀여운 딸기입니다.
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;price&quot;

1000
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;currency&quot;

KRW
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;stock&quot;

10
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;images[]&quot;; filename=&quot;Strawberry-removebg-preview.png&quot;
Content-Type: image/png

(data)
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;password&quot;

neph1234
----WebKitFormBoundary7MA4YWxkTrZu0gW--
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;request-line&quot;&gt;Request Line&lt;/h3&gt;

&lt;div class=&quot;language-http highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;POST&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;/item&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;HTTP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1.1&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;가장 첫 줄에는 Request Line이 적혀있는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;POST는 HTTP Method 중 하나이며 더 많은 메서드에 대한 정보는 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Methods&quot;&gt;이 링크&lt;/a&gt;에서 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;request-headers&quot;&gt;Request Headers&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Host: camp-open-market-2.herokuapp.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Request Header에는 여러가지 Header가 선택적으로 들어갈 수 있으며 이 코드에서는 Host와 Content-Type Header가 들어가 있다.&lt;/p&gt;

&lt;p&gt;Content-Type의 내용으로는 multipart/form-data와 boundary parameter가 전달된다.&lt;/p&gt;

&lt;p&gt;boundary parameter로는 임의의 문자열이 전달되면 된다 (보통 swift에서는 UUID를 활용)&lt;/p&gt;

&lt;h3 id=&quot;request-body&quot;&gt;Request Body&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;title&quot;

귀여운 딸기
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;descriptions&quot;

귀여운 딸기입니다.
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;price&quot;

1000
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;currency&quot;

KRW
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;stock&quot;

10
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;images[]&quot;; filename=&quot;Strawberry-removebg-preview.png&quot;
Content-Type: image/png

(data)
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;password&quot;

neph1234
----WebKitFormBoundary7MA4YWxkTrZu0gW--
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Request Body내의 하나의 단락의 시작은 boundary로 시작한다.&lt;/p&gt;

&lt;p&gt;밑줄에는 Content-Disposition을 적어주고&lt;/p&gt;

&lt;p&gt;blank line을 하나 삽입한 뒤&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;에 명시된 공간에 들어갈 내용을 적어준다&lt;/p&gt;

&lt;p&gt;즉, 아래의 코드가 하나의 단락이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;title&quot;

귀여운 딸기
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;주의할 점은 (data)라고 적힌 공간에는 문자열로 변환된 data가 들어있다.&lt;/p&gt;

&lt;p&gt;이미지의 문자열로의 변환은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIImageJPEGRepresentation&lt;/code&gt;메서드를 통해 진행해줄 수 있다.&lt;/p&gt;

&lt;p&gt;Body의 마지막에는 boudary를 적어주며, 꼭 따라야하는 것은 아니지만 관례적으로 boudary 뒤에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&lt;/code&gt;를 붙여줌으로써 구분이 쉽도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;swift-코드를-통해-multipartform-data-코드-만들기&quot;&gt;Swift 코드를 통해 multipart/form-data 코드 만들기&lt;/h2&gt;

&lt;p&gt;처음 multipart/form-data 코드를 만드려하면 참 난감하다.&lt;/p&gt;

&lt;p&gt;그래서 위에 작성한 multipart/form-data를 swift 코드로 변환해주는 함수를 작성하여 아래에 남겨두었다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;convertTextField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fieldString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;--&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;boundary&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fieldString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Content-Disposition: form-data; name=&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)\&quot;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fieldString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fieldString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fieldString&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 아래의 multipart/form-data 예제 단락을 통해 이해해보자&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;title&quot;

귀여운 딸기
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 parameter로 받아오는 key는 아래의 예시에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;title&lt;/code&gt;에 해당한다.&lt;/p&gt;

&lt;p&gt;그리고 value로 넣어줄 값은 “귀여운 딸기”라는 String이다.&lt;/p&gt;

&lt;p&gt;첫 줄에는 “–(boundary)\r\n”라는 값을 넣어 단락의 시작을 알린다.&lt;/p&gt;

&lt;p&gt;그 뒤로는 Content-Disposition과 value 값을 각각 fieldString이라는 문자열에 넣어 마무리한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;\n은 newline인 것을 알겠다지만 \r은 대체 왜 필요한지 의문이 들었다.&lt;/p&gt;

  &lt;p&gt;나와 같은 의문을 품을 독자를 위해 해당 의문에 대해 어느정도 답이 된 &lt;a href=&quot;https://m.blog.naver.com/taeil34/221325864981&quot;&gt;글&lt;/a&gt;을 첨부한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;참고한-링크&quot;&gt;참고한 링크&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP 헤더의 종류들에 대해 잘 설명해놓은 글: &lt;a href=&quot;http://go-colly.org/articles/scraping_related_http_headers/&quot;&gt;The most important HTTP headers for scraping&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;swift를 통한 URLSession Tutorial: &lt;a href=&quot;https://www.donnywals.com/uploading-images-and-forms-to-a-server-using-urlsession/&quot;&gt;Uploading images and forms to a server using URLSession&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;mozilla의 Content-Type Document: &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Type&quot;&gt;Content-Type&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;mozilla의 HTTP Methods Document: &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Methods&quot;&gt;HTTP 요청 메서드&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\r&lt;/code&gt;은 왜써야할까? : &lt;a href=&quot;https://m.blog.naver.com/taeil34/221325864981&quot;&gt;CR(\r), LF(\n)이란 무엇인가?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 12 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/HTTPBasicWithSwift/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/HTTPBasicWithSwift/</guid>
        
        <category>HTTP</category>
        
        <category>multipart/form-data</category>
        
        
        <category>네트워크</category>
        
      </item>
    
      <item>
        <title>2021년 05월 10, 11일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;h3 id=&quot;프로젝트-open-market&quot;&gt;프로젝트: Open Market&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP Response, Request에 대해 알아봄&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;작성한 글 &lt;a href=&quot;https://neph3779.github.io/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/HTTPBasicWithSwift/&quot;&gt;HTTP 기본 개념 정리 with swift&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JSONSerialization을 이용하는 방안 알아봄&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;JSONSerialization을 사용하면 API 문서를 읽고 JSON 문서에 맞는 Type을 굳이 제작하지 않아도 Key 값만 알고 있다면 Value를 꺼내서 쓸 수 있다는 장점이 있다!&lt;/p&gt;

        &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;json&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JSONSerialization&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;jsonObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as?&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UML을 통해 구조 설계를 미리 진행해봄&lt;/p&gt;

    &lt;p&gt;팀원인 덕복의 하드캐리와 함께 UML 작성이 이루어졌다.&lt;/p&gt;

    &lt;p&gt;네트워크 관련 지식이 너무 없었고 Request Header의 구성과 multipart/form-data의 구성을 전혀 몰랐던 터라 많이 답답했는데 같이 공부하면서 정말 많이 배웠다.&lt;/p&gt;

    &lt;p&gt;구조는 큰 틀로 보자면 내부에서 사용할 model이 있고 (Get을 통해 받아온 JSON 형태의 Data를 Decoding) Post와 Patch 등을 위해 있는 API model이 있다. FormData라는 프로토콜을 만들어서 Postman class에서 API통신을 수월하게 할 수 있도록 제작하였다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210512013152.png&quot; alt=&quot;OpenMarket-API&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210512013157.png&quot; alt=&quot;OpenMarket-API model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210512013205.png&quot; alt=&quot;OpenMarket-model&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 11 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.05.11-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.05.11-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>2021년 05월 10일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP Method, HTTP Request Code, HTTP Request, Response Header, Body 구조 공부&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://opentutorials.org/course/3385/21673&quot;&gt;HTTP강의&lt;/a&gt; by 생활코딩&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=8GH0yMPvQFU&amp;amp;ab_channel=KiloLoco&quot;&gt;Multipart/form-data 구성 by swift 유튜브 강의&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;git flow, git branch 생성 전략에 대해 공부함&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://woowabros.github.io/experience/2017/10/30/baemin-mobile-git-branch-strategy.html&quot;&gt;git flow 전략&lt;/a&gt; by 우아한 형제들&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://junshock5.tistory.com/82&quot;&gt;issue기반 branch 생성&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;github의 issue, project, milestone, label등에 대해 알게 됨&lt;/li&gt;
      &lt;li&gt;https://developer.apple.com/videos/play/wwdc2017/405/&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;URLSession과 그 사용법에 대해 공부함 (dataTask, request)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/documentation/foundation/urlsession/&quot;&gt;URLSession 공식문서&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/documentation/foundation/urlsessiondelegate&quot;&gt;URLSession Delegate 공식문서&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate&quot;&gt;URLSessionTask Delegate 공식문서&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/documentation/foundation/urlrequest/&quot;&gt;URLRequest 공식문서&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;header에 내용을 추가하기 위해 사용되는 request type의 instance method &lt;a href=&quot;https://developer.apple.com/documentation/foundation/urlrequest/2011522-addvalue&quot;&gt;addValue(_:forHTTPHeaderField:) 공식문서&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/documentation/foundation/url_loading_system&quot;&gt;URL Loading System&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/documentation/foundation/url_loading_system/fetching_website_data_into_memory&quot;&gt;Fetching Website Data into Memory&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=toU4o5Z0cVM&amp;amp;list=PLAHa1zfLtLiM7hxIjjWaXbB5-pxs25EFR&amp;amp;index=8&amp;amp;ab_channel=%EB%93%9C%EB%A6%BC%EC%BD%94%EB%94%A9by%EC%97%98%EB%A6%AC&quot;&gt;코드스쿼드의 iOS 네트워크 프로그래밍 공개영상&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JSONSerialization을 통해 type 구현 없이 간단한 data를 꺼낼 수 있는 방법 공부&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;https://www.hackingwithswift.com/example-code/system/how-to-parse-json-using-jsonserialization&quot;&gt;참고한 링크&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;예제코드&lt;/p&gt;

        &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;errorData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JSONSerialization&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;jsonObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                                        &lt;span class=&quot;nv&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;completionHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataIsNotJSON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/foundation/jsonserialization/1418059-jsonobject&quot;&gt;jsonObject 공식문서&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잡다한-정보들&quot;&gt;잡다한 정보들&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ARC를 통한 인스턴스의 생명주기는 컴파일 타임에 결정된다!&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;deinit하는 코드를 원래는 프로그래머가 직접 작성했다면 ARC를 통해 그 코드가 컴파일 타임에 삽입되므로 프로그래머의 수고가 줄어듦&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;app delegate의 … with laucnOption에서의 laucnOption은 앱이 어떤 루트로 실행되었는지를 알려주는 것!&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;push 알림을 눌러서 진입&lt;/li&gt;
      &lt;li&gt;다른 앱을 통해서 열려서 진입&lt;/li&gt;
      &lt;li&gt;그냥 앱을 눌러서 진입&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP의 상태코드는 status코드! state와 헷갈리지 말자!&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://blog.naver.com/PostView.nhn?blogId=tommy6753&amp;amp;logNo=220830550597&quot;&gt;staus vs state&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 10 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.05.10-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.05.10-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>[#12] 메모리 관리-1</title>
        <description>&lt;h2 id=&quot;logical-address-vs-physical-address&quot;&gt;Logical Address vs Physical Address&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509140605.png&quot; alt=&quot;image-20210509140602320&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Logical address는 프로세스마다 독립적으로 가지는 주소공간이다. 어떤 프로세스가 메모리상에서 어느 지점에 위치하는지와 무관하게 논리적으로 각 프로세스가 0번지부터 가지고 있는 주소값을 Logical address(virtual address)라고 부른다.&lt;/p&gt;

&lt;p&gt;반면 Physical address는 메모리에 실제로 올라가있는 위치를 나타낸다.&lt;/p&gt;

&lt;p&gt;어떤 프로그램이 물리적인 메모리의 어느 지점으로 올라갈지에 대해 결정하는 것을 주소 바인딩이라 한다. 주소 바인딩의 시점은 크게 3가지로 분류할 수 있다.&lt;/p&gt;

&lt;p&gt;❗️Symbolic Address란 우리가 흔히 사용하는 포인터라 볼 수 있다. 프로그래밍을 할 때 논리적인 주소값을 실제로 사용하는 경우는 거의 없고 Symbolic한 공간에 담아서 사용하는데 이런 것을 Symbolic Address라 한다. 컴파일 시에 이런 Symbolic Address는 Logical Address로 바뀌게 된다.&lt;/p&gt;

&lt;h2 id=&quot;주소-바인딩의-3가지-시점&quot;&gt;주소 바인딩의 3가지 시점&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509141342.png&quot; alt=&quot;image-20210509141341673&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509141431.png&quot; alt=&quot;image-20210509141428970&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;주소 바인딩이 이루어지는 시점은 크게 다음 3가지로 분류할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Compile time binding&lt;/p&gt;

    &lt;p&gt;컴파일 타임에 Physical address가 결정됨 (사실상 Logical address가 Physical address와 같음)&lt;/p&gt;

    &lt;p&gt;컴파일 타임에 메모리 어느위치에 올라가야 할지가 결정되어야 하므로 비효율적&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Load time binding&lt;/p&gt;

    &lt;p&gt;프로그램이 메모리에 올라갈 때 Logical address를 Physical address에 올려준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Execution time binding (= Run time binding)&lt;/p&gt;

    &lt;p&gt;Load time binding과 기본적으로 같지만 Physical address가 실행되는 도중에 바뀔 수 있다. (메모리에서 쫓겨났다가 다시 메모리에 올라갈 수 있으므로)&lt;/p&gt;

    &lt;p&gt;하드웨어적 지원이 필요한 방식이며 MMU라는 하드웨어가 이를 담당한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;❗️ instruction code내부의 Logical Address는 메모리에 올라가더라도 Logical Address의 상태를 유지하고 있으므로 CPU가 보는 주소는 Logical Address라는 것에 유의&lt;/p&gt;

&lt;h2 id=&quot;memory-management-unit&quot;&gt;Memory Management Unit&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509173608.png&quot; alt=&quot;image-20210509173605022&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;주소변환을 위한 하드웨어 장치인 MMU는 base register(relocation register)의 값을 통해 user program과 CPU가 Logical address만을 가지고 일할 수 있도록 도와준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509173742.png&quot; alt=&quot;image-20210509173739212&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509173920.png&quot; alt=&quot;image-20210509173916868&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가장 간단한 형태의 MMU는 Relocation register와 Limit register 이 두개의 레지스터를 통해 주소바인딩을 진행한다.&lt;/p&gt;

&lt;p&gt;그림의 예제에서는 Logical Address 346번지를 보려하고 있다. 이런 상황에서 프로세스 p1의 시작위치(relocation register) + 346에 위치한 메모리에 올라가있는 값을 읽어 반환한다.&lt;/p&gt;

&lt;p&gt;Limit register는 프로그램의 크기를 담는 값으로 범위를 벗어난 주소로의 잘못된 접근을 막아준다. (다른 프로그램이 존재하는 위치의 값을 참조할 수 없음)&lt;/p&gt;

&lt;h2 id=&quot;몇가지-용어-정리&quot;&gt;몇가지 용어 정리&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509174433.png&quot; alt=&quot;image-20210509174430642&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dynamic-loading-loading-메모리로-올리는-것&quot;&gt;Dynamic Loading (Loading: 메모리로 올리는 것)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 전체를 메모리에 미리 올리는 것이 아닌 해당 루틴이 불려질 때 메모리에 load하는 것&lt;/li&gt;
  &lt;li&gt;메모리 이용률 향상&lt;/li&gt;
  &lt;li&gt;가끔식 사용되는 코드들이 많은 경우에 유용 (오류 처리 루틴은 가끔씩만 사용됨)&lt;/li&gt;
  &lt;li&gt;운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능
    &lt;ul&gt;
      &lt;li&gt;OS가 라이브러리를 통해 Dynamic Loading을 쉽게 할 수 있도록 지원)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dynamic-linking&quot;&gt;Dynamic Linking&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Linking을 실행 시간(execution time)까지 미루는 기법&lt;/li&gt;
  &lt;li&gt;Static linking
    &lt;ul&gt;
      &lt;li&gt;라이브러리가 프로그램의 실행 파일 코드에 포함됨&lt;/li&gt;
      &lt;li&gt;실행 파일의 크기가 커짐&lt;/li&gt;
      &lt;li&gt;동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dynamic linking
    &lt;ul&gt;
      &lt;li&gt;라이브러리가 실행시에 연결(link)됨&lt;/li&gt;
      &lt;li&gt;라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 stub이라는 작은 코드를 둠&lt;/li&gt;
      &lt;li&gt;라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고, 없으면  디스크에서 읽어옴&lt;/li&gt;
      &lt;li&gt;운영체제의 도움이 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;overlays&quot;&gt;Overlays&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;메모리에 프로세스의 부분 중 실제 필요한 정보만을 올림&lt;/li&gt;
  &lt;li&gt;프로세스의 크기가 메모리보다 클 때 유용&lt;/li&gt;
  &lt;li&gt;운영체제의 지원없이 사용자에 의해 구현&lt;/li&gt;
  &lt;li&gt;작은 공간의 메모리를 사용하던 초창기 시스테메서 수작업으로 프로그래머가 구현
    &lt;ul&gt;
      &lt;li&gt;Manual Overlay&lt;/li&gt;
      &lt;li&gt;프로그래밍이 매우 복잡함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;swapping&quot;&gt;Swapping&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Swapping : 프로세스를 일시적으로 메모리에서 backing store로(하드디스크 등) 쫓아내는 것&lt;/li&gt;
  &lt;li&gt;Backing store (= swap area)
    &lt;ul&gt;
      &lt;li&gt;디스크 : 많은 사용자의 프로세스 이미지를 담&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Swap in / Swap out
    &lt;ul&gt;
      &lt;li&gt;일반적으로 중기 스케쥴러 (swapper)에 의해 swap out 시킬 프로세스 선정&lt;/li&gt;
      &lt;li&gt;priority based CPU scheduling algorithm
        &lt;ul&gt;
          &lt;li&gt;priority가 낮은 프로세스를 swapped out&lt;/li&gt;
          &lt;li&gt;priority가 높은 프로세스를 메모리에 올려놓음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Compile time 혹은  load time binding 에서는 원래 메모리 위치로 swap in 해야함&lt;/li&gt;
      &lt;li&gt;Run time binding에서는 추후 빈 메모리 영역 아무 곳에나 올릴 수 있음&lt;/li&gt;
      &lt;li&gt;swap time은 대부분 transfer time (swap되는 양에 비례하는 시간)임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509180641.png&quot; alt=&quot;image-20210509180638441&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스를 메모리에서 backing store로 swap out하고&lt;/p&gt;

&lt;p&gt;backing store에서 메모리로 다시 swap in 하는 과정&lt;/p&gt;

&lt;h2 id=&quot;allocation-of-physical-memory&quot;&gt;Allocation of Physical Memory&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509183936.png&quot; alt=&quot;image-20210509183932669&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;물리 메모리는 낮은 주소공간에 OS가, 높은 주소공간에 사용자 프로세스가 올라간다.&lt;/p&gt;

&lt;p&gt;사용자 프로세스를 할당하는 방법에는 연속 할당과 불연속 할당이 있다.&lt;/p&gt;

&lt;p&gt;불연속 할당의 예시로는 잘 알려진 Paging 기법이 있다.&lt;/p&gt;

&lt;h2 id=&quot;연속-할당&quot;&gt;연속 할당&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509184148.png&quot; alt=&quot;image-20210509184146679&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연속 할당은 고정 분할 방식과 가변분할 방식으로 구분된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509184248.png&quot; alt=&quot;image-20210509184246161&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;고정 분할 방식은 사용자의 프로그램을 미리 파티션(분할)으로 나누는 것이고&lt;/p&gt;

&lt;p&gt;가변 분할 방식은 사용자 프로그램이 들어가 있는 메모리 영역을 미리 나누지 않는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509184231.png&quot; alt=&quot;image-20210509184229095&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;외부 조각이란 프로그램의 크기보다 분할의 크기가 작은 경우에 발생 (다른 프로그램이 들어가기엔 너무 작은 공간)&lt;/p&gt;

&lt;p&gt;내부 조각이란 프로그램이 들어가고도 남아버린 공간&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509190019.png&quot; alt=&quot;image-20210509190016473&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Hole : 가용 메모리 공간&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509190145.png&quot; alt=&quot;image-20210509190141506&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연속 할당을 사용하면 Hole이 생기는데 이 Hole의 어느 위치에 프로그램을 넣을 것인지에 대한 문제가 Dynamic Storage Allocation Problem이다.&lt;/p&gt;

&lt;p&gt;이 문제를 해결하는 알고리즘은 대표적으로 다음 세가지가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;First - fit&lt;/li&gt;
  &lt;li&gt;Best - fit&lt;/li&gt;
  &lt;li&gt;Worst - fit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509190404.png&quot; alt=&quot;image-20210509190401752&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;외부조각 문제를 해결하는 방법중엔 compaction 이라는 방법이 있는데 사용중인 메모리 영역을 한군데로 몰아서 사용 가능한 넓은 공간을 얻어내는 방법이다. compaction시 최소한의 메모리 이동 방법을 구하기 매우 어려우며 비용이 많이 든다.&lt;/p&gt;

&lt;h2 id=&quot;paging-기법&quot;&gt;Paging 기법&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509190553.png&quot; alt=&quot;image-20210509190550691&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509191337.png&quot; alt=&quot;image-20210509191333969&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각각의 page로 나누어 비어있는 공간이 있다면 page를 물리적인 메모리(page frame)에 할당해준다.&lt;/p&gt;

&lt;p&gt;logical page frame이 physical memory의 어떤 frame에 올라가 있는지에 대해 다루는 것이 page table이다.&lt;/p&gt;

&lt;p&gt;page table의 내용에는 frame의 번호가 담겨있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509193903.png&quot; alt=&quot;image-20210509193900472&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 그림은 paging 기법을 나타낸 그림이다.&lt;/p&gt;

&lt;p&gt;CPU가 논리적인 주소를 주면 물리적인 주소로 바꿔주는 작업을 page table을 거쳐서 진행한다.&lt;/p&gt;

&lt;p&gt;p는 page의 번호가 되고 d는 page 내에서 얼만큼 떨어져 있는지를 나타내는 offset이 된다.&lt;/p&gt;

&lt;p&gt;물리적인 주소로 바꾸기 위해 page의 번호를 frame의 번호로 바꾸는 작업이 page table에서 진행된다.&lt;/p&gt;

&lt;p&gt;page table의 용량이 매우 크기 때문에 page table은 물리적 메모리에 들어가게 된다.&lt;/p&gt;

&lt;h2 id=&quot;tlb--associative-register&quot;&gt;TLB &amp;amp; Associative Register&lt;/h2&gt;

&lt;h3 id=&quot;page-table의-구현&quot;&gt;Page Table의 구현&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509194641.png&quot; alt=&quot;image-20210509194638320&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;메모리에 접근하기 위해서는 주소 변환을 해야하며&lt;/p&gt;

&lt;p&gt;page table이 메모리에 존재하기 때문에&lt;/p&gt;

&lt;p&gt;page table에 접근하는 과정에서 메모리 접근이 이루어지고&lt;/p&gt;

&lt;p&gt;page table을 통해 변환된 주소로 이동하는 과정에서 또 한번 메모리 접근이 이루어진다.&lt;/p&gt;

&lt;p&gt;MMU는 base register와 limit register가 존재했는데 Page Table에서는 이것이 Page-table base register(PTBR)와 Page-table length register(PTLR) 두가지로 이용된다.&lt;/p&gt;

&lt;p&gt;PTBR은 page table을 가리키며 (메모리에 존재하므로 page table에 접근하기 위해 필요)&lt;/p&gt;

&lt;p&gt;PTLR은 테이블의 크기를 보관한다. (limit의 용도)&lt;/p&gt;

&lt;p&gt;이렇듯 두 번의 메모리 접근은 비용이 크기 때문에 속도 향상을 위해 별도의 하드웨어 자원을 두기도 하는데 associative register 혹은 Translation Look-aside Buffer(TLB)라 불리는 캐시를 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;tlb&quot;&gt;TLB&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509195201.png&quot; alt=&quot;image-20210509195158476&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;캐시 메모리 : 메인 메모리 윗단에 존재하는 메인 메모리에서 빈번히 사용되는 메모리를 더 빨리 접근할 수 있게 해주는 메모리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TLB는 page table에서 빈번히 이용되는 table 값을 캐싱하고 있음 (메인 메모리보다 접근 속도가 빠름)&lt;/p&gt;

&lt;p&gt;CPU가 메모리에 접근할때는 먼저 TLB를 검색해보고 TLB에 없는 경우 (TLB miss)에는 page table를 통해 접근한다.&lt;/p&gt;

&lt;p&gt;page 번호와 frame 번호 쌍을 가지고 있으며 TLB 전체를 검색해봐야 있는지 없는지를 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;associative-register&quot;&gt;Associative Register&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509195711.png&quot; alt=&quot;image-20210509195707543&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TLB 전체를 항상 검색해봐야한다는 특성 때문에 병렬적 탐색이 가능한 Associative register를 사용한다.&lt;/p&gt;

&lt;p&gt;TLB와 page table은 프로세스마다 존재해야하므로 문맥교환이 일어날때마다 flush 작업을 해줘서 비워줘야 한다.&lt;/p&gt;

&lt;h3 id=&quot;실제-메모리-접근-시간&quot;&gt;실제 메모리 접근 시간&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509200005.png&quot; alt=&quot;image-20210509200001687&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;two-level-page-table&quot;&gt;Two-Level Page Table&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509200119.png&quot; alt=&quot;image-20210509200117200&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509202817.png&quot; alt=&quot;image-20210509202814597&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509203420.png&quot; alt=&quot;image-20210509203416523&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509203524.png&quot; alt=&quot;image-20210509203521191&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일반 Page Table은 공간의 낭비가 크므로 이를 개선하기 위해 있는 것이 Two-Level Paging Table&lt;/p&gt;

&lt;p&gt;inner table의 entry 하나당 크기는 4bytes인데 이는 inner table의 크기가 실제 page의 크기와 같기 때문이다.&lt;/p&gt;

&lt;p&gt;2^10 = 1K이므로 1K만큼의 크기를 가진 page와 매칭이 가능하다.&lt;/p&gt;

</description>
        <pubDate>Sun, 09 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/12-Memory-Management/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/12-Memory-Management/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>frame &amp; bounds</title>
        <description>&lt;h2 id=&quot;frame&quot;&gt;frame&lt;/h2&gt;

&lt;p&gt;frame은 Superview 좌표계의 (0, 0)으로부터 얼마만큼 떨어져 있는지(위치) + view의 크기를 나타내는 값이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Superview 좌표계의 (0, 0)은 Superview의 좌상단 꼭짓점이 아닐 수도 있다.&lt;/strong&gt; (Superview의 bounds가 변경된 경우)&lt;/p&gt;

&lt;p&gt;이 문장이 frame과 bounds를 이해하는데 핵심이 된다.&lt;/p&gt;

&lt;h2 id=&quot;bounds&quot;&gt;bounds&lt;/h2&gt;

&lt;p&gt;bounds는 view 자기 자신의 좌표계에서 원점(좌상단 꼭짓점)의 좌표값(origin의 좌표값) + view의 크기를 나타내는 값이다.&lt;/p&gt;

&lt;h2 id=&quot;frame과-bounds의-차이---그림을-통한-이해&quot;&gt;frame과 bounds의 차이 - 그림을 통한 이해&lt;/h2&gt;

&lt;p&gt;다음 코드를 이해해보자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509013223.png&quot; alt=&quot;image-20210509013221679&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;superview는 빨간색, subview는 파란색이다.&lt;/p&gt;

&lt;p&gt;주목할 점은 superview의 bouns.origin 값을 설정하는 부분이다.&lt;/p&gt;

&lt;p&gt;(-50, -50)으로 설정해준 것을 볼 수 있는데 이 말은 즉슨 빨간색 네모의 좌상단 꼭짓점의 좌표값이 (-50, -50)이라는 것이다.&lt;/p&gt;

&lt;p&gt;이제 subview가 어디에 그려질지 상상해보자면&lt;/p&gt;

&lt;p&gt;subview의 frame의 x값과 y값이 각각 0이므로 superview의 (0, 0)으로부터 (0, 0) 떨어진 위치에서부터 그려질 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509013515.png&quot; alt=&quot;simulator_screenshot_A7734F26-C68D-4995-9DCB-BE29FC951127&quot; style=&quot;zoom: 25%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;superview의 관점에서 보았을 때 빨간색 네모의 좌상단 꼭짓점의 좌표는 (-50, -50)이며&lt;/p&gt;

&lt;p&gt;파란색 네모의 좌상단 꼭짓점의 좌표가 (0, 0)에 해당하는 위치인 것이다.&lt;/p&gt;

&lt;h2 id=&quot;scrollview의-이해&quot;&gt;ScrollView의 이해&lt;/h2&gt;

&lt;p&gt;위의 내용을 이해하면 한걸음 나아가서 scroll view의 동작원리에 대해 이해할 수 있다.&lt;/p&gt;

&lt;p&gt;위의 빨간색, 파란색 네모 예제에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;superview.bounds.origin&lt;/code&gt;의 y값을 증가시키면 파란색 네모는 위쪽으로 올라간다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;superview.bounds.origin&lt;/code&gt;의 y값을 -50에서 -10으로 증가시켰을 때의 결과이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509014113.png&quot; alt=&quot;simulator_screenshot_8A7C995E-1E78-43E8-A7DD-F4CEB0F30B0D&quot; style=&quot;zoom:25%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;빨간색 네모의 좌상단 꼭짓점의 좌표값은 (-50, -10)이 된 것이고&lt;/p&gt;

&lt;p&gt;파란색 네모의 좌상단 꼭짓점은 superview의 (0, 0)이므로 위와 같은 결과가 나온 것이다.&lt;/p&gt;

&lt;p&gt;이를 통해 ScrollView는 superview의 bounds.origin의 x값이나 y값을 스크롤하는 만큼 증가/감소시킨다는 것을 알 수 있다.&lt;/p&gt;

</description>
        <pubDate>Fri, 07 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/ios/frame-bounds-difference/</link>
        <guid isPermaLink="true">https://neph3779.github.io/ios/frame-bounds-difference/</guid>
        
        <category>frame</category>
        
        <category>bound</category>
        
        <category>origin</category>
        
        <category>center</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>2021년 05월 04일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;TDD
    &lt;ul&gt;
      &lt;li&gt;TDD의 용어에 대해 알아보고 실제 Unit Test 코드에 적용시켜보는 과정 진행&lt;/li&gt;
      &lt;li&gt;읽어본 글 : &lt;a href=&quot;https://saad-eloulladi.medium.com/unit-tests-swift-mocking-the-right-way-65488848a3fc&quot;&gt;Mock, Stub, Spy, Fake가 뭔지에 대해 Swift 코드 예제로 설명해주는 글&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CS
    &lt;ul&gt;
      &lt;li&gt;읽어본 글 : &lt;a href=&quot;https://kingofbackend.tistory.com/119?fbclid=IwAR3LZY-KEbPyL_IqWy7s1rGGf01Bkd7h2jF5RyQiPJmLH06vF8eaGKidlZg&quot;&gt;프로세스와 스레드의 차이에 대해 설명해놓은 글&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;은행창구 프로젝트
    &lt;ul&gt;
      &lt;li&gt;protocol을 사용하여 책임을 분리하는 작업 진행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 04 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.05.04-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.05.04-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>2021년 05월 03일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ARC와 Memory Structure&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;ARC는 자동으로 Reference count를 관리하는 기능&lt;/li&gt;
      &lt;li&gt;Memory Structure에는 Code, Data, Stack, Heap 영역이 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Retain Cycle과 Dead Lock&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Retain Cycle의 예시를 볼 수 있는 App (godrm님의 프로젝트) &lt;a href=&quot;https://github.com/godrm/RetainCycleApp&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;ARC 공식문서의 Strong retain cycle에 대해&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;참조타입이랑 값타입이랑 뭐가 다르지?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;retain count는 누가 관리해주지?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;retain count를 관리해주는 애들은 모두 heap에 간다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;값타입이 선호되는 이유 (성능에 왜 유리할까)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;catch문에 error를 변수로 선언해서 쓰는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://nshipster.com/swift-foundation-error-protocols/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;extension 에다가만 protocol 채택해서 쓰는것 그냥 처음부터 채택하는거랑 뭐가 다르지?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;이미 구현되어있는 애에다가 프로토콜을 주입할 수 있음 (의존성 주입)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이게 왜 되는거지?&lt;/p&gt;

    &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;mutating&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;closeBank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;totalCustomerNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;closeTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CFAbsoluteTimeGetCurrent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;spentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSpentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
          
        &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;numberOfCustomers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalCustomerNumber&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BankManagerError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failToGetTotalCustomerNumber&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
          
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;업무가 마감되었습니다. 오늘 업무를 처리한 고객은 총 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numberOfCustomers&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;명이며, 총 업무시간은 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spentTime&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;초입니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSpentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;openTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;close&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;closeTime&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BankManagerError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failToCaclulateSpentTime&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
          
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;spentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;formatTimeDuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spentTime&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;왜 try에 do - catch가 없는데도 정상 동작할까? -&amp;gt; Error Description을 자동으로 String으로 바꿔주는건가? 흠…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;setUp, tearDown을 쓰는 이유&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;메모리를 위해서&lt;/li&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;병렬성은 같은 작업을 여러개의 CPU가 동시에 하는 것&lt;/p&gt;

&lt;p&gt;우리가 하는 것은 여러개의 ‘다른’ 작업이기 때문에 동시성 프로그래밍이다 (병렬성 아님)&lt;/p&gt;

&lt;p&gt;코어가 여러개 일때만 병렬 프로그래밍이 가능하다.&lt;/p&gt;
</description>
        <pubDate>Mon, 03 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.05.03-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.05.03-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>Typora 이미지 쉽게 업로드 하기 for mac</title>
        <description>&lt;h2 id=&quot;사건의-발단&quot;&gt;사건의 발단&lt;/h2&gt;

&lt;p&gt;Typora를 통해 깃허브 블로그 글을 쓰다보면 이미지 첨부하는 작업이 매우 귀찮다고 느끼시는 분들이 많으실 것 같아요. 이미지의 상대경로를 지정해주고 깃헙 블로그 레포의 어떤 폴더에 캡쳐한 스크린샷을 담는 과정은 상당히 귀찮은 작업이죠..&lt;/p&gt;

&lt;p&gt;이러한 문제를 해결할 수 있는 방안(이미지를 링크로 변환하여 업로드)을 오늘 알려드리겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;내가-찍은-스크린샷이-weibo에-익명으로-올라가는-것을-참을-수-있어&quot;&gt;내가 찍은 스크린샷이 weibo에 익명으로 올라가는 것을 참을 수 있어!&lt;/h4&gt;

&lt;p&gt;하시는 분들은 밑의 내용을 읽으실 필요 없이&lt;/p&gt;

&lt;p&gt;Typora의 이미지 설정 부분에 가셔서 Image Uploader을 upic으로 설정해주신 뒤&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;brew install upic&lt;/code&gt; 커맨드를 통해 upic을 다운받아주시기만 하면 간단하게 해결할 수 있습니다&lt;/p&gt;

&lt;h2 id=&quot;그래서-어떻게-하면-되는데&quot;&gt;그래서 어떻게 하면 되는데?&lt;/h2&gt;

&lt;h3 id=&quot;1-typora의-언어-중국어로-변경하기&quot;&gt;1. Typora의 언어 중국어로 변경하기&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502223128.png&quot; alt=&quot;image-20210502223124947&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502223414.png&quot; alt=&quot;image-20210502223410704&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우선 Typora의 언어를 중국어로 바꾸는 것부터 시작합니다&lt;/p&gt;

&lt;p&gt;???:   🧐 웬 뜬금없이 중국어?&lt;/p&gt;

&lt;p&gt;하시는 분들이 많으실텐데 이번 포스트의 핵심이 될 Picgo가 중국어만을 지원하기 때문에 진행해야하는 작업입니다!&lt;/p&gt;

&lt;p&gt;과정이 끝난 뒤에는 다시 한국어로 설정해도 전혀 문제가 없으니 걱정하지 마세요! 😆&lt;/p&gt;

&lt;p&gt;중국어로 설정해주신 뒤 command + q를 이용해 typora를 완전 종료해줬다가 다시 켜주세요.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-picgoapp-다운로드-하기&quot;&gt;2. PicGo.app 다운로드 하기&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502223553.png&quot; alt=&quot;image-20210502223551901&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;중국어로 바꿔주셨다면 이미지 업로더의 종류에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PicGo.app&lt;/code&gt;이 추가된 것을 보실 수 있으실거에요&lt;/p&gt;

&lt;p&gt;PicGo.app은 중국어만 지원하는 앱이기 때문에 언어를 중국어로 설정했을 경우에만 노출되도록 Typora가 지정해놨습니다.&lt;/p&gt;

&lt;p&gt;이제 PicGo.app 다운로드하기 버튼을 누르셔서 (아래 하 + 어려운 한자 버튼이 다운로드 버튼입니다.)&lt;/p&gt;

&lt;p&gt;다운로드를 진행해주세요 (꼭 저 버튼을 통해 하실 필요는 없고 PicGo 깃헙으로 가셔서 dmg 파일을 받으셔도 됩니다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-github에-이미지가-저장될-repository-만들기-토큰-받아오기&quot;&gt;3. Github에 이미지가 저장될 Repository 만들기, 토큰 받아오기&lt;/h3&gt;

&lt;p&gt;이 부분의 스크린샷은 생략하도록 하겠습니다!&lt;/p&gt;

&lt;p&gt;Repo를 만들어 주시고 토큰을 받아와주세요&lt;/p&gt;

&lt;p&gt;토큰을 받아오는 과정은 &lt;a href=&quot;https://taeuk-gang.github.io/wiki/Typora%20%EC%8B%A0%EA%B8%B0%EB%8A%A5%20-%20%EC%9D%B4%EB%AF%B8%EC%A7%80%20%EC%9E%90%EB%8F%99%20%EC%97%85%EB%A1%9C%EB%93%9C/&quot;&gt;이 블로그 글&lt;/a&gt;에 잘 설명되어있으니 참고하시면 좋을 것 같습니다!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-picgoapp-설정하기&quot;&gt;4. PicGo.app 설정하기&lt;/h3&gt;

&lt;p&gt;이제부터는 제가 보여드리는 스크린샷을 그대로 따라해주시면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502223852.png&quot; alt=&quot;image-20210502223850730&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Custom에 불이 들어오도록 버튼을 눌러주세요!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210503101050.png&quot; alt=&quot;image-20210503101048818&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;톱니바퀴 모양 cell을 눌러서 이 화면에 들어와 주신 뒤&lt;/p&gt;

&lt;p&gt;제 설정대로 stepper을 On/Off 해주세요&lt;/p&gt;

&lt;p&gt;다만! 위에서 4번째에 있는 stepper을 On 해주면 이미지를 업로드 할때 매번 업로드될 이름을 정해줄 수 있어요!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210502225855.png&quot; alt=&quot;20210502225608&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;왼쪽 ScrollView에 있는 GitHub뭐시기 버튼을 눌러 이 화면에 와주신 뒤 TextField를 채워주시면 됩니다!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;첫 칸에는 본인의 깃허브 닉네임/레포이름 을 적어주세요!&lt;/p&gt;

&lt;p&gt;두번째 칸에는 저장할 레포의 어떤 브랜치에 이미지를 업로드할지 설정해주는 작업인데, 여기서 master branch가 아닌 다른 브랜치로 설정해주셔야 무분별한 commit들이 쌓이지 않습니다!&lt;/p&gt;

&lt;p&gt;사용하기로 한 깃헙 레포에 추가적인 브랜치를 만들어주세요! 저의 경우에는 master branch가 아닌 forUpload라는 이름의 브랜치에 이미지가 업로드 되도록 한 상황입니다!&lt;/p&gt;

&lt;p&gt;세번째 칸에는 아까 받아온 토큰을 넣어주시면 됩니다.&lt;/p&gt;

&lt;p&gt;네번째 칸에는 이미지의 경로를 적어주시면 되는데 repo내의 폴더라고 보시면 될 것 같아요&lt;/p&gt;

&lt;p&gt;(제가 설정한 것은 Neph3779라는 유저의 Blog-Image라는 레포의 img 폴더에 내가 찍은 스크린샷을 저장해! 가 되겠네요)&lt;/p&gt;

&lt;p&gt;이 작업이 끝나셨다면 밑의 파란색 버튼과 초록색 버튼을 눌러주시면 됩니다 (초록 버튼은 눌러지지 않을 수 있는데 문제 없어요!)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그럼 이제 드디어 타이포라에 와서 이미지를 업로드 해볼까요?&lt;/p&gt;

&lt;p&gt;(타이포라의 언어 설정은 한국어로 다시 바꿔주셔도 됩니다!)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5-typora를-통해-이미지-업로드-하기&quot;&gt;5. Typora를 통해 이미지 업로드 하기&lt;/h3&gt;

&lt;p&gt;찍은 스크린샷을 단순히 command + v로 타이포라에 붙여넣기 하면 아래의 사진처럼 내 맥북에 저장된 경로를 통해 이미지가 업로드 됩니다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502224745.png&quot; alt=&quot;image-20210502224715666&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 상태에서 사진을 우클릭 하신 뒤 Upload Image라는 버튼을 누르시면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210502225842.png&quot; alt=&quot;image-20210502224818354&quot; /&gt;&lt;/p&gt;

&lt;p&gt;짜잔 보이는것처럼 나의 깃헙 레포와 연동된 링크를 통해 이미지가 들어가는 것을 볼 수 있어요!&lt;/p&gt;

&lt;p&gt;개인적으로 이 작업을 해놓고 나니 사진을 업로드 하는게 너무나도 편해졌어요!&lt;/p&gt;

&lt;p&gt;게다가 upic은 weibo에 나의 소중한 스크린샷들이 익명으로 올라가는게 마음에 걸렸었는데&lt;/p&gt;

&lt;p&gt;이 방법을 쓰면 내 깃허브 레포에만 저장되고 이미지가 유출되지 않으니 좋은 것 같습니다&lt;/p&gt;

&lt;p&gt;Mac 사용자를 위한 튜토리얼이 없길래 글을 써봤는데 도움이 되셨으면 좋겠어요!&lt;/p&gt;
</description>
        <pubDate>Sun, 02 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9D%BC%EC%83%81/TyporaEasyImageUpload/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9D%BC%EC%83%81/TyporaEasyImageUpload/</guid>
        
        <category>Typora</category>
        
        <category>Picgo</category>
        
        
        <category>일상</category>
        
      </item>
    
  </channel>
</rss>
