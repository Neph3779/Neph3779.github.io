<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Neph's Blog</title>
    <description>Write code with my soul.</description>
    <link>https://neph3779.github.io/</link>
    <atom:link href="https://neph3779.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 09 Apr 2021 00:39:01 +0900</pubDate>
    <lastBuildDate>Fri, 09 Apr 2021 00:39:01 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>2021년 04월 06일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;json-파일을-디코딩하는-방법에-대해-공부했습니다&quot;&gt;JSON 파일을 디코딩하는 방법에 대해 공부했습니다.&lt;/h3&gt;

&lt;p&gt;JSON 파일이 어떻게 구성되어있는지 파악한 뒤  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Decodable&lt;/code&gt;프로토콜을 채용한 타입을 JSON 파일 구성에 맞게 제작하는 방식으로 디코딩이 이루어지는 것을 알게되었습니다. Swift는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;camleCasing&lt;/code&gt;을 지향하지만 JSON 파일은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;snakeCasing&lt;/code&gt;으로 작성된 경우가 많습니다. 이를 해결하기 위해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CodingKey&lt;/code&gt;라는 프로토콜을 채택하여 원하는 꼴로 모양을 맞춰줄 수 있었습니다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Decodable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;imageName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;shortDescription&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CodingKeys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CodingKey&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imageName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;image_name&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shortDescription&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;short_desc&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;description&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;desc&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;고민중인-부분&quot;&gt;고민중인 부분&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;JSON 파일을 프로그래머가 일일이 분석해서 타입을 만들어야되는 것일까? 에 대한 의문이 있습니다.&lt;/li&gt;
  &lt;li&gt;Asset 폴더를 통채로 넣었을 때 파일 경로를 통한 탐색이 진행되어야 할 줄 알았는데 Xcode가 자동으로 이미지와 json파일을 분류해줬습니다. 이것이 이미지 파일명 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;folds~universal@1x.png&lt;/code&gt;)를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;idiom&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scale&lt;/code&gt;을 자동으로 분류해주는 것으로 추측되지만 자세한건 내일 더 알아보기로 했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;error-핸들링에-대해-더-알아보았습니다&quot;&gt;Error 핸들링에 대해 더 알아보았습니다.&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://rhino-developer.tistory.com/entry/Swift-ErrorHandling&quot;&gt;라이노님의 글&lt;/a&gt;과 &lt;a href=&quot;https://wlaxhrl.tistory.com/53&quot;&gt;찜토끼님의 글&lt;/a&gt;을 통해 error case에 associated value를 줄 수 있는 방법에 대해 알게되었고 이에 대해 공부하고 있습니다. 이번 만국박람회 프로젝트에서 사용해보기로 했습니다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JsonDecodingError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dataCorrupted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;keyNotFound&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;valueNotFound&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Tue, 06 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.06-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.06-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>[작성중] [#6] CPU 스케쥴링 - 1</title>
        <description>&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;
&lt;ol id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#목차&quot; id=&quot;markdown-toc-목차&quot;&gt;목차&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cpu-스케쥴링&quot; id=&quot;markdown-toc-cpu-스케쥴링&quot;&gt;CPU 스케쥴링&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#add-load-store-명령&quot; id=&quot;markdown-toc-add-load-store-명령&quot;&gt;Add, Load, Store 명령&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cpu-버스트와-io-버스트&quot; id=&quot;markdown-toc-cpu-버스트와-io-버스트&quot;&gt;CPU 버스트와 I/O 버스트&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cpu-스케쥴링의-필요성&quot; id=&quot;markdown-toc-cpu-스케쥴링의-필요성&quot;&gt;CPU 스케쥴링의 필요성&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cpu-스케쥴러&quot; id=&quot;markdown-toc-cpu-스케쥴러&quot;&gt;CPU 스케쥴러&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#cpu-스케쥴러의-동작과정&quot; id=&quot;markdown-toc-cpu-스케쥴러의-동작과정&quot;&gt;CPU 스케쥴러의 동작과정&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#cpu-스케쥴링이-필요한-몇-가지-경우들&quot; id=&quot;markdown-toc-cpu-스케쥴링이-필요한-몇-가지-경우들&quot;&gt;CPU 스케쥴링이 필요한 몇 가지 경우들&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#선점형-방식과-비선점형-방식&quot; id=&quot;markdown-toc-선점형-방식과-비선점형-방식&quot;&gt;선점형 방식과 비선점형 방식&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#디스패처&quot; id=&quot;markdown-toc-디스패처&quot;&gt;디스패처&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#cpu의-이양-작업&quot; id=&quot;markdown-toc-cpu의-이양-작업&quot;&gt;CPU의 이양 작업&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#디스패처-1&quot; id=&quot;markdown-toc-디스패처-1&quot;&gt;디스패처&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;cpu-스케쥴링&quot;&gt;CPU 스케쥴링&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;add-load-store-명령&quot;&gt;Add, Load, Store 명령&lt;/h3&gt;

&lt;p&gt;CPU 명령에는 덧셈을 진행하는 Add, 메모리 접근을 수행하는 Load, Store 명령이 있다. Load, Store 명령어는 Add 명령에 비해서는 느리지만 비교적 짧은 시간이 드는 명령이며, Add 명령과 마찬가지로 사용자 프로그램이 직접 실행할 수 있는 일반명령에 해당한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cpu-버스트와-io-버스트&quot;&gt;CPU 버스트와 I/O 버스트&lt;/h3&gt;

&lt;p&gt;사용자 프로그램은 CPU 작업(CPU busrt)과 I/O 작업(I/O burst)의 반복으로 구성된다. 이는 CPU와 I/O라는 서로 다른 자원을 번갈아 사용하며 프로그램이 수행되는 것으로 볼 수 있다. 대부분의 프로세스는 다수의 짧은 CPU 버스트와 소수의 긴 CPU 버스트로 구성된다. 이렇게 짧은 CPU 버스트가 대부분인 프로세스를 I/O 바운드 프로세스라 하며, 이에 반대되는 프로세스를 CPU 바운드 프로세스라 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cpu-스케쥴링의-필요성&quot;&gt;CPU 스케쥴링의 필요성&lt;/h3&gt;

&lt;p&gt;각 프로그램마다 CPU 버스트와 I/O 버스트가 차지하는 비율이 다르기 때문에 CPU 스케쥴링 작업이 필요하다.  CPU 버스트가 짧은 프로세스는 대부분 대화형 작업(interactive job)으로 사용자와 인터랙션을 해야하기 때문에 CPU의 빠른 서비스를 필요로 하며 이에 CPU 스케쥴러는 I/O 바운드 프로세스가 우선적으로 CPU를 사용할 수 있도록 해준다. 이 작업은 대화형 프로세스에게 빠른 응답성을 제공해줌과 도시에 I/O 장치의 효율성도 높이는데 I/O 바운드 프로세스는 CPU를 잠깐만 사용한 뒤 다시 I/O 작업을 수행하기 때문이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cpu-스케쥴러&quot;&gt;CPU 스케쥴러&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;cpu-스케쥴러의-동작과정&quot;&gt;CPU 스케쥴러의 동작과정&lt;/h3&gt;

&lt;p&gt;CPU 스케쥴러는 준비 상태에 있는 프로세스들 중 어떤한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드이다. 프로세스 실행 중 타이머 인터럽트가 발생하면 CPU 스케쥴러가 호출된다. 그럼 이 때 CPU 스케쥴러는 준비 큐에서 프로세스를 하나 선택해 CPU를 할당하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cpu-스케쥴링이-필요한-몇-가지-경우들&quot;&gt;CPU 스케쥴링이 필요한 몇 가지 경우들&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;실행 상태에 있던 프로세스가 I/O 요청 등에 의해 봉쇄 상태로 바뀌는 경우&lt;/li&gt;
  &lt;li&gt;실행 상태에 있던 프로세스가 타이머 인터럽트 발생에 의해 준비 상태로 바뀌는 경우&lt;/li&gt;
  &lt;li&gt;I/O 요청으로 봉쇄 상태에 있던 프로세스가 I/O 작업이 완료되어 인터럽트가 발생하고 그 결과 이 프로세스의 상태가 준비 상태로 바뀌는 경우&lt;/li&gt;
  &lt;li&gt;CPU에서 실행 상태에 있는 프로세스가 종료되는 경우&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;선점형-방식과-비선점형-방식&quot;&gt;선점형 방식과 비선점형 방식&lt;/h3&gt;

&lt;p&gt;CPU 스케쥴링 방식에는 선점형 방식과 비선점형 방식이 있는데 비선점형 방식은 CPU를 획득한 프로세스가 스스로 반납하기 전까지 CPU를 빼앗지 않지만 선점형 방식은 CPU를 강제로 빼앗을 수 있다. 위의 스케쥴링이 필요한 몇 가지 경우 중 1번과 4번은 비선점형 스케쥴링의 예이며, 2번과 3번은 선점형 스케쥴링 방식의 예에 해당한다. 3번은 이번에 I/O 작업이 완료된 프로세스가 인터럽트 당한 프로세스보다 우선순위가 높아서 곧바로 CPU를 획득하는 경우이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;디스패처&quot;&gt;디스패처&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;cpu의-이양-작업&quot;&gt;CPU의 이양 작업&lt;/h3&gt;

&lt;p&gt;어떤 프로세스에게 CPU를 할당할지가 결정되고 나면 선택된 프로세스에게 CPU를 이양하는 작업이 필요하다. 이런 작업을 해주는 운영체제의 코드를 디스패처(dispatcher)라고 부른다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;디스패처-1&quot;&gt;디스패처&lt;/h3&gt;

&lt;p&gt;디스패처는 현재 수행 중이던 프로세스의 문맥을 그 프로세스의 PCB에 저장하고 이번에 CPU를 할당할 프로세스의 PCB로부터 문맥을 복원한 뒤 CPU를 넘겨준다. 프로세스 문맥 복원 뒤에 시스템의 상태를 사용자모드로 전환해 사용자 프로그램에게 CPU 제어권을 넘기게 된다. 디스패처가 하나의 프로세스를 정지시키고 다음 프로세스에게 CPU를 넘기는 과정에서 걸리는 시간을 디스패치 지연시간(dispatch latency)라고 하며 대부분 문맥교환 오버헤드가 디스패치 지연시간을 이루고 있다.&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Mon, 05 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/6-CPU-%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%B2%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC-1/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/6-CPU-%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%B2%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC-1/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>[#5] 프로세스 관리 - 2</title>
        <description>&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;
&lt;ol id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#목차&quot; id=&quot;markdown-toc-목차&quot;&gt;목차&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#프로세스의-생성&quot; id=&quot;markdown-toc-프로세스의-생성&quot;&gt;프로세스의 생성&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#부모-프로세스와-자식-프로세스&quot; id=&quot;markdown-toc-부모-프로세스와-자식-프로세스&quot;&gt;부모 프로세스와 자식 프로세스&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#자원의-획득과-프로세스의-수행모델&quot; id=&quot;markdown-toc-자원의-획득과-프로세스의-수행모델&quot;&gt;자원의 획득과 프로세스의 수행모델&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#주소-공간&quot; id=&quot;markdown-toc-주소-공간&quot;&gt;주소 공간&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#프로세스의-생성-절차&quot; id=&quot;markdown-toc-프로세스의-생성-절차&quot;&gt;프로세스의 생성 절차&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#프로세스의-종료-절차&quot; id=&quot;markdown-toc-프로세스의-종료-절차&quot;&gt;프로세스의 종료 절차&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#프로세스의-강제-종료가-이루어지는-경우&quot; id=&quot;markdown-toc-프로세스의-강제-종료가-이루어지는-경우&quot;&gt;프로세스의 강제 종료가 이루어지는 경우&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#자식-프로세스를-생성하는-과정&quot; id=&quot;markdown-toc-자식-프로세스를-생성하는-과정&quot;&gt;자식 프로세스를 생성하는 과정&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#프로세스-간의-협력&quot; id=&quot;markdown-toc-프로세스-간의-협력&quot;&gt;프로세스 간의 협력&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#독립적-프로세스&quot; id=&quot;markdown-toc-독립적-프로세스&quot;&gt;독립적 프로세스&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#협력-프로세스와-협력-메커니즘&quot; id=&quot;markdown-toc-협력-프로세스와-협력-메커니즘&quot;&gt;협력 프로세스와 협력 메커니즘&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ipc--메시지-전달-방식&quot; id=&quot;markdown-toc-ipc--메시지-전달-방식&quot;&gt;IPC :: 메시지 전달 방식&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#메시지-전달-방식&quot; id=&quot;markdown-toc-메시지-전달-방식&quot;&gt;메시지 전달 방식&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#직접통신과-간접통신&quot; id=&quot;markdown-toc-직접통신과-간접통신&quot;&gt;직접통신과 간접통신&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ipc--공유메모리-방식&quot; id=&quot;markdown-toc-ipc--공유메모리-방식&quot;&gt;IPC :: 공유메모리 방식&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#주소공간의-공유&quot; id=&quot;markdown-toc-주소공간의-공유&quot;&gt;주소공간의 공유&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#일관성-문제&quot; id=&quot;markdown-toc-일관성-문제&quot;&gt;일관성 문제&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;프로세스의-생성&quot;&gt;프로세스의 생성&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;부모-프로세스와-자식-프로세스&quot;&gt;부모 프로세스와 자식 프로세스&lt;/h3&gt;

&lt;p&gt;시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만 그다음부터는 이미 존재하던 프로세스가 다른 프로세스를 복제 생성한다. 프로세스는 항상 자식 프로세스가 먼저 종료되고나서 부모 프로세스가 종료된다. 후손이 여러개인 (자식의 자식으로 이어지는 계층도가 긴) 프로세스의 경우에는 연쇄적으로 모든 후손 프로세스들을 종료시킨 뒤에 종료된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;자원의-획득과-프로세스의-수행모델&quot;&gt;자원의 획득과 프로세스의 수행모델&lt;/h3&gt;

&lt;p&gt;생성된 프로세스가 작업을 수행하기 위해서는 자원이 필요하다. 운영체제로부터 &lt;strong&gt;직접 자원을 할당받는 경우&lt;/strong&gt;도 있고 &lt;strong&gt;부모 프로세스와 자식 프로세스가 자원을 공유하는 경우&lt;/strong&gt;(일부만 공유하는 경우, 전부를 공유하는 경우로 나뉨)도 있다. 프로세스가 수행되는 모델도 &lt;strong&gt;부모와 자식이 공존하며 수행되는 모델&lt;/strong&gt;이 있고, &lt;strong&gt;부모가 자식이 종료될때까지 기다리는 모델&lt;/strong&gt;도 있다. 전자의 경우에는 CPU 획득을 위해 서로 경쟁하는 관계가 된다. 반면 후자의 경우에는 자식 프로세스가 종료되기 전까지 부모 프로세스는 봉쇄 상태에 머물러 있다가 자식 프로세스가 종료되면 준비 상태가 되어 CPU를 얻을 권한이 생기게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;주소-공간&quot;&gt;주소 공간&lt;/h3&gt;

&lt;p&gt;프로세스가 생성되면 독자적인 주소 공간을 갖게 된다. 부모 프로세스와 자식 프로세스는 별도의 주소 공간을 가지게 되는데 자식 프로세스는 부모 프로세스의 주소 공간 내용을 그대로 복사하여 생성된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스의-생성-절차&quot;&gt;프로세스의 생성 절차&lt;/h3&gt;

&lt;p&gt;유닉스에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt; 시스템 콜을 통해 새로운 프로세스를 생성할 수 있는데 프로세스 ID를 제외한 모든 정보 즉, 운영체제 커널 내의 정보(PCB, 자원 등)와 주소 공간의 정보를 그대로 복사한다. 복제가 완료되면 그 위에 새로운 프로그램을 덮어씌울 수도 있는데 이 작업은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec()&lt;/code&gt; 시스템 콜을 통해 이루어진다. (exec 작업은 필수가 아님)&lt;/p&gt;

&lt;p&gt;자식 프로세스가 부모 프로세스와 달라지지 않는다면 굳이 복사를 진행할 필요가 없다. 따라서 자식 프로세스에서 변경이 진행될 때 복사를 진행하는 방식을 Copy-On-Write(a.k.a. COW)라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스의-종료-절차&quot;&gt;프로세스의 종료 절차&lt;/h3&gt;

&lt;p&gt;프로세스의 종료는 크게 자발적 종료와 비자발적 종료로 구분된다. 자발적 종료가 이루어지는 경우, 프로세스는 명령을 모두 수행한 후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit()&lt;/code&gt;이라는 시스템 콜을 진행한다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit()&lt;/code&gt;은 프로그래머가 명시적으로 호출하지 않아도 프로그램 종료 지점에 컴파일러가 자동으로 삽입). 운영체제에게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit()&lt;/code&gt;을 통해 자신이 종료될 수 있음을 알리면 운영체제는 자원을 회수하고 시스템 내에서 프로세스를 정리한다. 반면 비자발적 종료의 경우에는 부모 프로세스가 자식 프로세스의 수행을 강제로 종료하는데 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abort()&lt;/code&gt;라는 함수를 통해 이루어진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스의-강제-종료가-이루어지는-경우&quot;&gt;프로세스의 강제 종료가 이루어지는 경우&lt;/h3&gt;

&lt;p&gt;프로세스가 강제 종료되는 경우는 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;자식 프로세스가 한계치를 넘는 자원을 요구할 때&lt;/li&gt;
  &lt;li&gt;자식 프로세스에게 할당된 작업이 더 이상 필요하지 않을 때&lt;/li&gt;
  &lt;li&gt;부모 프로세스가 종료되는 경우&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위와 다르게 부모 프로세스가 종료된 이후에도 실행되어야 할 프로세스가 있다면 해당 프로세스를 다른 프로세스의 자식으로 이양하는 작업이 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;자식-프로세스를-생성하는-과정&quot;&gt;자식 프로세스를 생성하는 과정&lt;/h3&gt;

&lt;p&gt;운영체제는 자식 프로세스의 생성을 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt; 시스템 콜을 제공한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt; 시스템 콜을 하게 되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt; 함수를 호출한 프로세스와 똑같은 프로세스가 생성된다. 이렇게 생성된 자식 프로세스는 부모 프로세스의 모든 문맥을 동일하게 가지고 있으며 부모 프로세스의 주소 공간을 비롯해 프로그램 카운터 등 레지스터 상태, PCB 및 커널 스택 등 모든 문맥을 그대로 복제해 자식 프로세스의 문맥을 형성한다. 즉, 자식 프로세스는 부모 프로세스의 처음부터 수행하는 것이 아니라 현재 수행한 시점(PC 지점)부터 수행하게 된다. 이 둘을 구분하기 위해 부모 프로세스 식별자(pid)는 양수이며 자식 프로세스의 식별자는 0이라는 차이가 존재한다.&lt;/p&gt;

&lt;p&gt;자식 프로세스가 부모와 다른 독자적 프로그램을 수행하도록 만들기 위해선 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec()&lt;/code&gt; 시스템 콜이 필요하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec()&lt;/code&gt; 시스템 콜은 지금까지 수행했던 상태를 잊어버리고 그 주소 공간을 완전히 새로운 프로그램으로 덮어씌운 후 처음부터 시작하도록 만들어준다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec()&lt;/code&gt; 이전 시점까지 프로그램을 실행하다 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec()&lt;/code&gt;을 만나면 새로운 프로그램으로 넘어가서 그 프로그램을 실행하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt; 시스템 콜을 통해 부모 프로세스와 자식 프로세스 간의 동기화가 가능하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt; 시스템 콜이 이루어지면 부모 프로세스는 자식 프로세스가 종료될 때까지 봉쇄상태에 들어가는데 일반적인 봉쇄 상태에서와는 다르게 자원을 기다리며 줄 서 있지 않고 자식 프로세스가 종료될 때까지 수면 상태에 머무른다. 자식 프로세스가 종료되는 순간 준비 큐에 재진입하여 CPU를 얻을 권한을 획득한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로세스-간의-협력&quot;&gt;프로세스 간의 협력&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;독립적-프로세스&quot;&gt;독립적 프로세스&lt;/h3&gt;

&lt;p&gt;프로세스는 자신만의 주소 공간을 가지고 수행되며 다른 프로세스의 주소공간을 참조하는 것은 허용되지 않는다. 프로세스 복제 과정에서 부모 프로세스의 주소 공간을 자식 프로세스가 복제하지만 생성 이후에는 독자적인 주소 공간만을 참조해 코드를 수행하므로 독립적인 관계가 된다.&lt;/p&gt;

&lt;h3 id=&quot;협력-프로세스와-협력-메커니즘&quot;&gt;협력 프로세스와 협력 메커니즘&lt;/h3&gt;

&lt;p&gt;경우에 따라서는 프로세스들이 협력할 때 업무의 효율성이 증진될 수 있다. 이런 프로세스 간 협력 메커니즘은 대표적으로 운영체제가 제공하는 IPC(Inter-Process Communication)가 있다. IPC는 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간의 통신을 의미하며 이러한 통신은 의사소통 기능과 동기화를 보장한다. 공유 데이터를 서로 다른 두 프로세스가 사용할 때 데이터 불일치의 문제를 예방하기 위해 하나의 프로세스가 공유 데이터의 값을 변경하는 동안 다른 프로세스는 그 데이터에 접근할 수 없도록 해야한다. IPC의 대표적인 방법으로는 메시지 전달 방식과 공유메모리 방식이 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ipc--메시지-전달-방식&quot;&gt;IPC :: 메시지 전달 방식&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;메시지-전달-방식&quot;&gt;메시지 전달 방식&lt;/h3&gt;

&lt;p&gt;메시지 전달 방식은 공유 데이터를 사용하지 않고 커널이 메시지를 간접적으로 전달하는 방식이다. 메시지 통신을 하는 시스템은 커널에 의해 send(message)와 receive(message)를 제공받는데 이 두 연산을 통해 시스템 콜 방식으로 정보를 주고받는다.&lt;/p&gt;

&lt;p&gt;통신이 필요한 두 프로세스는 커뮤니케이션 링크를 생성한 후 send()와 receive()를 통해 메시지를 주고받는다. 커뮤니케이션 링크는 물리적으로 구현될수도 있고 논리적으로 구현될수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;직접통신과-간접통신&quot;&gt;직접통신과 간접통신&lt;/h3&gt;

&lt;p&gt;메시지 전달을 통해 통신하는 방식에는 직접통신(direct communication)과 간접통신(indirect communication)이 있다. 이 둘의 차이는 연산의 인터페이스의 차이일 뿐 실제 메시지 전송이 이루어지는 내부 구현은 커널의 중재에 의해 사실상 동일하게 이루어진다.&lt;/p&gt;

&lt;p&gt;직접통신에서는 통신하려는 프로세스의 이름을 명시적으로 표시한다. 커뮤니케이션 링크는 자동적으로 생성되고, 하나의 링크는 오직 한 쌍의 프로세스에게만 할당된다. 또한 각 쌍의 프로세스에는 오직 하나의 링크만이 존재하고 링크는 단방향성인 경우와 양방향성인 경우가 있지만 대부분 양방향성이다.&lt;/p&gt;

&lt;p&gt;간접통신에는 메시지를 메일박스(mail box) 또는 포트(port)로부터 전달받는다. 각 메일박스에는 고유의 ID가 있으며 메일박스를 공유하는 프로세스들만 서로 통신할 수 있다. 간접통신의 경우 커뮤니케이션 링크는 프로세스 간에 메일 박스를 공유하는 경우에만 생성되는데 하나의 링크가 여러 프로세스들에게 할당될 수 있으며 각 프로세스의 쌍은 여러 링크를 공유할 수 있다. 링크는 단방향성과 양방향성 모두 존재하며 send/receive연산, 메일박스 삭제 연산 등이 지원된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ipc--공유메모리-방식&quot;&gt;IPC :: 공유메모리 방식&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;주소공간의-공유&quot;&gt;주소공간의 공유&lt;/h3&gt;

&lt;p&gt;공유메모리 방식에서는 프로세스들이 주소 공간의 일부를 공유한다. 원칙적으로는 각자 독립적인 주소 공간을 가지지만 운영체제가 시스템 콜을 통해 프로세스들이 주소 공간 중 일부를 공유할 수 있도록 해준다. 실제 구현은 두 프로세스가 서로 독자적인 주소 공간을 가지고 있지만 이 주소 공간이 물리적 메모리에 매핑될 때 공유메모리 주소 영역에 대해서는 동일한 물리적 메모리 주소로 매핑된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;일관성-문제&quot;&gt;일관성 문제&lt;/h3&gt;

&lt;p&gt;공유메모리 방식은 프로세스간의 통신을 수월하게 해주지만 서로의 데이터에 일관성 문제가 발생할 수 있다. 이에 대해서는 커널이 책임을 지지 않으므로 프로세스들끼리 직접 공유메모리 접근에 대한 동기화 문제를 해결해야한다.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/5-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3-%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5-2/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/5-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3-%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5-2/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>2021년 04월 05일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;운영체제-5번째-6번째-정리본-업로드-및-스터디-참여&quot;&gt;운영체제 5번째, 6번째 정리본 업로드 및 스터디 참여&lt;/h3&gt;

&lt;p&gt;어느덧 벌써 4번째 스터디가 진행되었습니다. 이번 스터디에서는 5장 프로세스 관리의 후반부와 6장인 CPU 스케쥴링의 전반부를 공부했습니다. 자세한 정리는 아래의 링크들을 참고해주시면 감사하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/5-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC-2/&quot;&gt;5번째 정리글&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/6-CPU-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-1/&quot;&gt;6번째 정리글&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/i-study-OS/BHK/tree/main/OS4&quot;&gt;스터디 repo 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;table-view와-json에-대해-알아보았습니다&quot;&gt;Table View와 JSON에 대해 알아보았습니다&lt;/h3&gt;

&lt;p&gt;JSON 파일을 디코딩하는 방법과 디코딩한 데이터를 Table View의 Cell에 넣는 방법에 대해 공부하고 있습니다. 배운 내용은 추후에 정리해서 블로그에 업로드하겠습니다.&lt;/p&gt;

</description>
        <pubDate>Mon, 05 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.05-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.05-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>2021년 04월 02, 03일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;h3 id=&quot;클로저에-대해-공부했습니다&quot;&gt;클로저에 대해 공부했습니다.&lt;/h3&gt;

&lt;p&gt;계산기 로직을 짜다 함수 자체를 프로퍼티로 저장하면 어떨까 하는 생각이 들어서 공부했습니다.&lt;/p&gt;

&lt;p&gt;클로저 형태로 프로퍼티를 선언한 다음에 함수를 저장할 수 있다는 사실을 알게 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;계산기프로젝트-step3를-완성했습니다&quot;&gt;계산기 프로젝트 Step3를 완성했습니다.&lt;/h3&gt;

&lt;p&gt;계산기 프로젝트 Review에서 자세히 다뤄보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;계산기 로직 순서도&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;735&quot; alt=&quot;스크린샷 3&quot; src=&quot;https://user-images.githubusercontent.com/67148595/113417602-b43ffa00-93fe-11eb-8139-309a818467f5.png&quot; style=&quot;zoom: 67%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;동작화면&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/67148595/113417571-a2f6ed80-93fe-11eb-996e-55c1dda55fa9.gif&quot; alt=&quot;계산기 프로젝트 Step3&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 02 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.02-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.02-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>2021년 03월 30일, 31일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;h3 id=&quot;swift-lint를-적용해봤습니다&quot;&gt;Swift Lint를 적용해봤습니다&lt;/h3&gt;

&lt;p&gt;일관된 컨벤션을 유지하고 싶어서 Swift Lint를 적용시켜봤습니다. VScode에 있던 prettier라는 extension과 유사한 기능을 하지만 warning 혹은 error까지 띄워준다는 점에서 깔끔한 코드를 짜는데 도움이 될 것 같아 적용해봤습니다. 기본 설정에서 불필요하다 생각되는 규칙들은 disable 시켰습니다&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://neph3779.github.io/swift/Swift-Lint-%EC%A0%81%EC%9A%A9%EA%B8%B0/&quot;&gt;Swfit Lint 적용기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tdd에-대해-복습했습니다&quot;&gt;TDD에 대해 복습했습니다&lt;/h3&gt;

&lt;p&gt;지난 활동학습 시간에 다루었던 TDD에 대해 복습했습니다.&lt;/p&gt;

&lt;p&gt;이에 대한 &lt;a href=&quot;https://neph3779.github.io/swift/Swift-Unit-Test,-TDD/&quot;&gt;정리글&lt;/a&gt;을 작성중입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;customstringconvertible과-description의-활용에-대해-공부했습니다&quot;&gt;CustomStringConvertible과 description의 활용에 대해 공부했습니다&lt;/h3&gt;

&lt;p&gt;숫자야구게임 프로젝트를 진행하며 사용했던 CustomStringConvertible 프로토콜과 description을 활용하여 error 메세지를 더 간단하게 출력할 방법을 고민하고 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;숫자야구게임-프로젝트에서-작성했던-코드&quot;&gt;숫자야구게임 프로젝트에서 작성했던 코드&lt;/h4&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;GameResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CustomStringConvertible&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userTurn&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computerTurn&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;somebodyWin&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;userTurn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;사용자&quot;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;computerTurn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;컴퓨터&quot;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;공부하며-본-링크&quot;&gt;공부하며 본 링크&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://daheenallwhite.github.io/swift/2019/05/08/CustomStringConvertible/&quot;&gt;흰의 description 정리글&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;부동-소수점-연산의-부정확성과-그-원인에-대해-공부했습니다&quot;&gt;부동 소수점 연산의 부정확성과 그 원인에 대해 공부했습니다&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/TIL/WHY.png&quot; alt=&quot;WHY&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번 계산기 프로젝트를 진행하며 당연하게 여겼던 부분들이 당연하지 않아지고 있습니다 ㅎㅎ..&lt;/p&gt;

&lt;p&gt;부동 소수로 모든 실수를 표현할 수 없다는 것은 알고 있었지만 실제 결과값을 print 해보면 정상적으로 동작하는 것처럼 나왔기에 별 생각없이 연산을 했었는데 rounding 작업을 직접해줘야 한다는 사실을 알게되었습니다.&lt;/p&gt;

&lt;p&gt;제네릭을 활용하여 연산 메서드를 만드려면 각 연산의 조건을 만족해야하는데 이번 프로젝트에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BinaryFloatingPoint&lt;/code&gt;를 이용하였습니다.&lt;/p&gt;

&lt;h4 id=&quot;protocol-extension을-통한-기본-기능-구현과-generic을-활용한-함수-구현&quot;&gt;Protocol Extension을 통한 기본 기능 구현과 Generic을 활용한 함수 구현&lt;/h4&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Computable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BinaryFloatingPoint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;firstNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;secondNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subtract&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BinaryFloatingPoint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;firstNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;secondNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Computable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BinaryFloatingPoint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;firstNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;secondNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondNumber&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1e9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1e9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subtract&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BinaryFloatingPoint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;firstNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;secondNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondNumber&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;round&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1e9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1e9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Wed, 31 Mar 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.03.31-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.03.31-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>[작성중] Swift Unit Test &amp; TDD</title>
        <description>&lt;p&gt;이번 글에는 지난 3월 29일 활동학습 시간에 배운 Unit Test와 Result 자료형에 대해 정리해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;tdd가-뭘까&quot;&gt;TDD가 뭘까?&lt;/h2&gt;

&lt;p&gt;일반적인 개발 프로세스는 디자인, 코드 작성, 자체 테스트의 순서로 이루어져 왔습니다. 하지만 이러한 방식은 자체 버그 검출 능력이 저하되는 문제, 소스코드 품질 저하의 문제, 자체 테스트 비용 증가의 문제를 야기시킵니다. 프로젝트의 초기 설계는 완벽할 수 없기 때문에&lt;/p&gt;

&lt;p&gt;TDD는 Test Driven Development의 약자로 매우 짧은 개발 cycle을 반복하는 개발 프로세스입니다. TDD의 Cycle을 그림으로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/Swift/TDD.png&quot; alt=&quot;TDD&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;첫 단계인 RED 단계에서는 동작하지 않는 코드를 작성합니다. 이후 GREEN 단계에서는 RED 단계 때 작성한 코드를 동작이 가능하도록 먼저 수정합니다. 이 때 단순히 동작만 하도록 코드를 변경하면 필요없는 부분이 남아있을 수 있으므로 이를 REFACTOR 단계에서 다듬어줍니다. (REFACTOR는 코드의 로직 변경이 이루어지지 않습니다)&lt;/p&gt;

&lt;h2 id=&quot;테스트를-하면-무엇이-좋을까&quot;&gt;테스트를 하면 무엇이 좋을까?&lt;/h2&gt;

&lt;p&gt;TDD를 통해 개발을 하면 자연스럽게 큰 단위의 문제를 작은 단위로 나누게 됩니다.&lt;/p&gt;

&lt;p&gt;“빠르게 실패하여 얻은 정보(피드백)를 바탕으로 개선하는 것” 이 TDD의 지향점입니다.&lt;/p&gt;

&lt;h3 id=&quot;테스트는-훌륭한-스펙-정의-문서가-된다&quot;&gt;테스트는 훌륭한 스펙 정의 문서가 된다&lt;/h3&gt;

&lt;p&gt;테스트 케이스들을 통해 메서드가 어떤 한계점을 가지고 있는지에 대해 알 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;테스트를-하지-않으면-코드를-수정리팩토링하기-어렵고-두려워진다&quot;&gt;테스트를 하지 않으면 코드를 수정(리팩토링)하기 어렵고 두려워진다&lt;/h3&gt;

&lt;p&gt;Refactor: Improve the Design of Existing Code&lt;/p&gt;

&lt;h3 id=&quot;기능을-다-구현-해놓고-테스트를-마지막에-작성하면-안될까&quot;&gt;기능을 다 구현 해놓고 테스트를 마지막에 작성하면 안될까?&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/Swift/JustCode.png&quot; alt=&quot;JustCode&quot; style=&quot;zoom:33%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;테스트 코드를 작성하는 것 = 내가 개발 스펙을 제대로 이해했다&lt;/p&gt;

&lt;p&gt;이 코드가 어떻게 동작해야 하는지를 인지했다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/Swift/IKnow.png&quot; alt=&quot;IKnow&quot; style=&quot;zoom:33%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;코드 테스트를 위해선 어떤 것을 만들어 낼 것인지에 대한 충분한 이해가 필요하며, 명확하고 구체적인 목표를 가지고 진행해야 합니다. 또한 빠른 피드백과 피드백에 따른 반응을 통해 코드를 수정하기가 수월해집니다.&lt;/p&gt;

&lt;h3 id=&quot;unit-test&quot;&gt;Unit Test&lt;/h3&gt;

&lt;p&gt;유닛 테스트는 소스 코드의 특정 모듈이 의도대로 정확히 작동하는지를 검증하는 절차입니다. 모든 함수와 메소드에 대한 테스트 케이스를 작성하는 절차이며 언제라도 코드 변경으로 인해 문제가 생길 경우 짧은 시간 내에 이를 파악하고 바로 잡을 수 있도록 도와줍니다. 이상적으로 모든 테스트 케이스는 서로 분리되어야 하며 이를 위해 가짜 객체(Mock object)를 생성하는 것도 좋은 방법입니다.&lt;/p&gt;

&lt;h3 id=&quot;어떤-테스트를-작성해야할까&quot;&gt;어떤 테스트를 작성해야할까?&lt;/h3&gt;

&lt;p&gt;여러가지 방법론이 존재하는데 그 중 FIRST와 Right - BICEP 전략을 소개해보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;first-방법&quot;&gt;FIRST 방법&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Fast : 테스트는 빠르게 동작해야한다.&lt;/li&gt;
  &lt;li&gt;Independent : 테스트는 독립적으로 진행되어야한다.&lt;/li&gt;
  &lt;li&gt;Repeatable :&lt;/li&gt;
  &lt;li&gt;Self-validating :&lt;/li&gt;
  &lt;li&gt;Timely :&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;독립적으로 동작해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;이-좋은-tdd를-왜-현업에선-사용하지-않고-있을까&quot;&gt;이 좋은 TDD를 왜 현업에선 사용하지 않고 있을까?&lt;/h3&gt;

&lt;h3 id=&quot;글-작성을-위해-참고한-링크&quot;&gt;글 작성을 위해 참고한 링크&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@rinae/tdd-test-driven-development-%EB%A5%BC-%EC%97%B0%EC%8A%B5%ED%95%98%EB%A9%B4%EC%84%9C-%EC%B0%B8%EA%B3%A0%ED%95%98%EA%B8%B0-%EC%A2%8B%EC%9D%80-%ED%8C%81-10%EA%B0%80%EC%A7%80-d8cf46ae1806&quot;&gt;TDD 10가지 팁&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ahea.wordpress.com/2018/09/10/%EC%84%A0%ED%83%9D%EC%9D%B4-%EC%95%84%EB%8B%8C-%ED%95%84%EC%88%98-tdd/&quot;&gt;선택이 아닌 필수 TDD&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://brunch.co.kr/@cg4jins/9&quot;&gt;카카오헤어샵의 TDD&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://johngrib.github.io/wiki/test-terms/#fnref:devops-handbook-180:2&quot;&gt;Test 관련 용어 정리&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.appsdeveloperblog.com/unit-testing-code-that-throws-error-in-swift/&quot;&gt;Error를 Throw하는 테스트 케이스 다루는 법1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jayeshkawli.ghost.io/try-catch-blocks-and-unit-tests-in-swift-3-0/&quot;&gt;Error를 Throw하는 테스트 케이스 다루는 법1&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 30 Mar 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/swift/Swift-Unit-Test,-TDD/</link>
        <guid isPermaLink="true">https://neph3779.github.io/swift/Swift-Unit-Test,-TDD/</guid>
        
        <category>TDD</category>
        
        <category>Unit Test</category>
        
        
        <category>Swift</category>
        
      </item>
    
      <item>
        <title>Swift Lint 적용기</title>
        <description>&lt;h2 id=&quot;swift-lint-적용기&quot;&gt;Swift Lint 적용기&lt;/h2&gt;

&lt;p&gt;오늘은 Swift Lint와 코코아팟을 처음으로 적용해보았습니다.&lt;/p&gt;

&lt;p&gt;코코아팟 설치, 사용법은 &lt;a href=&quot;https://zeddios.tistory.com/25&quot;&gt;이 링크&lt;/a&gt;에서 보실 수 있습니다 (고마워요 제드!)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;간략하게 적용 과정을 요약하자면&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo gem install cocoapods&lt;/code&gt;를 터미널에 입력하여 코코아팟 설치&lt;/p&gt;

&lt;p&gt;터미널로 프로젝트 파일(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.xcodeproj&lt;/code&gt;)이 위치한 경로로 이동하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pod init&lt;/code&gt; 진행&lt;/p&gt;

&lt;p&gt;pod init이 정상적으로 됐다면 Podfile이 생성되었을텐데 에디터를 통해 오픈 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vim Podfile&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Podfile의 target do 밑줄에 pod ‘원하는 라이브러리 이름’ 을 적어주고 저장 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pod 'SwiftLint'&lt;/code&gt; 추가)&lt;/p&gt;

&lt;p&gt;터미널에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pod install&lt;/code&gt; 진행&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 작업이 완료되었다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.xcworkspace&lt;/code&gt;라는 파일이 생겼을텐데 이것을 통해 프로젝트 파일을 오픈&lt;/p&gt;

&lt;p&gt;BuildPhases의 추가 버튼 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt;버튼)을 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;New Run Script Phase&lt;/code&gt;를 진행&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;${PODS_ROOT}/SwiftLint/swiftlint
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드를 추가하면 끝!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.swiftlint.yml&lt;/code&gt;이라는 파일을 만들어서 불필요한 규칙들을 disable 시켜줄 수 있습니다. (Xcode내에서 empty 파일로 추가할수도 있지만 오류가 잦아 터미널에서 추가하는 것이 좋아보입니다.)&lt;/p&gt;

&lt;p&gt;규칙들은 아래의 링크를 통해 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/realm/SwiftLint&quot;&gt;Swift Lint 공식 깃허브&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://realm.github.io/SwiftLint/rule-directory.html&quot;&gt;Swift Lint 공식문서&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번 계산기 프로젝트에서 불필요하다 생각되는 규칙들은 다음과 같이 disable 시켜줬습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;disabled_rules:
- trailing_whitespace
- identifier_name
- line_length

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;참고한-링크&quot;&gt;참고한 링크&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/realm/SwiftLint&quot;&gt;Swift Lint 공식 깃허브&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://realm.github.io/SwiftLint/rule-directory.html&quot;&gt;Swift Lint 공식문서&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zeddios.tistory.com/25&quot;&gt;왕초보를 위한 코코아팟 사용법 (Zedd)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zeddios.tistory.com/447&quot;&gt;Swift Lint 사용법 (Zedd)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://yagom.net/forums/topic/swift-lint-%EC%8D%A8%EB%B3%B4%EA%B8%B0/&quot;&gt;Swift Lint 써보기 (야곰닷넷)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://academy.realm.io/kr/posts/slug-jp-simard-swiftlint/&quot;&gt;Swift Lint (realm)&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 30 Mar 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/swift/Swift-Lint-%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%80%E1%85%B5/</link>
        <guid isPermaLink="true">https://neph3779.github.io/swift/Swift-Lint-%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%80%E1%85%B5/</guid>
        
        <category>SwiftLint</category>
        
        <category>CocoaPods</category>
        
        
        <category>Swift</category>
        
      </item>
    
      <item>
        <title>2021년 03월 29일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;h3 id=&quot;unit-test&quot;&gt;Unit Test&lt;/h3&gt;

&lt;p&gt;유닛 테스트에 대해 공부했습니다&lt;/p&gt;

&lt;p&gt;Swift의 프레임워크인 XCTest를 이용하여 여러가지 메서드, 유닛들을 테스트할 수 있었습니다&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://velog.io/@wimes/UnitTest-for-Xcode&quot;&gt;참고할만한 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;os-3번째-스터디-진행&quot;&gt;OS 3번째 스터디 진행&lt;/h3&gt;

&lt;p&gt;운영체제 3번째 스터디를 진행했습니다.&lt;/p&gt;

&lt;p&gt;이번 스터디에서는 프로세스 관리와 스레드에 대해 다루었습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/i-study-OS/BHK/tree/main/OS3&quot;&gt;스터디 깃헙 레포지토리 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/3-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%8B%A4%ED%96%89/&quot;&gt;블로그 정리글 링크1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/4-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC/&quot;&gt;블로그 정리글 링크2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2의-보수와-비트-마스킹&quot;&gt;2의 보수와 비트 마스킹&lt;/h3&gt;

&lt;p&gt;팀원들과 함께 2의 보수에 대해 공부했습니다&lt;/p&gt;

&lt;p&gt;Swift에서는 음수를 Int8로 구성된 이진수로 변환하면 “-“가 붙은채로 변환되었기에&lt;/p&gt;

&lt;p&gt;이를 MSB를 Sign Bit로 만들어주기 위해 여러가지 로직들을 구상했습니다&lt;/p&gt;

&lt;p&gt;아래의 코드는 그 중 하나인 String 타입의 Text Field 내용을 받아 2진수 형태로 변환해주는 작업입니다.&lt;/p&gt;

&lt;p&gt;사용자가 MSB를 1로 설정하여 음수를 입력한 경우에 대해 변환하는 과정을 담았습니다&lt;/p&gt;

&lt;p&gt;어떤 수에 대한 2의 보수를 구하는 과정을 역순으로 진행하여 사용자가 의도한 값(음수)을 얻을 수 있도록 구성했습니다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;convertToBinary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;radix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;255는 8bit 이진수로 나타내면 1111_1111이므로 XOR연산시 number의 하위 8비트를 반전시켜줍니다.&lt;/p&gt;

&lt;p&gt;예를 들어 사용자 입력이1000_1001 이라면 사용자가 의도한 값은 -119이지만 Int로 변환시 128+8+1 = 137이 됩니다.&lt;/p&gt;

&lt;p&gt;이를 다시 -119로 만들어주기 위해 1을 빼준 뒤 255와 XOR 연산을 통해 0111_0111로 만들어줍니다&lt;/p&gt;

&lt;p&gt;그 뒤에 다시 -1을 곱해주면 우리가 원했던 결과인 -119로의 변환이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;고민중인-내용들&quot;&gt;고민중인 내용들&lt;/h2&gt;

&lt;h3 id=&quot;공부-시간의-분배에-대해-고민하고-있습니다&quot;&gt;공부 시간의 분배에 대해 고민하고 있습니다&lt;/h3&gt;

&lt;p&gt;CS, 프로젝트, 알고리즘 삼 박자가 맞게 공부를 하라..&lt;/p&gt;

&lt;p&gt;말은 참 쉽지만 몸은 하나이기에 잘 되지 않는 것 같습니다&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 29 Mar 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.03.29-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.03.29-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>[#4] 프로세스 관리 - 1</title>
        <description>&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;
&lt;ol id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#목차&quot; id=&quot;markdown-toc-목차&quot;&gt;목차&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#프로세스의-개념&quot; id=&quot;markdown-toc-프로세스의-개념&quot;&gt;프로세스의 개념&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#프로세스란&quot; id=&quot;markdown-toc-프로세스란&quot;&gt;프로세스란?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#프로세스의-문맥process-context의-필요성&quot; id=&quot;markdown-toc-프로세스의-문맥process-context의-필요성&quot;&gt;프로세스의 문맥(process context)의 필요성&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#프로세스-문맥의-세가지-분류&quot; id=&quot;markdown-toc-프로세스-문맥의-세가지-분류&quot;&gt;프로세스 문맥의 세가지 분류&lt;/a&gt;        &lt;ol&gt;
          &lt;li&gt;&lt;a href=&quot;#하드웨어-문맥&quot; id=&quot;markdown-toc-하드웨어-문맥&quot;&gt;하드웨어 문맥&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#프로세스의-주소-공간&quot; id=&quot;markdown-toc-프로세스의-주소-공간&quot;&gt;프로세스의 주소 공간&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#커널상의-문맥&quot; id=&quot;markdown-toc-커널상의-문맥&quot;&gt;커널상의 문맥&lt;/a&gt;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#프로세스의-상태&quot; id=&quot;markdown-toc-프로세스의-상태&quot;&gt;프로세스의 상태&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#프로세스의-세가지-상태---실행-준비-봉쇄&quot; id=&quot;markdown-toc-프로세스의-세가지-상태---실행-준비-봉쇄&quot;&gt;프로세스의 세가지 상태 - 실행, 준비, 봉쇄&lt;/a&gt;        &lt;ol&gt;
          &lt;li&gt;&lt;a href=&quot;#실행-상태&quot; id=&quot;markdown-toc-실행-상태&quot;&gt;실행 상태&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#준비-상태&quot; id=&quot;markdown-toc-준비-상태&quot;&gt;준비 상태&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#봉쇄-상태&quot; id=&quot;markdown-toc-봉쇄-상태&quot;&gt;봉쇄 상태&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#중지-상태&quot; id=&quot;markdown-toc-중지-상태&quot;&gt;중지 상태&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#그-외의-상태&quot; id=&quot;markdown-toc-그-외의-상태&quot;&gt;그 외의 상태&lt;/a&gt;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#프로세스-제어블록&quot; id=&quot;markdown-toc-프로세스-제어블록&quot;&gt;프로세스 제어블록&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#프로세스-제어블록pcb의-구성요소&quot; id=&quot;markdown-toc-프로세스-제어블록pcb의-구성요소&quot;&gt;프로세스 제어블록(PCB)의 구성요소&lt;/a&gt;        &lt;ol&gt;
          &lt;li&gt;&lt;a href=&quot;#프로세스의-상태process-state&quot; id=&quot;markdown-toc-프로세스의-상태process-state&quot;&gt;프로세스의 상태(process state)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#프로그램-카운터program-counter의-값&quot; id=&quot;markdown-toc-프로그램-카운터program-counter의-값&quot;&gt;프로그램 카운터(program counter)의 값&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#cpu-레지스터cpu-register의-값&quot; id=&quot;markdown-toc-cpu-레지스터cpu-register의-값&quot;&gt;CPU 레지스터(CPU register)의 값&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#cpu-스케쥴링-정보cpu-scheduling-information&quot; id=&quot;markdown-toc-cpu-스케쥴링-정보cpu-scheduling-information&quot;&gt;CPU 스케쥴링 정보(CPU scheduling information)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#메모리-관리-정보memory-management-information&quot; id=&quot;markdown-toc-메모리-관리-정보memory-management-information&quot;&gt;메모리 관리 정보(memory management information)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#자원-사용-정보accounting-information&quot; id=&quot;markdown-toc-자원-사용-정보accounting-information&quot;&gt;자원 사용 정보(accounting information)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#입출력-상태-정보io-status-information&quot; id=&quot;markdown-toc-입출력-상태-정보io-status-information&quot;&gt;입출력 상태 정보(I/O status information)&lt;/a&gt;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#문맥교환&quot; id=&quot;markdown-toc-문맥교환&quot;&gt;문맥교환&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#문맥교환content-switch의-의미&quot; id=&quot;markdown-toc-문맥교환content-switch의-의미&quot;&gt;문맥교환(content switch)의 의미&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#프로세스-스케쥴링을-위한-큐&quot; id=&quot;markdown-toc-프로세스-스케쥴링을-위한-큐&quot;&gt;프로세스 스케쥴링을 위한 큐&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#준비-큐ready-queue&quot; id=&quot;markdown-toc-준비-큐ready-queue&quot;&gt;준비 큐(ready queue)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#장치-큐device-queue&quot; id=&quot;markdown-toc-장치-큐device-queue&quot;&gt;장치 큐(device queue)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#소프트웨어-자원을-기다리는-큐&quot; id=&quot;markdown-toc-소프트웨어-자원을-기다리는-큐&quot;&gt;소프트웨어 자원을 기다리는 큐&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#스케쥴러&quot; id=&quot;markdown-toc-스케쥴러&quot;&gt;스케쥴러&lt;/a&gt;    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;#스케쥴러의-뜻&quot; id=&quot;markdown-toc-스케쥴러의-뜻&quot;&gt;스케쥴러의 뜻&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#스케쥴러의-종류&quot; id=&quot;markdown-toc-스케쥴러의-종류&quot;&gt;스케쥴러의 종류&lt;/a&gt;        &lt;ol&gt;
          &lt;li&gt;&lt;a href=&quot;#장기-스케쥴러작업-스케쥴러&quot; id=&quot;markdown-toc-장기-스케쥴러작업-스케쥴러&quot;&gt;장기 스케쥴러(작업 스케쥴러)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#특성&quot; id=&quot;markdown-toc-특성&quot;&gt;특성&lt;/a&gt;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#중기-스케쥴러&quot; id=&quot;markdown-toc-중기-스케쥴러&quot;&gt;중기 스케쥴러&lt;/a&gt;        &lt;ol&gt;
          &lt;li&gt;&lt;a href=&quot;#단기-스케쥴러cpu-스케쥴러&quot; id=&quot;markdown-toc-단기-스케쥴러cpu-스케쥴러&quot;&gt;단기 스케쥴러(CPU 스케쥴러)&lt;/a&gt;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;프로세스의-개념&quot;&gt;프로세스의 개념&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;프로세스란&quot;&gt;프로세스란?&lt;/h3&gt;

&lt;p&gt;프로세스란 실행 중인 프로그램을 뜻함&lt;/p&gt;

&lt;p&gt;디스크에 실행파일의 형태로 존재하던 프로그램이 메모리에 올라가서 실행되기 시작하면 프로세스가 됨&lt;/p&gt;

&lt;p&gt;프로세스는 CPU를 획득하여 자신의 코드를 수행,&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스의-문맥process-context의-필요성&quot;&gt;프로세스의 문맥(process context)의 필요성&lt;/h3&gt;

&lt;p&gt;프로세스의 문맥이란 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보&lt;/p&gt;

&lt;p&gt;여러 프로세스가 실행되면 프로세스마다 CPU를 번갈아가며 사용&lt;/p&gt;

&lt;p&gt;따라서 CPU 재보유하여 명령의 수행을 재개할 때 직전 수행 시점의 정확한 상태를 재현해야 함&lt;/p&gt;

&lt;p&gt;이때 정확한 재현을 위해 필요한 것이 프로세스의 문맥&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스-문맥의-세가지-분류&quot;&gt;프로세스 문맥의 세가지 분류&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/OS/4/1.png&quot; alt=&quot;1&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;하드웨어-문맥&quot;&gt;하드웨어 문맥&lt;/h4&gt;

&lt;p&gt;CPU의 수행 상태를 나타내는 PC값과 각종 레지스터들&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;프로세스의-주소-공간&quot;&gt;프로세스의 주소 공간&lt;/h4&gt;

&lt;p&gt;프로세스가 보유한 독자적 주소공간인 코드, 데이터, 스택&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;커널상의-문맥&quot;&gt;커널상의 문맥&lt;/h4&gt;

&lt;p&gt;프로세스를 관리하기 위한 자료구조인 PCB와 커널스택&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로세스의-상태&quot;&gt;프로세스의 상태&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;프로세스의-세가지-상태---실행-준비-봉쇄&quot;&gt;프로세스의 세가지 상태 - 실행, 준비, 봉쇄&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;실행-상태&quot;&gt;실행 상태&lt;/h4&gt;

&lt;p&gt;프로세스가 CPU를 보유하고 기계어 명령을 처리하고 있는 상태&lt;/p&gt;

&lt;p&gt;매 시점마다 실행 상태에 있는 프로세스는 오직 하나 뿐&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;준비-상태&quot;&gt;준비 상태&lt;/h4&gt;

&lt;p&gt;CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;봉쇄-상태&quot;&gt;봉쇄 상태&lt;/h4&gt;

&lt;p&gt;당장 명령을 실행할 수 없는 상태&lt;/p&gt;

&lt;p&gt;주로 요청한 입출력 작업이 처리중일 때 프로세스는 봉쇄 상태에 머무름&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;중지-상태&quot;&gt;중지 상태&lt;/h4&gt;

&lt;p&gt;외부적인 이유로 프로세스의 수행이 정지된 상태&lt;/p&gt;

&lt;p&gt;외부에서 재개시키지 않는 이상 다시 활성화 될 수 없음&lt;/p&gt;

&lt;p&gt;중지 상태의 프로세스는 메모리를 통째로 빼앗기고 디스크로 스왑 아웃 됨 (중기 스케쥴러에 의해 되는 경우가 대표적)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;중지준비&lt;/li&gt;
  &lt;li&gt;중지봉쇄&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;그-외의-상태&quot;&gt;그 외의 상태&lt;/h4&gt;

&lt;p&gt;프로세스가 생성중일 때 - 시작(new) 상태&lt;/p&gt;

&lt;p&gt;프로세스가 종료중인 상태 - 완료(terminated) 상태&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로세스-제어블록&quot;&gt;프로세스 제어블록&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;프로세스-제어블록pcb의-구성요소&quot;&gt;프로세스 제어블록(PCB)의 구성요소&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;프로세스의-상태process-state&quot;&gt;프로세스의 상태(process state)&lt;/h4&gt;

&lt;p&gt;CPU를 할당해도 되는지의 여부를 결정하기 위해 필요&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;프로그램-카운터program-counter의-값&quot;&gt;프로그램 카운터(program counter)의 값&lt;/h4&gt;

&lt;p&gt;다음에 수행할 명령의 위치를 가리킴&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;cpu-레지스터cpu-register의-값&quot;&gt;CPU 레지스터(CPU register)의 값&lt;/h4&gt;

&lt;p&gt;CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지를 나타냄&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;cpu-스케쥴링-정보cpu-scheduling-information&quot;&gt;CPU 스케쥴링 정보(CPU scheduling information)&lt;/h4&gt;

&lt;p&gt;CPU 스케쥴링을 위해 필요&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;메모리-관리-정보memory-management-information&quot;&gt;메모리 관리 정보(memory management information)&lt;/h4&gt;

&lt;p&gt;메모리 할당을 위해 필요&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;자원-사용-정보accounting-information&quot;&gt;자원 사용 정보(accounting information)&lt;/h4&gt;

&lt;p&gt;사용자에게 자원 사용 요금을 계산하여 청구하는 등의 용도에 의해 필요&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;입출력-상태-정보io-status-information&quot;&gt;입출력 상태 정보(I/O status information)&lt;/h4&gt;

&lt;p&gt;프로세스가 오픈한 파일 정보 등 프로세스 입출력 관련 상태 정보를 나타냄&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;문맥교환&quot;&gt;문맥교환&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;문맥교환content-switch의-의미&quot;&gt;문맥교환(content switch)의 의미&lt;/h3&gt;

&lt;p&gt;문맥교환이란 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정을 뜻함&lt;/p&gt;

&lt;p&gt;문맥교환은 타이머 인터럽트, 프로세스의 입출력 요청, 다른 조건을 충족하지 못해 CPU를 회수당하고 봉쇄 상태가 되는 경우에 발생&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/OS/4/2.png&quot; alt=&quot;2&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로세스-스케쥴링을-위한-큐&quot;&gt;프로세스 스케쥴링을 위한 큐&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;준비-큐ready-queue&quot;&gt;준비 큐(ready queue)&lt;/h3&gt;

&lt;p&gt;CPU를 기다리는 프로세스들을 줄 세우기 위한 큐&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;장치-큐device-queue&quot;&gt;장치 큐(device queue)&lt;/h3&gt;

&lt;p&gt;특정 자원을 기다리는 프로세스들을 줄 세우기 위한 큐&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;소프트웨어-자원을-기다리는-큐&quot;&gt;소프트웨어 자원을 기다리는 큐&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;스케쥴러&quot;&gt;스케쥴러&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;스케쥴러의-뜻&quot;&gt;스케쥴러의 뜻&lt;/h3&gt;

&lt;p&gt;어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의  코드&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;스케쥴러의-종류&quot;&gt;스케쥴러의 종류&lt;/h3&gt;

&lt;h4 id=&quot;장기-스케쥴러작업-스케쥴러&quot;&gt;장기 스케쥴러(작업 스케쥴러)&lt;/h4&gt;

&lt;p&gt;어떤 프로세스를 준비 큐에 진입시킬지 결정하는 역할&lt;/p&gt;

&lt;p&gt;프로세스에게 메모리를 할당시키는 역할&lt;/p&gt;

&lt;p&gt;처음 프로세스가 생성되면 시작 상태를 거쳐 준비 상태에 이르게 되는데 장기 스케쥴러는 이때 어떤 큐에 삽입할지 결정&lt;/p&gt;

&lt;h4 id=&quot;특성&quot;&gt;특성&lt;/h4&gt;

&lt;p&gt;수십 초 내지 수 분 단위로 가끔 호출되므로 속도가 빠르지 않아도 됨&lt;/p&gt;

&lt;p&gt;메모리에 동시에 올라가 있는 프로세스의 수를 조절하는 역할(시작 상태의 프로세스에게 메모리 할당을 승인할지 여부를 장기 스케쥴러가 결정하기 때문&lt;/p&gt;

&lt;p&gt;현대의 시분할 시스템에서는 거의 사용되지 않음 (자원이 매우 빈약하던 과거에 쓰였었음)&lt;/p&gt;

&lt;p&gt;현대에는 시작 상태가 되면 곧바로 그 프로세스에 메모리를 할당해서 준비 큐에 넣어줌&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;중기-스케쥴러&quot;&gt;중기 스케쥴러&lt;/h3&gt;

&lt;p&gt;너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우에 이를 동적으로 조절하기 위해 추가된 스케쥴러&lt;/p&gt;

&lt;p&gt;스왑 아웃 : 너무 많은 프로세스가 메모리에 적재되어 프로세스당 보유 메모리양이 극도로 적어지면 메모리에 올라와 있는 프로세스 중 일부를 선정해 이들로부터 메모리를 통째로 빼앗아 그 내용을 디스크 스왑 영역에 저장하는 것&lt;/p&gt;

&lt;p&gt;스왑 아웃 우선순위가 가장 높은 것은 봉쇄 상태의 프로세스들&lt;/p&gt;

&lt;p&gt;이 외에도 타이머 인터럽트가 발생해 준비 큐로 이동하는 프로세스도 스왑 아웃 시킴&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;단기-스케쥴러cpu-스케쥴러&quot;&gt;단기 스케쥴러(CPU 스케쥴러)&lt;/h4&gt;

&lt;p&gt;준비 상태의 프로세스 중 어떤 프로세스를 다음번에 실행 상태로 만들 것인지 결정&lt;/p&gt;

&lt;p&gt;여러 프로세스 중 어떤 프로세스에 CPU를 할당할 것인가를 결정&lt;/p&gt;

&lt;p&gt;타이머 인터럽트 발생 시 단기 스케쥴러가 호출됨&lt;/p&gt;

&lt;p&gt;특성&lt;/p&gt;

&lt;p&gt;밀리초 단위로 매우 빈번히 호출되므로 속도가 빨라야 함&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sun, 28 Mar 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/4-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3-%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/4-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3-%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
  </channel>
</rss>
