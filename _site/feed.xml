<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Neph's Blog</title>
    <description>Write code with my soul.</description>
    <link>https://neph3779.github.io/</link>
    <atom:link href="https://neph3779.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 12 May 2021 01:20:14 +0900</pubDate>
    <lastBuildDate>Wed, 12 May 2021 01:20:14 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>HTTP 기본 개념 정리 with swift</title>
        <description>&lt;h2 id=&quot;http란&quot;&gt;HTTP란?&lt;/h2&gt;

&lt;p&gt;CSS, HTML, 이미지 등이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Server와&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Client가&lt;/code&gt; 서로 주고받는 Content라면&lt;/p&gt;

&lt;p&gt;Content를 주고받기 위해 서로가 알아들을 수 있는 공통의 약속(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Protocol&lt;/code&gt;)이 필요하다.&lt;/p&gt;

&lt;p&gt;이 약속이 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP&lt;/code&gt;(Hyper Text Tranfer Protocol)이다.&lt;/p&gt;

&lt;h2 id=&quot;request와-response&quot;&gt;Request와 Response&lt;/h2&gt;

&lt;p&gt;HTTP는 크게 Request와 Response로 구분된다.&lt;/p&gt;

&lt;p&gt;Client가 Request 메세지를 작성해서 Server에 보내면 Server는 Response를 보내준다.&lt;/p&gt;

&lt;p&gt;Request와 Response Message는 각각 Header와 Body로 구분된다.&lt;/p&gt;

&lt;h2 id=&quot;http-message-구조&quot;&gt;HTTP Message 구조&lt;/h2&gt;

&lt;p&gt;Request의 Message는 다음과 같은 구조로 이루어져 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210511230558.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Header와 Body로 구분되며 그 사이에는 반드시 blank line이 들어가야한다.&lt;/p&gt;

&lt;h3 id=&quot;header의-구조&quot;&gt;Header의 구조&lt;/h3&gt;

&lt;p&gt;가장 첫 줄은 Request Line으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP Method Name&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;요청할 파일의 형식/요청할 파일의 이름&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사용할 HTTP 버전&lt;/code&gt;으로 이루어져있다.&lt;/p&gt;

&lt;p&gt;Request Line을 제외한 나머지 부분을 Request Header라고 부르는데 필수로 적어야하는 Host Header를 제외하면 다른 Header는 꼭 있어야 하는건 아니다.&lt;/p&gt;

&lt;p&gt;이번 프로젝트에서 중요하게 이용되는 HTTP Header인  Conten-type에는  Body에 들어갈 Message의 MIME(Multipurpose Internet Mail Extensions) type을 적어줄 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;body의-구조&quot;&gt;Body의 구조&lt;/h3&gt;

&lt;p&gt;MIME type은 여러가지 종류가 있는데 가장 대표적인 것은 HTML 코드이며,  이번 프로젝트에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multipart/form-data&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt;을 사용한다. JSON에 비해 상대적으로 익숙하지 않은 multipart/form-data를 아래에 정리해보았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MIME Type에 대해 설명하고 있는 mozilla 문서: &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types&quot;&gt;MIME 타입&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;더 많은 MIME Type은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types&quot;&gt;이 링크&lt;/a&gt;에서 볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;multipartform-data&quot;&gt;multipart/form-data&lt;/h3&gt;

&lt;p&gt;multipart/form-data는 HTML Form의 내용을 전송할 때 사용할 수 있는 문서 형식이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&lt;/code&gt;로 시작되는 문자열인 boundary로 구분되는 서로 다른 파트들로 구성되며, 각각의 파트는 그 자체로서 개체이며 자신만의 HTTP 헤더를 가진다. 파일 업로드 필드를 위한 헤더로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Disposition&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Type&lt;/code&gt;이 있다.&lt;/p&gt;

&lt;p&gt;Content-type Header에 boundary parameter를 포함해야하며 이 boundary parameter는 메세지 파트의 구분(multipart를 서로 구분해주는 역할)과 메세지의 시작과 끝을 나타내는 역할을 한다.&lt;/p&gt;

&lt;p&gt;첫번째 Boundary 이전의 Body는 MIME을 지원하지 않는 클라이언트를 위해 제공되는 영역이다.&lt;/p&gt;

&lt;p&gt;boundary parameter에 들어갈 문자열을 프로그래머가 무작위 문자를 선택해서 작성한다. 이 때 보통 앞부분에는 WebkitFormBoundary… 등과 같이 프로그래머가 인식할 수 있는 문자를 삽입하며 뒷부분에 무작위 문자열을 붙여서 Boundary가  unique하도록 만들어 본문과의 충돌을 피한다.&lt;/p&gt;

&lt;h2 id=&quot;http-코드를-보며-이해해보자&quot;&gt;HTTP 코드를 보며 이해해보자&lt;/h2&gt;

&lt;div class=&quot;language-http highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;POST&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;/item&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;HTTP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1.1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;camp-open-market-2.herokuapp.com&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Content-Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW&lt;/span&gt;

----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;title&quot;

귀여운 딸기
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;descriptions&quot;

귀여운 딸기입니다.
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;price&quot;

1000
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;currency&quot;

KRW
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;stock&quot;

10
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;images[]&quot;; filename=&quot;Strawberry-removebg-preview.png&quot;
Content-Type: image/png

(data)
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;password&quot;

neph1234
----WebKitFormBoundary7MA4YWxkTrZu0gW--
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;request-line&quot;&gt;Request Line&lt;/h3&gt;

&lt;div class=&quot;language-http highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;POST&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;/item&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;HTTP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1.1&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;가장 첫 줄에는 Request Line이 적혀있는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;POST는 HTTP Method 중 하나이며 더 많은 메서드에 대한 정보는 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Methods&quot;&gt;이 링크&lt;/a&gt;에서 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;request-headers&quot;&gt;Request Headers&lt;/h3&gt;

&lt;div class=&quot;language-http highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;err&quot;&gt;Host: camp-open-market-2.herokuapp.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Request Header에는 여러가지 Header가 선택적으로 들어갈 수 있으며 이 코드에서는 Host와 Content-Type Header가 들어가 있다.&lt;/p&gt;

&lt;p&gt;Content-Type의 내용으로는 multipart/form-data와 boundary parameter가 전달된다.&lt;/p&gt;

&lt;p&gt;boundary parameter로는 임의의 문자열이 전달되면 된다 (보통 swift에서는 UUID를 활용)&lt;/p&gt;

&lt;h3 id=&quot;request-body&quot;&gt;Request Body&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;title&quot;

귀여운 딸기
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;descriptions&quot;

귀여운 딸기입니다.
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;price&quot;

1000
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;currency&quot;

KRW
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;stock&quot;

10
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;images[]&quot;; filename=&quot;Strawberry-removebg-preview.png&quot;
Content-Type: image/png

(data)
----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;password&quot;

neph1234
----WebKitFormBoundary7MA4YWxkTrZu0gW--
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Request Body내의 하나의 단락의 시작은 boundary로 시작한다.&lt;/p&gt;

&lt;p&gt;밑줄에는 Content-Disposition을 적어주고&lt;/p&gt;

&lt;p&gt;blank line을 하나 삽입한 뒤&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;에 명시된 공간에 들어갈 내용을 적어준다&lt;/p&gt;

&lt;p&gt;즉, 아래의 코드가 하나의 단락이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;title&quot;

귀여운 딸기
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;주의할 점은 (data)라고 적힌 공간에는 문자열로 변환된 data가 들어있다.&lt;/p&gt;

&lt;p&gt;이미지의 문자열로의 변환은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIImageJPEGRepresentation&lt;/code&gt;메서드를 통해 진행해줄 수 있다.&lt;/p&gt;

&lt;p&gt;Body의 마지막에는 boudary를 적어주며, 꼭 따라야하는 것은 아니지만 관례적으로 boudary 뒤에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&lt;/code&gt;를 붙여줌으로써 구분이 쉽도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;swift-코드를-통해-multipartform-data-코드-만들기&quot;&gt;Swift 코드를 통해 multipart/form-data 코드 만들기&lt;/h2&gt;

&lt;p&gt;처음 multipart/form-data 코드를 만드려하면 참 난감하다.&lt;/p&gt;

&lt;p&gt;그래서 위에 작성한 multipart/form-data를 swift 코드로 변환해주는 함수를 작성하여 아래에 남겨두었다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;convertTextField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fieldString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;--&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;boundary&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fieldString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Content-Disposition: form-data; name=&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)\&quot;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fieldString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fieldString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fieldString&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 아래의 multipart/form-data 예제 단락을 통해 이해해보자&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name=&quot;title&quot;

귀여운 딸기
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 parameter로 받아오는 key는 아래의 예시에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;title&lt;/code&gt;에 해당한다.&lt;/p&gt;

&lt;p&gt;그리고 value로 넣어줄 값은 “귀여운 딸기”라는 String이다.&lt;/p&gt;

&lt;p&gt;첫 줄에는 “–(boundary)\r\n”라는 값을 넣어 단락의 시작을 알린다.&lt;/p&gt;

&lt;p&gt;그 뒤로는 Content-Disposition과 value 값을 각각 fieldString이라는 문자열에 넣어 마무리한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;\n은 newline인 것을 알겠다지만 \r은 대체 왜 필요한지 의문이 들었다.&lt;/p&gt;

  &lt;p&gt;나와 같은 의문을 품을 독자를 위해 해당 의문에 대해 어느정도 답이 된 &lt;a href=&quot;https://m.blog.naver.com/taeil34/221325864981&quot;&gt;글&lt;/a&gt;을 첨부한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;참고한-링크&quot;&gt;참고한 링크&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP 헤더의 종류들에 대해 잘 설명해놓은 글: &lt;a href=&quot;http://go-colly.org/articles/scraping_related_http_headers/&quot;&gt;The most important HTTP headers for scraping&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;swift를 통한 URLSession Tutorial: &lt;a href=&quot;https://www.donnywals.com/uploading-images-and-forms-to-a-server-using-urlsession/&quot;&gt;Uploading images and forms to a server using URLSession&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;mozilla의 Content-Type Document: &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Type&quot;&gt;Content-Type&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;mozilla의 HTTP Methods Document: &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP/Methods&quot;&gt;HTTP 요청 메서드&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\r&lt;/code&gt;은 왜써야할까? : &lt;a href=&quot;https://m.blog.naver.com/taeil34/221325864981&quot;&gt;CR(\r), LF(\n)이란 무엇인가?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 12 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/HTTPBasicWithSwift/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/HTTPBasicWithSwift/</guid>
        
        <category>HTTP</category>
        
        <category>multipart/form-data</category>
        
        
        <category>네트워크</category>
        
      </item>
    
      <item>
        <title>[#12] 메모리 관리-1</title>
        <description>&lt;h2 id=&quot;logical-address-vs-physical-address&quot;&gt;Logical Address vs Physical Address&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509140605.png&quot; alt=&quot;image-20210509140602320&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Logical address는 프로세스마다 독립적으로 가지는 주소공간이다. 어떤 프로세스가 메모리상에서 어느 지점에 위치하는지와 무관하게 논리적으로 각 프로세스가 0번지부터 가지고 있는 주소값을 Logical address(virtual address)라고 부른다.&lt;/p&gt;

&lt;p&gt;반면 Physical address는 메모리에 실제로 올라가있는 위치를 나타낸다.&lt;/p&gt;

&lt;p&gt;어떤 프로그램이 물리적인 메모리의 어느 지점으로 올라갈지에 대해 결정하는 것을 주소 바인딩이라 한다. 주소 바인딩의 시점은 크게 3가지로 분류할 수 있다.&lt;/p&gt;

&lt;p&gt;❗️Symbolic Address란 우리가 흔히 사용하는 포인터라 볼 수 있다. 프로그래밍을 할 때 논리적인 주소값을 실제로 사용하는 경우는 거의 없고 Symbolic한 공간에 담아서 사용하는데 이런 것을 Symbolic Address라 한다. 컴파일 시에 이런 Symbolic Address는 Logical Address로 바뀌게 된다.&lt;/p&gt;

&lt;h2 id=&quot;주소-바인딩의-3가지-시점&quot;&gt;주소 바인딩의 3가지 시점&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509141342.png&quot; alt=&quot;image-20210509141341673&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509141431.png&quot; alt=&quot;image-20210509141428970&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;주소 바인딩이 이루어지는 시점은 크게 다음 3가지로 분류할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Compile time binding&lt;/p&gt;

    &lt;p&gt;컴파일 타임에 Physical address가 결정됨 (사실상 Logical address가 Physical address와 같음)&lt;/p&gt;

    &lt;p&gt;컴파일 타임에 메모리 어느위치에 올라가야 할지가 결정되어야 하므로 비효율적&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Load time binding&lt;/p&gt;

    &lt;p&gt;프로그램이 메모리에 올라갈 때 Logical address를 Physical address에 올려준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Execution time binding (= Run time binding)&lt;/p&gt;

    &lt;p&gt;Load time binding과 기본적으로 같지만 Physical address가 실행되는 도중에 바뀔 수 있다. (메모리에서 쫓겨났다가 다시 메모리에 올라갈 수 있으므로)&lt;/p&gt;

    &lt;p&gt;하드웨어적 지원이 필요한 방식이며 MMU라는 하드웨어가 이를 담당한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;❗️ instruction code내부의 Logical Address는 메모리에 올라가더라도 Logical Address의 상태를 유지하고 있으므로 CPU가 보는 주소는 Logical Address라는 것에 유의&lt;/p&gt;

&lt;h2 id=&quot;memory-management-unit&quot;&gt;Memory Management Unit&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509173608.png&quot; alt=&quot;image-20210509173605022&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;주소변환을 위한 하드웨어 장치인 MMU는 base register(relocation register)의 값을 통해 user program과 CPU가 Logical address만을 가지고 일할 수 있도록 도와준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509173742.png&quot; alt=&quot;image-20210509173739212&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509173920.png&quot; alt=&quot;image-20210509173916868&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가장 간단한 형태의 MMU는 Relocation register와 Limit register 이 두개의 레지스터를 통해 주소바인딩을 진행한다.&lt;/p&gt;

&lt;p&gt;그림의 예제에서는 Logical Address 346번지를 보려하고 있다. 이런 상황에서 프로세스 p1의 시작위치(relocation register) + 346에 위치한 메모리에 올라가있는 값을 읽어 반환한다.&lt;/p&gt;

&lt;p&gt;Limit register는 프로그램의 크기를 담는 값으로 범위를 벗어난 주소로의 잘못된 접근을 막아준다. (다른 프로그램이 존재하는 위치의 값을 참조할 수 없음)&lt;/p&gt;

&lt;h2 id=&quot;몇가지-용어-정리&quot;&gt;몇가지 용어 정리&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509174433.png&quot; alt=&quot;image-20210509174430642&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dynamic-loading-loading-메모리로-올리는-것&quot;&gt;Dynamic Loading (Loading: 메모리로 올리는 것)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 전체를 메모리에 미리 올리는 것이 아닌 해당 루틴이 불려질 때 메모리에 load하는 것&lt;/li&gt;
  &lt;li&gt;메모리 이용률 향상&lt;/li&gt;
  &lt;li&gt;가끔식 사용되는 코드들이 많은 경우에 유용 (오류 처리 루틴은 가끔씩만 사용됨)&lt;/li&gt;
  &lt;li&gt;운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능
    &lt;ul&gt;
      &lt;li&gt;OS가 라이브러리를 통해 Dynamic Loading을 쉽게 할 수 있도록 지원)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dynamic-linking&quot;&gt;Dynamic Linking&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Linking을 실행 시간(execution time)까지 미루는 기법&lt;/li&gt;
  &lt;li&gt;Static linking
    &lt;ul&gt;
      &lt;li&gt;라이브러리가 프로그램의 실행 파일 코드에 포함됨&lt;/li&gt;
      &lt;li&gt;실행 파일의 크기가 커짐&lt;/li&gt;
      &lt;li&gt;동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dynamic linking
    &lt;ul&gt;
      &lt;li&gt;라이브러리가 실행시에 연결(link)됨&lt;/li&gt;
      &lt;li&gt;라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 stub이라는 작은 코드를 둠&lt;/li&gt;
      &lt;li&gt;라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고, 없으면  디스크에서 읽어옴&lt;/li&gt;
      &lt;li&gt;운영체제의 도움이 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;overlays&quot;&gt;Overlays&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;메모리에 프로세스의 부분 중 실제 필요한 정보만을 올림&lt;/li&gt;
  &lt;li&gt;프로세스의 크기가 메모리보다 클 때 유용&lt;/li&gt;
  &lt;li&gt;운영체제의 지원없이 사용자에 의해 구현&lt;/li&gt;
  &lt;li&gt;작은 공간의 메모리를 사용하던 초창기 시스테메서 수작업으로 프로그래머가 구현
    &lt;ul&gt;
      &lt;li&gt;Manual Overlay&lt;/li&gt;
      &lt;li&gt;프로그래밍이 매우 복잡함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;swapping&quot;&gt;Swapping&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Swapping : 프로세스를 일시적으로 메모리에서 backing store로(하드디스크 등) 쫓아내는 것&lt;/li&gt;
  &lt;li&gt;Backing store (= swap area)
    &lt;ul&gt;
      &lt;li&gt;디스크 : 많은 사용자의 프로세스 이미지를 담&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Swap in / Swap out
    &lt;ul&gt;
      &lt;li&gt;일반적으로 중기 스케쥴러 (swapper)에 의해 swap out 시킬 프로세스 선정&lt;/li&gt;
      &lt;li&gt;priority based CPU scheduling algorithm
        &lt;ul&gt;
          &lt;li&gt;priority가 낮은 프로세스를 swapped out&lt;/li&gt;
          &lt;li&gt;priority가 높은 프로세스를 메모리에 올려놓음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Compile time 혹은  load time binding 에서는 원래 메모리 위치로 swap in 해야함&lt;/li&gt;
      &lt;li&gt;Run time binding에서는 추후 빈 메모리 영역 아무 곳에나 올릴 수 있음&lt;/li&gt;
      &lt;li&gt;swap time은 대부분 transfer time (swap되는 양에 비례하는 시간)임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509180641.png&quot; alt=&quot;image-20210509180638441&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스를 메모리에서 backing store로 swap out하고&lt;/p&gt;

&lt;p&gt;backing store에서 메모리로 다시 swap in 하는 과정&lt;/p&gt;

&lt;h2 id=&quot;allocation-of-physical-memory&quot;&gt;Allocation of Physical Memory&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509183936.png&quot; alt=&quot;image-20210509183932669&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;물리 메모리는 낮은 주소공간에 OS가, 높은 주소공간에 사용자 프로세스가 올라간다.&lt;/p&gt;

&lt;p&gt;사용자 프로세스를 할당하는 방법에는 연속 할당과 불연속 할당이 있다.&lt;/p&gt;

&lt;p&gt;불연속 할당의 예시로는 잘 알려진 Paging 기법이 있다.&lt;/p&gt;

&lt;h2 id=&quot;연속-할당&quot;&gt;연속 할당&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509184148.png&quot; alt=&quot;image-20210509184146679&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연속 할당은 고정 분할 방식과 가변분할 방식으로 구분된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509184248.png&quot; alt=&quot;image-20210509184246161&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;고정 분할 방식은 사용자의 프로그램을 미리 파티션(분할)으로 나누는 것이고&lt;/p&gt;

&lt;p&gt;가변 분할 방식은 사용자 프로그램이 들어가 있는 메모리 영역을 미리 나누지 않는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509184231.png&quot; alt=&quot;image-20210509184229095&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;외부 조각이란 프로그램의 크기보다 분할의 크기가 작은 경우에 발생 (다른 프로그램이 들어가기엔 너무 작은 공간)&lt;/p&gt;

&lt;p&gt;내부 조각이란 프로그램이 들어가고도 남아버린 공간&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509190019.png&quot; alt=&quot;image-20210509190016473&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Hole : 가용 메모리 공간&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509190145.png&quot; alt=&quot;image-20210509190141506&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연속 할당을 사용하면 Hole이 생기는데 이 Hole의 어느 위치에 프로그램을 넣을 것인지에 대한 문제가 Dynamic Storage Allocation Problem이다.&lt;/p&gt;

&lt;p&gt;이 문제를 해결하는 알고리즘은 대표적으로 다음 세가지가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;First - fit&lt;/li&gt;
  &lt;li&gt;Best - fit&lt;/li&gt;
  &lt;li&gt;Worst - fit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509190404.png&quot; alt=&quot;image-20210509190401752&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;외부조각 문제를 해결하는 방법중엔 compaction 이라는 방법이 있는데 사용중인 메모리 영역을 한군데로 몰아서 사용 가능한 넓은 공간을 얻어내는 방법이다. compaction시 최소한의 메모리 이동 방법을 구하기 매우 어려우며 비용이 많이 든다.&lt;/p&gt;

&lt;h2 id=&quot;paging-기법&quot;&gt;Paging 기법&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509190553.png&quot; alt=&quot;image-20210509190550691&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509191337.png&quot; alt=&quot;image-20210509191333969&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각각의 page로 나누어 비어있는 공간이 있다면 page를 물리적인 메모리(page frame)에 할당해준다.&lt;/p&gt;

&lt;p&gt;logical page frame이 physical memory의 어떤 frame에 올라가 있는지에 대해 다루는 것이 page table이다.&lt;/p&gt;

&lt;p&gt;page table의 내용에는 frame의 번호가 담겨있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509193903.png&quot; alt=&quot;image-20210509193900472&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 그림은 paging 기법을 나타낸 그림이다.&lt;/p&gt;

&lt;p&gt;CPU가 논리적인 주소를 주면 물리적인 주소로 바꿔주는 작업을 page table을 거쳐서 진행한다.&lt;/p&gt;

&lt;p&gt;p는 page의 번호가 되고 d는 page 내에서 얼만큼 떨어져 있는지를 나타내는 offset이 된다.&lt;/p&gt;

&lt;p&gt;물리적인 주소로 바꾸기 위해 page의 번호를 frame의 번호로 바꾸는 작업이 page table에서 진행된다.&lt;/p&gt;

&lt;p&gt;page table의 용량이 매우 크기 때문에 page table은 물리적 메모리에 들어가게 된다.&lt;/p&gt;

&lt;h2 id=&quot;tlb--associative-register&quot;&gt;TLB &amp;amp; Associative Register&lt;/h2&gt;

&lt;h3 id=&quot;page-table의-구현&quot;&gt;Page Table의 구현&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509194641.png&quot; alt=&quot;image-20210509194638320&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;메모리에 접근하기 위해서는 주소 변환을 해야하며&lt;/p&gt;

&lt;p&gt;page table이 메모리에 존재하기 때문에&lt;/p&gt;

&lt;p&gt;page table에 접근하는 과정에서 메모리 접근이 이루어지고&lt;/p&gt;

&lt;p&gt;page table을 통해 변환된 주소로 이동하는 과정에서 또 한번 메모리 접근이 이루어진다.&lt;/p&gt;

&lt;p&gt;MMU는 base register와 limit register가 존재했는데 Page Table에서는 이것이 Page-table base register(PTBR)와 Page-table length register(PTLR) 두가지로 이용된다.&lt;/p&gt;

&lt;p&gt;PTBR은 page table을 가리키며 (메모리에 존재하므로 page table에 접근하기 위해 필요)&lt;/p&gt;

&lt;p&gt;PTLR은 테이블의 크기를 보관한다. (limit의 용도)&lt;/p&gt;

&lt;p&gt;이렇듯 두 번의 메모리 접근은 비용이 크기 때문에 속도 향상을 위해 별도의 하드웨어 자원을 두기도 하는데 associative register 혹은 Translation Look-aside Buffer(TLB)라 불리는 캐시를 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;tlb&quot;&gt;TLB&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509195201.png&quot; alt=&quot;image-20210509195158476&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;캐시 메모리 : 메인 메모리 윗단에 존재하는 메인 메모리에서 빈번히 사용되는 메모리를 더 빨리 접근할 수 있게 해주는 메모리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TLB는 page table에서 빈번히 이용되는 table 값을 캐싱하고 있음 (메인 메모리보다 접근 속도가 빠름)&lt;/p&gt;

&lt;p&gt;CPU가 메모리에 접근할때는 먼저 TLB를 검색해보고 TLB에 없는 경우 (TLB miss)에는 page table를 통해 접근한다.&lt;/p&gt;

&lt;p&gt;page 번호와 frame 번호 쌍을 가지고 있으며 TLB 전체를 검색해봐야 있는지 없는지를 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;associative-register&quot;&gt;Associative Register&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509195711.png&quot; alt=&quot;image-20210509195707543&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TLB 전체를 항상 검색해봐야한다는 특성 때문에 병렬적 탐색이 가능한 Associative register를 사용한다.&lt;/p&gt;

&lt;p&gt;TLB와 page table은 프로세스마다 존재해야하므로 문맥교환이 일어날때마다 flush 작업을 해줘서 비워줘야 한다.&lt;/p&gt;

&lt;h3 id=&quot;실제-메모리-접근-시간&quot;&gt;실제 메모리 접근 시간&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509200005.png&quot; alt=&quot;image-20210509200001687&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;two-level-page-table&quot;&gt;Two-Level Page Table&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509200119.png&quot; alt=&quot;image-20210509200117200&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509202817.png&quot; alt=&quot;image-20210509202814597&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509203420.png&quot; alt=&quot;image-20210509203416523&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509203524.png&quot; alt=&quot;image-20210509203521191&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일반 Page Table은 공간의 낭비가 크므로 이를 개선하기 위해 있는 것이 Two-Level Paging Table&lt;/p&gt;

&lt;p&gt;inner table의 entry 하나당 크기는 4bytes인데 이는 inner table의 크기가 실제 page의 크기와 같기 때문이다.&lt;/p&gt;

&lt;p&gt;2^10 = 1K이므로 1K만큼의 크기를 가진 page와 매칭이 가능하다.&lt;/p&gt;

</description>
        <pubDate>Sun, 09 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/12-Memory-Management/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/12-Memory-Management/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>frame &amp; bounds</title>
        <description>&lt;h2 id=&quot;frame&quot;&gt;frame&lt;/h2&gt;

&lt;p&gt;frame은 Superview 좌표계의 (0, 0)으로부터 얼마만큼 떨어져 있는지(위치) + view의 크기를 나타내는 값이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Superview 좌표계의 (0, 0)은 Superview의 좌상단 꼭짓점이 아닐 수도 있다.&lt;/strong&gt; (Superview의 bounds가 변경된 경우)&lt;/p&gt;

&lt;p&gt;이 문장이 frame과 bounds를 이해하는데 핵심이 된다.&lt;/p&gt;

&lt;h2 id=&quot;bounds&quot;&gt;bounds&lt;/h2&gt;

&lt;p&gt;bounds는 view 자기 자신의 좌표계에서 원점(좌상단 꼭짓점)의 좌표값(origin의 좌표값) + view의 크기를 나타내는 값이다.&lt;/p&gt;

&lt;h2 id=&quot;frame과-bounds의-차이---그림을-통한-이해&quot;&gt;frame과 bounds의 차이 - 그림을 통한 이해&lt;/h2&gt;

&lt;p&gt;다음 코드를 이해해보자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509013223.png&quot; alt=&quot;image-20210509013221679&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;superview는 빨간색, subview는 파란색이다.&lt;/p&gt;

&lt;p&gt;주목할 점은 superview의 bouns.origin 값을 설정하는 부분이다.&lt;/p&gt;

&lt;p&gt;(-50, -50)으로 설정해준 것을 볼 수 있는데 이 말은 즉슨 빨간색 네모의 좌상단 꼭짓점의 좌표값이 (-50, -50)이라는 것이다.&lt;/p&gt;

&lt;p&gt;이제 subview가 어디에 그려질지 상상해보자면&lt;/p&gt;

&lt;p&gt;subview의 frame의 x값과 y값이 각각 0이므로 superview의 (0, 0)으로부터 (0, 0) 떨어진 위치에서부터 그려질 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509013515.png&quot; alt=&quot;simulator_screenshot_A7734F26-C68D-4995-9DCB-BE29FC951127&quot; style=&quot;zoom: 25%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;superview의 관점에서 보았을 때 빨간색 네모의 좌상단 꼭짓점의 좌표는 (-50, -50)이며&lt;/p&gt;

&lt;p&gt;파란색 네모의 좌상단 꼭짓점의 좌표가 (0, 0)에 해당하는 위치인 것이다.&lt;/p&gt;

&lt;h2 id=&quot;scrollview의-이해&quot;&gt;ScrollView의 이해&lt;/h2&gt;

&lt;p&gt;위의 내용을 이해하면 한걸음 나아가서 scroll view의 동작원리에 대해 이해할 수 있다.&lt;/p&gt;

&lt;p&gt;위의 빨간색, 파란색 네모 예제에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;superview.bounds.origin&lt;/code&gt;의 y값을 증가시키면 파란색 네모는 위쪽으로 올라간다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;superview.bounds.origin&lt;/code&gt;의 y값을 -50에서 -10으로 증가시켰을 때의 결과이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210509014113.png&quot; alt=&quot;simulator_screenshot_8A7C995E-1E78-43E8-A7DD-F4CEB0F30B0D&quot; style=&quot;zoom:25%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;빨간색 네모의 좌상단 꼭짓점의 좌표값은 (-50, -10)이 된 것이고&lt;/p&gt;

&lt;p&gt;파란색 네모의 좌상단 꼭짓점은 superview의 (0, 0)이므로 위와 같은 결과가 나온 것이다.&lt;/p&gt;

&lt;p&gt;이를 통해 ScrollView는 superview의 bounds.origin의 x값이나 y값을 스크롤하는 만큼 증가/감소시킨다는 것을 알 수 있다.&lt;/p&gt;

</description>
        <pubDate>Fri, 07 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/ios/frame-bounds-difference/</link>
        <guid isPermaLink="true">https://neph3779.github.io/ios/frame-bounds-difference/</guid>
        
        <category>frame</category>
        
        <category>bound</category>
        
        <category>origin</category>
        
        <category>center</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>2021년 05월 04일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;TDD
    &lt;ul&gt;
      &lt;li&gt;TDD의 용어에 대해 알아보고 실제 Unit Test 코드에 적용시켜보는 과정 진행&lt;/li&gt;
      &lt;li&gt;읽어본 글 : &lt;a href=&quot;https://saad-eloulladi.medium.com/unit-tests-swift-mocking-the-right-way-65488848a3fc&quot;&gt;Mock, Stub, Spy, Fake가 뭔지에 대해 Swift 코드 예제로 설명해주는 글&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CS
    &lt;ul&gt;
      &lt;li&gt;읽어본 글 : &lt;a href=&quot;https://kingofbackend.tistory.com/119?fbclid=IwAR3LZY-KEbPyL_IqWy7s1rGGf01Bkd7h2jF5RyQiPJmLH06vF8eaGKidlZg&quot;&gt;프로세스와 스레드의 차이에 대해 설명해놓은 글&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;은행창구 프로젝트
    &lt;ul&gt;
      &lt;li&gt;protocol을 사용하여 책임을 분리하는 작업 진행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 04 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.05.04-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.05.04-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>2021년 05월 03일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ARC와 Memory Structure&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;ARC는 자동으로 Reference count를 관리하는 기능&lt;/li&gt;
      &lt;li&gt;Memory Structure에는 Code, Data, Stack, Heap 영역이 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Retain Cycle과 Dead Lock&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Retain Cycle의 예시를 볼 수 있는 App (godrm님의 프로젝트) &lt;a href=&quot;https://github.com/godrm/RetainCycleApp&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;ARC 공식문서의 Strong retain cycle에 대해&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;참조타입이랑 값타입이랑 뭐가 다르지?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;retain count는 누가 관리해주지?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;retain count를 관리해주는 애들은 모두 heap에 간다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;값타입이 선호되는 이유 (성능에 왜 유리할까)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;catch문에 error를 변수로 선언해서 쓰는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://nshipster.com/swift-foundation-error-protocols/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;extension 에다가만 protocol 채택해서 쓰는것 그냥 처음부터 채택하는거랑 뭐가 다르지?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;이미 구현되어있는 애에다가 프로토콜을 주입할 수 있음 (의존성 주입)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이게 왜 되는거지?&lt;/p&gt;

    &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;mutating&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;closeBank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;totalCustomerNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;closeTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CFAbsoluteTimeGetCurrent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;spentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSpentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
          
        &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;numberOfCustomers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalCustomerNumber&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BankManagerError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failToGetTotalCustomerNumber&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
          
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;업무가 마감되었습니다. 오늘 업무를 처리한 고객은 총 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numberOfCustomers&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;명이며, 총 업무시간은 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spentTime&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;초입니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSpentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;openTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;close&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;closeTime&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BankManagerError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failToCaclulateSpentTime&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
          
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;spentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;formatTimeDuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spentTime&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;왜 try에 do - catch가 없는데도 정상 동작할까? -&amp;gt; Error Description을 자동으로 String으로 바꿔주는건가? 흠…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;setUp, tearDown을 쓰는 이유&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;메모리를 위해서&lt;/li&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;병렬성은 같은 작업을 여러개의 CPU가 동시에 하는 것&lt;/p&gt;

&lt;p&gt;우리가 하는 것은 여러개의 ‘다른’ 작업이기 때문에 동시성 프로그래밍이다 (병렬성 아님)&lt;/p&gt;

&lt;p&gt;코어가 여러개 일때만 병렬 프로그래밍이 가능하다.&lt;/p&gt;
</description>
        <pubDate>Mon, 03 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.05.03-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.05.03-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>Typora 이미지 쉽게 업로드 하기 for mac</title>
        <description>&lt;h2 id=&quot;사건의-발단&quot;&gt;사건의 발단&lt;/h2&gt;

&lt;p&gt;Typora를 통해 깃허브 블로그 글을 쓰다보면 이미지 첨부하는 작업이 매우 귀찮다고 느끼시는 분들이 많으실 것 같아요. 이미지의 상대경로를 지정해주고 깃헙 블로그 레포의 어떤 폴더에 캡쳐한 스크린샷을 담는 과정은 상당히 귀찮은 작업이죠..&lt;/p&gt;

&lt;p&gt;이러한 문제를 해결할 수 있는 방안(이미지를 링크로 변환하여 업로드)을 오늘 알려드리겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;내가-찍은-스크린샷이-weibo에-익명으로-올라가는-것을-참을-수-있어&quot;&gt;내가 찍은 스크린샷이 weibo에 익명으로 올라가는 것을 참을 수 있어!&lt;/h4&gt;

&lt;p&gt;하시는 분들은 밑의 내용을 읽으실 필요 없이&lt;/p&gt;

&lt;p&gt;Typora의 이미지 설정 부분에 가셔서 Image Uploader을 upic으로 설정해주신 뒤&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;brew install upic&lt;/code&gt; 커맨드를 통해 upic을 다운받아주시기만 하면 간단하게 해결할 수 있습니다&lt;/p&gt;

&lt;h2 id=&quot;그래서-어떻게-하면-되는데&quot;&gt;그래서 어떻게 하면 되는데?&lt;/h2&gt;

&lt;h3 id=&quot;1-typora의-언어-중국어로-변경하기&quot;&gt;1. Typora의 언어 중국어로 변경하기&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502223128.png&quot; alt=&quot;image-20210502223124947&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502223414.png&quot; alt=&quot;image-20210502223410704&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우선 Typora의 언어를 중국어로 바꾸는 것부터 시작합니다&lt;/p&gt;

&lt;p&gt;???:   🧐 웬 뜬금없이 중국어?&lt;/p&gt;

&lt;p&gt;하시는 분들이 많으실텐데 이번 포스트의 핵심이 될 Picgo가 중국어만을 지원하기 때문에 진행해야하는 작업입니다!&lt;/p&gt;

&lt;p&gt;과정이 끝난 뒤에는 다시 한국어로 설정해도 전혀 문제가 없으니 걱정하지 마세요! 😆&lt;/p&gt;

&lt;p&gt;중국어로 설정해주신 뒤 command + q를 이용해 typora를 완전 종료해줬다가 다시 켜주세요.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-picgoapp-다운로드-하기&quot;&gt;2. PicGo.app 다운로드 하기&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502223553.png&quot; alt=&quot;image-20210502223551901&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;중국어로 바꿔주셨다면 이미지 업로더의 종류에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PicGo.app&lt;/code&gt;이 추가된 것을 보실 수 있으실거에요&lt;/p&gt;

&lt;p&gt;PicGo.app은 중국어만 지원하는 앱이기 때문에 언어를 중국어로 설정했을 경우에만 노출되도록 Typora가 지정해놨습니다.&lt;/p&gt;

&lt;p&gt;이제 PicGo.app 다운로드하기 버튼을 누르셔서 (아래 하 + 어려운 한자 버튼이 다운로드 버튼입니다.)&lt;/p&gt;

&lt;p&gt;다운로드를 진행해주세요 (꼭 저 버튼을 통해 하실 필요는 없고 PicGo 깃헙으로 가셔서 dmg 파일을 받으셔도 됩니다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-github에-이미지가-저장될-repository-만들기-토큰-받아오기&quot;&gt;3. Github에 이미지가 저장될 Repository 만들기, 토큰 받아오기&lt;/h3&gt;

&lt;p&gt;이 부분의 스크린샷은 생략하도록 하겠습니다!&lt;/p&gt;

&lt;p&gt;Repo를 만들어 주시고 토큰을 받아와주세요&lt;/p&gt;

&lt;p&gt;토큰을 받아오는 과정은 &lt;a href=&quot;https://taeuk-gang.github.io/wiki/Typora%20%EC%8B%A0%EA%B8%B0%EB%8A%A5%20-%20%EC%9D%B4%EB%AF%B8%EC%A7%80%20%EC%9E%90%EB%8F%99%20%EC%97%85%EB%A1%9C%EB%93%9C/&quot;&gt;이 블로그 글&lt;/a&gt;에 잘 설명되어있으니 참고하시면 좋을 것 같습니다!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-picgoapp-설정하기&quot;&gt;4. PicGo.app 설정하기&lt;/h3&gt;

&lt;p&gt;이제부터는 제가 보여드리는 스크린샷을 그대로 따라해주시면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502223852.png&quot; alt=&quot;image-20210502223850730&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Custom에 불이 들어오도록 버튼을 눌러주세요!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210503101050.png&quot; alt=&quot;image-20210503101048818&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;톱니바퀴 모양 cell을 눌러서 이 화면에 들어와 주신 뒤&lt;/p&gt;

&lt;p&gt;제 설정대로 stepper을 On/Off 해주세요&lt;/p&gt;

&lt;p&gt;다만! 위에서 4번째에 있는 stepper을 On 해주면 이미지를 업로드 할때 매번 업로드될 이름을 정해줄 수 있어요!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210502225855.png&quot; alt=&quot;20210502225608&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;왼쪽 ScrollView에 있는 GitHub뭐시기 버튼을 눌러 이 화면에 와주신 뒤 TextField를 채워주시면 됩니다!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;첫 칸에는 본인의 깃허브 닉네임/레포이름 을 적어주세요!&lt;/p&gt;

&lt;p&gt;두번째 칸에는 저장할 레포의 어떤 브랜치에 이미지를 업로드할지 설정해주는 작업인데, 여기서 master branch가 아닌 다른 브랜치로 설정해주셔야 무분별한 commit들이 쌓이지 않습니다!&lt;/p&gt;

&lt;p&gt;사용하기로 한 깃헙 레포에 추가적인 브랜치를 만들어주세요! 저의 경우에는 master branch가 아닌 forUpload라는 이름의 브랜치에 이미지가 업로드 되도록 한 상황입니다!&lt;/p&gt;

&lt;p&gt;세번째 칸에는 아까 받아온 토큰을 넣어주시면 됩니다.&lt;/p&gt;

&lt;p&gt;네번째 칸에는 이미지의 경로를 적어주시면 되는데 repo내의 폴더라고 보시면 될 것 같아요&lt;/p&gt;

&lt;p&gt;(제가 설정한 것은 Neph3779라는 유저의 Blog-Image라는 레포의 img 폴더에 내가 찍은 스크린샷을 저장해! 가 되겠네요)&lt;/p&gt;

&lt;p&gt;이 작업이 끝나셨다면 밑의 파란색 버튼과 초록색 버튼을 눌러주시면 됩니다 (초록 버튼은 눌러지지 않을 수 있는데 문제 없어요!)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그럼 이제 드디어 타이포라에 와서 이미지를 업로드 해볼까요?&lt;/p&gt;

&lt;p&gt;(타이포라의 언어 설정은 한국어로 다시 바꿔주셔도 됩니다!)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5-typora를-통해-이미지-업로드-하기&quot;&gt;5. Typora를 통해 이미지 업로드 하기&lt;/h3&gt;

&lt;p&gt;찍은 스크린샷을 단순히 command + v로 타이포라에 붙여넣기 하면 아래의 사진처럼 내 맥북에 저장된 경로를 통해 이미지가 업로드 됩니다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502224745.png&quot; alt=&quot;image-20210502224715666&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 상태에서 사진을 우클릭 하신 뒤 Upload Image라는 버튼을 누르시면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210502225842.png&quot; alt=&quot;image-20210502224818354&quot; /&gt;&lt;/p&gt;

&lt;p&gt;짜잔 보이는것처럼 나의 깃헙 레포와 연동된 링크를 통해 이미지가 들어가는 것을 볼 수 있어요!&lt;/p&gt;

&lt;p&gt;개인적으로 이 작업을 해놓고 나니 사진을 업로드 하는게 너무나도 편해졌어요!&lt;/p&gt;

&lt;p&gt;게다가 upic은 weibo에 나의 소중한 스크린샷들이 익명으로 올라가는게 마음에 걸렸었는데&lt;/p&gt;

&lt;p&gt;이 방법을 쓰면 내 깃허브 레포에만 저장되고 이미지가 유출되지 않으니 좋은 것 같습니다&lt;/p&gt;

&lt;p&gt;Mac 사용자를 위한 튜토리얼이 없길래 글을 써봤는데 도움이 되셨으면 좋겠어요!&lt;/p&gt;
</description>
        <pubDate>Sun, 02 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9D%BC%EC%83%81/TyporaEasyImageUpload/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9D%BC%EC%83%81/TyporaEasyImageUpload/</guid>
        
        <category>Typora</category>
        
        <category>Picgo</category>
        
        
        <category>일상</category>
        
      </item>
    
      <item>
        <title>[#11] Deadlock(데드락)</title>
        <description>&lt;h2 id=&quot;교착상태deadlock&quot;&gt;교착상태(deadlock)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502181946.png&quot; alt=&quot;2&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어느 누구도 양보를 하지 않으면 더이상 진행되지 않는 상태를 deadlock(교착상태)라고 한다.&lt;/p&gt;

&lt;p&gt;Resource는 하드웨어 자원과 소프트웨어 자원을 모두 칭하는 개념으로 자신의 자원을 내놓지 않고 상대방의 자원을 서로 차지하려는 시도에 의해 deadlock 상태가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;프로세스가 자원을 사용하는 절차는 다음과 같이 이루어진다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;요청 (Request)&lt;/li&gt;
  &lt;li&gt;획득 (Allocate)&lt;/li&gt;
  &lt;li&gt;사용 (Use)&lt;/li&gt;
  &lt;li&gt;반납 (Release)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;deadlock-발생의-4가지-조건&quot;&gt;Deadlock 발생의 4가지 조건&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502182005.png&quot; alt=&quot;3&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;데드락은 다음 4가지 조건에 의해 발생한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Mutual Exclusion (상호 배제)&lt;/p&gt;

    &lt;p&gt;어떤 자원을 가지고 있는 동안에 그 자원을 독점적으로 쓴다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;No preemption (비선점)&lt;/p&gt;

    &lt;p&gt;자원을 강제로 빼앗을 수 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hold and wait (보유 대기)&lt;/p&gt;

    &lt;p&gt;자원을 가지고 있는 프로세스가 다른 자원을 기다릴 때 자신의 자원을 내놓지 않는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Circular wait (순환 대기)&lt;/p&gt;

    &lt;p&gt;자원을 기다리는 프로세스간의 cycle이 형성된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자원-할당-그래프&quot;&gt;자원 할당 그래프&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502182013.png&quot; alt=&quot;4&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Process에서 나가는 화살표는 Resource를 요청하고 있는 상태를 나타낸다.&lt;/p&gt;

&lt;p&gt;Resource에서 나가는 화살표는 해당 Resource를 Process가 보유하고 있음을 나타낸다.&lt;/p&gt;

&lt;p&gt;Resource는 하나의 Block에 여러개가 있을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502182019.png&quot; alt=&quot;5&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자원 할당 그래프(Resource Allocation Graph)를 통해 deadlock 상태인지 아닌지를 판가름할 수 있다.&lt;/p&gt;

&lt;p&gt;그래프에 cycle이 없다면 모든 경우에 deadlock이 아니다.&lt;/p&gt;

&lt;p&gt;그래프에 cycle이 있고 모든 Resouce Block에 자원이 하나씩만 있다면 반드시 deadlock 상태이다.&lt;/p&gt;

&lt;p&gt;그래프에 cycle이 있지만 모든 Resoucr Block의 자원이 하나씩만 있는 것이 아니라면 (여러개가 있는 Block이 존재한다면) deadlock일 수도 있고 아닐수도 있다. (추가적 검증 필요)&lt;/p&gt;

&lt;p&gt;참고)&lt;/p&gt;

&lt;p&gt;ppt의 왼쪽 그림은 deadlock 상태이다.&lt;/p&gt;

&lt;p&gt;ppt의 오른쪽 그림은 cycle이 형성되어있지만 deadlock 상태가 아니다.&lt;/p&gt;

&lt;h2 id=&quot;deadlock의-처리-방법&quot;&gt;Deadlock의 처리 방법&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502182024.png&quot; alt=&quot;6&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Deadlock을 해결하는 방법에는 크게 4가지가 있다. 가장 강한 처리 방법부터 약한 처리방법을 순차적으로 나열하였다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Deadlock Prevention&lt;/p&gt;

    &lt;p&gt;Deadlock의 4가지 조건 중 만족하지 않는 조건이 있도록 만드는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Deadlock Avoidance&lt;/p&gt;

    &lt;p&gt;Deadlock 발생 조건을 따져본 뒤 발생 가능성이 없는 경우에만 자원을 할당&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Deadlock Detection and recovery&lt;/p&gt;

    &lt;p&gt;Deadlock이 발생하면 해당 지점을 파악하여 recover하는 방식&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Deadlock Ignorance&lt;/p&gt;

    &lt;p&gt;OS는 deadlock에 대해 관여하지 않음. deadlock은 빈번히 발생하는 현상이 아니기 때문에 deadlock 처리 방법의 overhead를 처리하는 cost가 더 높다 판단하여 현대의 OS들은 대부분 Deadlock Ignorance를 채택하고 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;deadlock-prevention&quot;&gt;Deadlock Prevention&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502182036.png&quot; alt=&quot;7&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 4가지 조건 중 하나를 차단하면 deadlock 발생을 막을 수 있다.&lt;/p&gt;

&lt;p&gt;Mutual Exclusion은 사실상 직접 차단하는 것이 어렵다.&lt;/p&gt;

&lt;p&gt;Hold and Wait은 두 가지 방법으로 차단할 수 있는데 방법 1의 경우에는 자원의 비효율성이 높아지므로 잘 사용하지 않는다.&lt;/p&gt;

&lt;p&gt;반면 방법2는 보유 자원을 모두 내려놓은 상태에서만 자원 요청을 할 수 있게 만드는 방법이므로 자원 비효율성이 높지 않다.&lt;/p&gt;

&lt;p&gt;No Preemption의 경우 자원을 뺏었을 때 문제가 없는 구조여야만 차단할 수 있다. CPU 스케쥴링과 다르게 자원을 빼았긴 후 다시 되찾았을 때 이전 작업을 이어서 하기가 어렵기 때문이다.&lt;/p&gt;

&lt;p&gt;Circular Wait는 자원마다 번호를 매겨서 정해진 순서대로만 자원을 획득할 수 있도록 처리하면 쌍방향으로의 자원 요구가 이루어질 수 없으므로 Cycle이 생길 우려가 사라진다.&lt;/p&gt;

&lt;p&gt;하지만 위의 방법들은 자원 이용률 저하, starvation 현상 등이 발생한다.&lt;/p&gt;

&lt;h2 id=&quot;deadlock-avoidance&quot;&gt;Deadlock Avoidance&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502183735.png&quot; alt=&quot;image-20210502183734195&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Process가 시작되어 종료될 때까지 써야하는 최대의 자원량을 알고 있다고 가정한다.&lt;/p&gt;

&lt;p&gt;모든 경우의 수를 따져보고 자원 할당으로부터 안전한 경우에만 자원을 할당해준다. (자원의 여분이 있음에도)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502184158.png&quot; alt=&quot;image-20210502184152926&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자원당 하나의 instance를 가지고 있다면 자원 할당 그래프 알고리즘(deadlock 발생 여부를 찾아줌)을 이용해 막아줄 수 있고&lt;/p&gt;

&lt;p&gt;자원당 여러개의 instance를 가지고 있는 경우에는 Banker’s 알고리즘을 통해 deadlock을 막아줄 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;resource-allocation-graph-algorithm&quot;&gt;Resource Allocation Graph algorithm&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502190017.png&quot; alt=&quot;image-20210502190015537&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자원당 instance가 하나만 있는 상황에서 deadlock을 피하는 방법&lt;/p&gt;

&lt;p&gt;자원에서 프로세스로 뻗어있는 화살표는 프로세스가 해당 자원을 보유하고 있다는 의미&lt;/p&gt;

&lt;p&gt;프로세스에서 자원으로 뻗어있는 화살표는 프로세스가 해당 자원을 요청했다는 의미&lt;/p&gt;

&lt;p&gt;점선으로 이루어진 화살표는 프로세스가 평생에 거쳐 해당 자원을 요청할 가능성이 있음을 나타냄&lt;/p&gt;

&lt;p&gt;deadlock의 위험성이 있으면 자원을 주지 않고 막는다.&lt;/p&gt;

&lt;h2 id=&quot;bankers-algorithm&quot;&gt;Banker’s Algorithm&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502191103.png&quot; alt=&quot;image-20210502191101848&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502191140.png&quot; alt=&quot;image-20210502191138729&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자원당 instance가 여러개 있는 경우 Banker’s Algorithm을 적용할 수 있다.&lt;/p&gt;

&lt;p&gt;ppt의 예시는 Process가 5개 있고&lt;/p&gt;

&lt;p&gt;Resource A,B,C는 instance를 각각 10개, 5개, 7개 가지고 있다.&lt;/p&gt;

&lt;p&gt;Allocation은 현재 할당된 instance를 나타내는 것이고&lt;/p&gt;

&lt;p&gt;Max는 최대로 요청할 수 있는 (프로세스 평생에 걸쳐) instance의 수를 나타낸 것이다.&lt;/p&gt;

&lt;p&gt;현재 남아있는 자원은 Available section에 보이는 것처럼 A 3개, B 3개, C 2개인 상황에서&lt;/p&gt;

&lt;p&gt;프로세스들이 자원을 요청했을 때 처리하는 방식에 대해 알아보자&lt;/p&gt;

&lt;p&gt;현재 가용자원만 가지고도(Available) 어떤 프로세스의 Max를 충족할 수 있다면 자원을 할당해준다&lt;/p&gt;

&lt;p&gt;하지만 이것이 불가능한 경우에는 deadlock을 피하기 위해 자원을 할당해주지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502193527.png&quot; alt=&quot;image-20210502193525439&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스의 Need (현재 상태에서 최대로 요청할 수 있는 resource instance의 양)보다 Available한 자원이 더 많은 경우에만 자원을 할당해주면 deadlock을 막을 수 있다.&lt;/p&gt;

&lt;p&gt;이 때 요청한 자원의 양과 Need는 서로 다른 개념임을 기억하자.&lt;/p&gt;

&lt;p&gt;적어도 Need 이상의 양을 요청하지 않는다는 전제 때문에 가능한 상황이다.&lt;/p&gt;

&lt;h2 id=&quot;deadlock-detection&quot;&gt;Deadlock Detection&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502194954.png&quot; alt=&quot;image-20210502194952896&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Deadlock Detection은 Deadlock Avoidance와 마찬가지로 모든 Resource의 instance가 하나인 경우에는 자원 할당 그래프를 사용해 deadlock을 탐지할 수 있다.&lt;/p&gt;

&lt;p&gt;instance가 여러개인 경우에는 Banker’s algorithm과 유사한 방법으로 처리할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502195232.png&quot; alt=&quot;image-20210502195223354&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스에서 프로세스로 뻗어나간 화살표는 자원 할당 그래프를 더 간편하게 그리기 위한 방안으로 화살표의 목적지에 해당하는 프로세스가 가진 자원을 화살표의 시작지에 해당하는 프로세스가 요청하고 있음을 나타낸다.&lt;/p&gt;

&lt;p&gt;process가 n개일 때 wait for graph에서 cycle을 찾는 overhead는 O(n^2)에 해당한다.&lt;/p&gt;

&lt;p&gt;node가 n개일 때 edge의 maximum은 n(n-1)개이므로 이 edge들을 모두 다 따라가보면 O(n^2)의 시간복잡도가 걸림을 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502200422.png&quot; alt=&quot;image-20210502200419205&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 상황은 자원당 instance가 여러개인 경우를 나타낸 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502200728.png&quot; alt=&quot;image-20210502200726350&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;deadlock-recovery&quot;&gt;Deadlock Recovery&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502200920.png&quot; alt=&quot;image-20210502200918555&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Deadlock을 recover하는 방법에는 크게 두가지가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Deadlock에 연루된 process들을 없애기 (한꺼번에 kill)&lt;/li&gt;
  &lt;li&gt;Deadlock에 연루된 process들을 하나씩 없애보기 (Deadlock이 없어질때까지)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위와 같은 방식으로 safe state가 되면 다시 process를 시작하면 된다.&lt;/p&gt;

&lt;p&gt;동일한 프로세스가 계속해서 victim(process가 deadlock에 연루되어서 죽는 경우)이 되는 경우&lt;/p&gt;

&lt;p&gt;starvation 문제를 야기할 수 있으므로 이 부분도 같이 고려를 해야한다.&lt;/p&gt;
</description>
        <pubDate>Sun, 02 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/11-Deadlock/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/11-Deadlock/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>2021년 04월 29일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Allen의 동시성 프로그래밍 특강을 들었습니다. 동기/비동기에 관해서 많은 것을 알 수 있었습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위의 특강을 토대로 Step1의 수정이 이루어졌습니다. protocol에 집착하던 것을 버린 것과 Operation을 Subclassing하여 OperationQueue에 단순한 BlockOperation을 넣지 않은 점이 이전과 가장 많이 달라진 부분입니다.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/yagom-academy/ios-bank-manager/pull/33&quot;&gt;PR 링크&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;오늘의-고민내일-공부할-내용들&quot;&gt;오늘의 고민(내일 공부할 내용들)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Completion Handler v.s. return 값 있는 함수
    &lt;ul&gt;
      &lt;li&gt;왜 비동기 작업에서는 return형 함수를 쓰면 안되는가? URL Session이 비동기처리라는 것을 유념하며 생각해보자!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클로저 - 캡처리스트 이게 뭐지?&lt;/li&gt;
  &lt;li&gt;콜백 함수의 개념에 대해서&lt;/li&gt;
  &lt;li&gt;고차함수의 정의가 뭐지?&lt;/li&gt;
  &lt;li&gt;enum + CaseIterable + random enum에 random함수를 깔끔하게 넣어서 이용하는 방법이 있던 것 같은데..&lt;/li&gt;
  &lt;li&gt;struct와 mutating 등에 대해 알아봐야 할 것 같다. (class로 했을때는 문제가 없던 것이 struct로 바꾸니 결과가 원하는대로 나오질 않네..)&lt;/li&gt;
  &lt;li&gt;XCTest의 setUp, tearDown 메서드에 대해 알아보자! instance의 생명주기가 어떻게 되는거지?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;내일-알아볼-링크들&quot;&gt;내일 알아볼 링크들&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;https://agostini.tech/2017/07/30/understanding-operation-and-operationqueue-in-swift/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;https://effectivecode.tistory.com/932&lt;/li&gt;
  &lt;li&gt;https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4_%EC%8B%A0%ED%98%B8&lt;/li&gt;
  &lt;li&gt;https://jcsoohwancho.github.io/2019-11-02-Message-Dispatch/&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 29 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.29-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.29-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>2021년 04월 27일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;은행 창구 프로젝트&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;as를 통한 type casting과 initializer를 통한 타입 변환이 서로 다르단 것을 다시 한 번 인지했습니다.&lt;/p&gt;

        &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userInput&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;inputNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* input as? Int와는 전혀 다른 문법 */&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;은행창구 프로젝트에 POP를 적용하기 위해 팀원과 노력했습니다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;해당 과정은 PR메세지와 README에 기록될 것 같습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 27 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.27-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.27-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>2021년 04월 26일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;새로운 프로젝트 (은행 창구 매니저 프로젝트) 시작&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;팀 그라운드 룰 작성 및 진행방향에 대해 이야기했습니다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;Jay가 알려준 github의 issue기능을 활용하여 커밋들을 관리하기로 했습니다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;프로토콜 지향 프로그래밍을 공부해봤습니다&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/408/&quot;&gt;Protocol-Oriented Programming in Swift&lt;/a&gt; WWDC 영상을 시청했습니다.&lt;/li&gt;
          &lt;li&gt;야곰의 스위프트 프로그래밍 책의 23장(프로토콜 지향 프로그래밍)을 정독했습니다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;활동학습을 통해 CPU 스케쥴링 기법에 대해 다시 복습했습니다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;이전에 써놓았던 운영체제 정리글을 다시 한번 읽어보는 시간을 가졌습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 26 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.26-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.26-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
  </channel>
</rss>
