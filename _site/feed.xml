<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Neph's Blog</title>
    <description>Write code with my soul.</description>
    <link>https://neph3779.github.io/</link>
    <atom:link href="https://neph3779.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 02 May 2021 22:54:40 +0900</pubDate>
    <lastBuildDate>Sun, 02 May 2021 22:54:40 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Typora 이미지 쉽게 업로드 하기 for mac</title>
        <description>&lt;h2 id=&quot;사건의-발단&quot;&gt;사건의 발단&lt;/h2&gt;

&lt;p&gt;Typora를 통해 깃허브 블로그 글을 쓰다보면 이미지 첨부하는 작업이 매우 귀찮다고 느끼시는 분들이 많으실겁니다.&lt;/p&gt;

&lt;p&gt;이미지의 상대경로를 지정해주고 깃헙 블로그 레포의 어떤 폴더에 캡쳐한 스크린샷을 담는 과정은 상당히 귀찮은 작업이죠..&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이러한 문제를 해결할 수 있는 방안(이미지를 링크로 변환하여 업로드)을 오늘 알려드리겠습니다.&lt;/p&gt;

&lt;p&gt;우선 Typora의 언어를 중국어로 바꾸는 것부터 시작합니다&lt;/p&gt;

&lt;p&gt;???:   🧐 웬 뜬금없이 중국어?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이번 포스트의 핵심이 될 Picgo가 중국어만을 지원하기 때문에 진행해야하는 작업입니다&lt;/p&gt;

&lt;p&gt;과정이 끝난 뒤에는 다시 한국어로 설정해도 전혀 문제가 없으니 걱정하지 마세요 😆&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;내가-찍은-스크린샷이-weibo에-익명으로-올라가는-것을-참을-수-있어&quot;&gt;내가 찍은 스크린샷이 weibo에 익명으로 올라가는 것을 참을 수 있어!&lt;/h4&gt;

&lt;p&gt;하시는 분들은 밑의 내용을 읽으실 필요 없이&lt;/p&gt;

&lt;p&gt;Typora의 이미지 설정 부분에 가셔서 Image Uploader을 upic으로 설정해주신 뒤&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;brew install upic&lt;/code&gt; 커맨드를 통해 upic을 다운받아주시기만 하면 간단하게 해결할 수 있습니다&lt;/p&gt;

&lt;h2 id=&quot;그래서-어떻게-하면-되는데&quot;&gt;그래서 어떻게 하면 되는데?&lt;/h2&gt;

&lt;h3 id=&quot;typora의-언어-중국어로-변경하기&quot;&gt;Typora의 언어 중국어로 변경하기&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502223128.png&quot; alt=&quot;image-20210502223124947&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502223414.png&quot; alt=&quot;image-20210502223410704&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;중국어로 설정해주신 뒤 command + q를 이용해 typora를 완전 종료해줬다가 다시 켜주세요!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;picgoapp-다운로드-하기&quot;&gt;PicGo.app 다운로드 하기&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502223553.png&quot; alt=&quot;image-20210502223551901&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;중국어로 바꿔주셨다면 이미지 업로더의 종류에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PicGo.app&lt;/code&gt;이 추가된 것을 보실 수 있으실거에요&lt;/p&gt;

&lt;p&gt;PicGo.app은 중국어만 지원하는 앱이기 때문에 언어를 중국어로 설정했을 경우에만 노출되도록 Typora가 지정해놨습니다.&lt;/p&gt;

&lt;p&gt;이제 PicGo.app 다운로드하기 버튼을 누르셔서 (아래 하 + 어려운 한자 버튼이 다운로드 버튼입니다.)&lt;/p&gt;

&lt;p&gt;다운로드를 진행해주세요 (꼭 저 버튼을 통해 하실 필요는 없고 PicGo 깃헙으로 가셔서 dmg 파일을 받으셔도 됩니다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;github에-이미지가-저장될-repository-만들기-토큰-받아오기&quot;&gt;Github에 이미지가 저장될 Repository 만들기, 토큰 받아오기&lt;/h3&gt;

&lt;p&gt;이 부분의 스크린샷은 생략하도록 하겠습니다!&lt;/p&gt;

&lt;p&gt;Repo를 만들어 주시고 토큰을 받아와주세요&lt;/p&gt;

&lt;p&gt;토큰을 받아오는 과정은 &lt;a href=&quot;[https://taeuk-gang.github.io/wiki/Typora%20%EC%8B%A0%EA%B8%B0%EB%8A%A5%20-%20%EC%9D%B4%EB%AF%B8%EC%A7%80%20%EC%9E%90%EB%8F%99%20%EC%97%85%EB%A1%9C%EB%93%9C/](https://taeuk-gang.github.io/wiki/Typora 신기능 - 이미지 자동 업로드/)&quot;&gt;이 블로그 글&lt;/a&gt;에 잘 설명되어있으니 참고하시면 좋을 것 같습니다!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;picgoapp-설정하기&quot;&gt;PicGo.app 설정하기&lt;/h3&gt;

&lt;p&gt;이제부터는 제가 보여드리는 스크린샷을 그대로 따라해주시면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502223852.png&quot; alt=&quot;image-20210502223850730&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Custom에 불이 들어오도록 버튼을 눌러주세요&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502224107.png&quot; alt=&quot;image-20210502224105971&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;왼쪽처럼 GitHub뭐시기 버튼을 눌러 이 화면에 와주신 뒤&lt;/p&gt;

&lt;p&gt;첫 칸에는 본인의 깃허브 닉네임/레포이름 을 적어주시면 되고&lt;/p&gt;

&lt;p&gt;두번째 칸에는 저장할 브랜치! 설정해주시면 됩니다 (여기서 master branch가 아닌 다른 브랜치로 설정해주셔야 무분별한 commit들이 쌓이지 않아요~)&lt;/p&gt;

&lt;p&gt;세번째 칸에는 아까 받아온 토큰을 넣어주시면 됩니다.&lt;/p&gt;

&lt;p&gt;네번째 칸에는 이미지의 경로를 적어주시면 되는데 repo내의 폴더라고 보시면 될 것 같아요&lt;/p&gt;

&lt;p&gt;(제가 설정한 것은 Neph3779라는 유저의 Blog-Image라는 레포의 img 폴더에 내가 찍은 스크린샷을 저장해! 가 되겠네요)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 작업이 끝나셨다면 밑의 파란색 버튼과 초록색 버튼을 눌러주시면 됩니다 (초록 버튼은 눌러지지 않을 수 있는데 문제 없어요!)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그럼 이제 드디어 타이포라에 와서 이미지를 업로드 해볼까요?&lt;/p&gt;

&lt;p&gt;(타이포라의 언어 설정은 한국어로 다시 바꿔주셔도 됩니다!)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;이미지-업로드-하기&quot;&gt;이미지 업로드 하기&lt;/h3&gt;

&lt;p&gt;찍은 스크린샷을 단순히 command + v로 타이포라에 붙여넣기 하면 아래의 사진처럼 내 맥북에 저장된 경로를 통해 이미지가 업로드 됩니다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502224745.png&quot; alt=&quot;image-20210502224715666&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상태에서 사진을 우클릭 하신 뒤 Upload Image라는 버튼을 누르시면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application Support/typora-user-images/image-20210502224818354.png&quot; alt=&quot;image-20210502224818354&quot; /&gt;&lt;/p&gt;

&lt;p&gt;짜잔 보이는것처럼 나의 깃헙 레포와 연동된 링크를 통해 이미지가 들어가는 것을 볼 수 있어요!&lt;/p&gt;

&lt;p&gt;개인적으로 이 작업을 해놓고 나니 사진을 업로드 하는게 너무나도 편해졌어요!&lt;/p&gt;

&lt;p&gt;게다가 upic은 weibo에 나의 소중한 스크린샷들이 익명으로 올라가는게 마음에 걸렸었는데&lt;/p&gt;

&lt;p&gt;이 방법을 쓰면 내 깃허브 레포에만 저장되고 이미지가 유출되지 않으니 좋은 것 같습니다&lt;/p&gt;

&lt;p&gt;Mac 사용자를 위한 튜토리얼이 없길래 글을 써봤는데 도움이 되셨으면 좋겠어요!&lt;/p&gt;
</description>
        <pubDate>Sun, 02 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9D%BC%EC%83%81/TyporaEasyImageUpload/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9D%BC%EC%83%81/TyporaEasyImageUpload/</guid>
        
        <category>Typora</category>
        
        <category>Picgo</category>
        
        
        <category>일상</category>
        
      </item>
    
      <item>
        <title>[#11] Deadlock(데드락)</title>
        <description>&lt;h2 id=&quot;교착상태deadlock&quot;&gt;교착상태(deadlock)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502181946.png&quot; alt=&quot;2&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어느 누구도 양보를 하지 않으면 더이상 진행되지 않는 상태를 deadlock(교착상태)라고 한다.&lt;/p&gt;

&lt;p&gt;Resource는 하드웨어 자원과 소프트웨어 자원을 모두 칭하는 개념으로 자신의 자원을 내놓지 않고 상대방의 자원을 서로 차지하려는 시도에 의해 deadlock 상태가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;프로세스가 자원을 사용하는 절차는 다음과 같이 이루어진다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;요청 (Request)&lt;/li&gt;
  &lt;li&gt;획득 (Allocate)&lt;/li&gt;
  &lt;li&gt;사용 (Use)&lt;/li&gt;
  &lt;li&gt;반납 (Release)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;deadlock-발생의-4가지-조건&quot;&gt;Deadlock 발생의 4가지 조건&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502182005.png&quot; alt=&quot;3&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;데드락은 다음 4가지 조건에 의해 발생한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Mutual Exclusion (상호 배제)&lt;/p&gt;

    &lt;p&gt;어떤 자원을 가지고 있는 동안에 그 자원을 독점적으로 쓴다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;No preemption (비선점)&lt;/p&gt;

    &lt;p&gt;자원을 강제로 빼앗을 수 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hold and wait (보유 대기)&lt;/p&gt;

    &lt;p&gt;자원을 가지고 있는 프로세스가 다른 자원을 기다릴 때 자신의 자원을 내놓지 않는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Circular wait (순환 대기)&lt;/p&gt;

    &lt;p&gt;자원을 기다리는 프로세스간의 cycle이 형성된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자원-할당-그래프&quot;&gt;자원 할당 그래프&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502182013.png&quot; alt=&quot;4&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Process에서 나가는 화살표는 Resource를 요청하고 있는 상태를 나타낸다.&lt;/p&gt;

&lt;p&gt;Resource에서 나가는 화살표는 해당 Resource를 Process가 보유하고 있음을 나타낸다.&lt;/p&gt;

&lt;p&gt;Resource는 하나의 Block에 여러개가 있을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502182019.png&quot; alt=&quot;5&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자원 할당 그래프(Resource Allocation Graph)를 통해 deadlock 상태인지 아닌지를 판가름할 수 있다.&lt;/p&gt;

&lt;p&gt;그래프에 cycle이 없다면 모든 경우에 deadlock이 아니다.&lt;/p&gt;

&lt;p&gt;그래프에 cycle이 있고 모든 Resouce Block에 자원이 하나씩만 있다면 반드시 deadlock 상태이다.&lt;/p&gt;

&lt;p&gt;그래프에 cycle이 있지만 모든 Resoucr Block의 자원이 하나씩만 있는 것이 아니라면 (여러개가 있는 Block이 존재한다면) deadlock일 수도 있고 아닐수도 있다. (추가적 검증 필요)&lt;/p&gt;

&lt;p&gt;참고)&lt;/p&gt;

&lt;p&gt;ppt의 왼쪽 그림은 deadlock 상태이다.&lt;/p&gt;

&lt;p&gt;ppt의 오른쪽 그림은 cycle이 형성되어있지만 deadlock 상태가 아니다.&lt;/p&gt;

&lt;h2 id=&quot;deadlock의-처리-방법&quot;&gt;Deadlock의 처리 방법&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502182024.png&quot; alt=&quot;6&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Deadlock을 해결하는 방법에는 크게 4가지가 있다. 가장 강한 처리 방법부터 약한 처리방법을 순차적으로 나열하였다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Deadlock Prevention&lt;/p&gt;

    &lt;p&gt;Deadlock의 4가지 조건 중 만족하지 않는 조건이 있도록 만드는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Deadlock Avoidance&lt;/p&gt;

    &lt;p&gt;Deadlock 발생 조건을 따져본 뒤 발생 가능성이 없는 경우에만 자원을 할당&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Deadlock Detection and recovery&lt;/p&gt;

    &lt;p&gt;Deadlock이 발생하면 해당 지점을 파악하여 recover하는 방식&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Deadlock Ignorance&lt;/p&gt;

    &lt;p&gt;OS는 deadlock에 대해 관여하지 않음. deadlock은 빈번히 발생하는 현상이 아니기 때문에 deadlock 처리 방법의 overhead를 처리하는 cost가 더 높다 판단하여 현대의 OS들은 대부분 Deadlock Ignorance를 채택하고 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;deadlock-prevention&quot;&gt;Deadlock Prevention&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502182036.png&quot; alt=&quot;7&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 4가지 조건 중 하나를 차단하면 deadlock 발생을 막을 수 있다.&lt;/p&gt;

&lt;p&gt;Mutual Exclusion은 사실상 직접 차단하는 것이 어렵다.&lt;/p&gt;

&lt;p&gt;Hold and Wait은 두 가지 방법으로 차단할 수 있는데 방법 1의 경우에는 자원의 비효율성이 높아지므로 잘 사용하지 않는다.&lt;/p&gt;

&lt;p&gt;반면 방법2는 보유 자원을 모두 내려놓은 상태에서만 자원 요청을 할 수 있게 만드는 방법이므로 자원 비효율성이 높지 않다.&lt;/p&gt;

&lt;p&gt;No Preemption의 경우 자원을 뺏었을 때 문제가 없는 구조여야만 차단할 수 있다. CPU 스케쥴링과 다르게 자원을 빼았긴 후 다시 되찾았을 때 이전 작업을 이어서 하기가 어렵기 때문이다.&lt;/p&gt;

&lt;p&gt;Circular Wait는 자원마다 번호를 매겨서 정해진 순서대로만 자원을 획득할 수 있도록 처리하면 쌍방향으로의 자원 요구가 이루어질 수 없으므로 Cycle이 생길 우려가 사라진다.&lt;/p&gt;

&lt;p&gt;하지만 위의 방법들은 자원 이용률 저하, starvation 현상 등이 발생한다.&lt;/p&gt;

&lt;h2 id=&quot;deadlock-avoidance&quot;&gt;Deadlock Avoidance&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502183735.png&quot; alt=&quot;image-20210502183734195&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Process가 시작되어 종료될 때까지 써야하는 최대의 자원량을 알고 있다고 가정한다.&lt;/p&gt;

&lt;p&gt;모든 경우의 수를 따져보고 자원 할당으로부터 안전한 경우에만 자원을 할당해준다. (자원의 여분이 있음에도)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502184158.png&quot; alt=&quot;image-20210502184152926&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자원당 하나의 instance를 가지고 있다면 자원 할당 그래프 알고리즘(deadlock 발생 여부를 찾아줌)을 이용해 막아줄 수 있고&lt;/p&gt;

&lt;p&gt;자원당 여러개의 instance를 가지고 있는 경우에는 Banker’s 알고리즘을 통해 deadlock을 막아줄 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;resource-allocation-graph-algorithm&quot;&gt;Resource Allocation Graph algorithm&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502190017.png&quot; alt=&quot;image-20210502190015537&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자원당 instance가 하나만 있는 상황에서 deadlock을 피하는 방법&lt;/p&gt;

&lt;p&gt;자원에서 프로세스로 뻗어있는 화살표는 프로세스가 해당 자원을 보유하고 있다는 의미&lt;/p&gt;

&lt;p&gt;프로세스에서 자원으로 뻗어있는 화살표는 프로세스가 해당 자원을 요청했다는 의미&lt;/p&gt;

&lt;p&gt;점선으로 이루어진 화살표는 프로세스가 평생에 거쳐 해당 자원을 요청할 가능성이 있음을 나타냄&lt;/p&gt;

&lt;p&gt;deadlock의 위험성이 있으면 자원을 주지 않고 막는다.&lt;/p&gt;

&lt;h2 id=&quot;bankers-algorithm&quot;&gt;Banker’s Algorithm&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502191103.png&quot; alt=&quot;image-20210502191101848&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502191140.png&quot; alt=&quot;image-20210502191138729&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자원당 instance가 여러개 있는 경우 Banker’s Algorithm을 적용할 수 있다.&lt;/p&gt;

&lt;p&gt;ppt의 예시는 Process가 5개 있고&lt;/p&gt;

&lt;p&gt;Resource A,B,C는 instance를 각각 10개, 5개, 7개 가지고 있다.&lt;/p&gt;

&lt;p&gt;Allocation은 현재 할당된 instance를 나타내는 것이고&lt;/p&gt;

&lt;p&gt;Max는 최대로 요청할 수 있는 (프로세스 평생에 걸쳐) instance의 수를 나타낸 것이다.&lt;/p&gt;

&lt;p&gt;현재 남아있는 자원은 Available section에 보이는 것처럼 A 3개, B 3개, C 2개인 상황에서&lt;/p&gt;

&lt;p&gt;프로세스들이 자원을 요청했을 때 처리하는 방식에 대해 알아보자&lt;/p&gt;

&lt;p&gt;현재 가용자원만 가지고도(Available) 어떤 프로세스의 Max를 충족할 수 있다면 자원을 할당해준다&lt;/p&gt;

&lt;p&gt;하지만 이것이 불가능한 경우에는 deadlock을 피하기 위해 자원을 할당해주지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502193527.png&quot; alt=&quot;image-20210502193525439&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스의 Need (현재 상태에서 최대로 요청할 수 있는 resource instance의 양)보다 Available한 자원이 더 많은 경우에만 자원을 할당해주면 deadlock을 막을 수 있다.&lt;/p&gt;

&lt;p&gt;이 때 요청한 자원의 양과 Need는 서로 다른 개념임을 기억하자.&lt;/p&gt;

&lt;p&gt;적어도 Need 이상의 양을 요청하지 않는다는 전제 때문에 가능한 상황이다.&lt;/p&gt;

&lt;h2 id=&quot;deadlock-detection&quot;&gt;Deadlock Detection&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502194954.png&quot; alt=&quot;image-20210502194952896&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Deadlock Detection은 Deadlock Avoidance와 마찬가지로 모든 Resource의 instance가 하나인 경우에는 자원 할당 그래프를 사용해 deadlock을 탐지할 수 있다.&lt;/p&gt;

&lt;p&gt;instance가 여러개인 경우에는 Banker’s algorithm과 유사한 방법으로 처리할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502195232.png&quot; alt=&quot;image-20210502195223354&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스에서 프로세스로 뻗어나간 화살표는 자원 할당 그래프를 더 간편하게 그리기 위한 방안으로 화살표의 목적지에 해당하는 프로세스가 가진 자원을 화살표의 시작지에 해당하는 프로세스가 요청하고 있음을 나타낸다.&lt;/p&gt;

&lt;p&gt;process가 n개일 때 wait for graph에서 cycle을 찾는 overhead는 O(n^2)에 해당한다.&lt;/p&gt;

&lt;p&gt;node가 n개일 때 edge의 maximum은 n(n-1)개이므로 이 edge들을 모두 다 따라가보면 O(n^2)의 시간복잡도가 걸림을 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502200422.png&quot; alt=&quot;image-20210502200419205&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 상황은 자원당 instance가 여러개인 경우를 나타낸 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502200728.png&quot; alt=&quot;image-20210502200726350&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;deadlock-recovery&quot;&gt;Deadlock Recovery&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502200920.png&quot; alt=&quot;image-20210502200918555&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Deadlock을 recover하는 방법에는 크게 두가지가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Deadlock에 연루된 process들을 없애기 (한꺼번에 kill)&lt;/li&gt;
  &lt;li&gt;Deadlock에 연루된 process들을 하나씩 없애보기 (Deadlock이 없어질때까지)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위와 같은 방식으로 safe state가 되면 다시 process를 시작하면 된다.&lt;/p&gt;

&lt;p&gt;동일한 프로세스가 계속해서 victim(process가 deadlock에 연루되어서 죽는 경우)이 되는 경우&lt;/p&gt;

&lt;p&gt;starvation 문제를 야기할 수 있으므로 이 부분도 같이 고려를 해야한다.&lt;/p&gt;
</description>
        <pubDate>Sun, 02 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/11-Deadlock/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/11-Deadlock/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>2021년 04월 29일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Allen의 동시성 프로그래밍 특강을 들었습니다. 동기/비동기에 관해서 많은 것을 알 수 있었습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위의 특강을 토대로 Step1의 수정이 이루어졌습니다. protocol에 집착하던 것을 버린 것과 Operation을 Subclassing하여 OperationQueue에 단순한 BlockOperation을 넣지 않은 점이 이전과 가장 많이 달라진 부분입니다.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/yagom-academy/ios-bank-manager/pull/33&quot;&gt;PR 링크&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;오늘의-고민내일-공부할-내용들&quot;&gt;오늘의 고민(내일 공부할 내용들)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Completion Handler v.s. return 값 있는 함수
    &lt;ul&gt;
      &lt;li&gt;왜 비동기 작업에서는 return형 함수를 쓰면 안되는가? URL Session이 비동기처리라는 것을 유념하며 생각해보자!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클로저 - 캡처리스트 이게 뭐지?&lt;/li&gt;
  &lt;li&gt;콜백 함수의 개념에 대해서&lt;/li&gt;
  &lt;li&gt;고차함수의 정의가 뭐지?&lt;/li&gt;
  &lt;li&gt;enum + CaseIterable + random enum에 random함수를 깔끔하게 넣어서 이용하는 방법이 있던 것 같은데..&lt;/li&gt;
  &lt;li&gt;struct와 mutating 등에 대해 알아봐야 할 것 같다. (class로 했을때는 문제가 없던 것이 struct로 바꾸니 결과가 원하는대로 나오질 않네..)&lt;/li&gt;
  &lt;li&gt;XCTest의 setUp, tearDown 메서드에 대해 알아보자! instance의 생명주기가 어떻게 되는거지?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;내일-알아볼-링크들&quot;&gt;내일 알아볼 링크들&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;https://agostini.tech/2017/07/30/understanding-operation-and-operationqueue-in-swift/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;https://effectivecode.tistory.com/932&lt;/li&gt;
  &lt;li&gt;https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4_%EC%8B%A0%ED%98%B8&lt;/li&gt;
  &lt;li&gt;https://jcsoohwancho.github.io/2019-11-02-Message-Dispatch/&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 29 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.29-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.29-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>2021년 04월 27일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;은행 창구 프로젝트&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;as를 통한 type casting과 initializer를 통한 타입 변환이 서로 다르단 것을 다시 한 번 인지했습니다.&lt;/p&gt;

        &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userInput&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;inputNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* input as? Int와는 전혀 다른 문법 */&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;은행창구 프로젝트에 POP를 적용하기 위해 팀원과 노력했습니다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;해당 과정은 PR메세지와 README에 기록될 것 같습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 27 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.27-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.27-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>2021년 04월 26일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;새로운 프로젝트 (은행 창구 매니저 프로젝트) 시작&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;팀 그라운드 룰 작성 및 진행방향에 대해 이야기했습니다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;Jay가 알려준 github의 issue기능을 활용하여 커밋들을 관리하기로 했습니다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;프로토콜 지향 프로그래밍을 공부해봤습니다&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/408/&quot;&gt;Protocol-Oriented Programming in Swift&lt;/a&gt; WWDC 영상을 시청했습니다.&lt;/li&gt;
          &lt;li&gt;야곰의 스위프트 프로그래밍 책의 23장(프로토콜 지향 프로그래밍)을 정독했습니다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;활동학습을 통해 CPU 스케쥴링 기법에 대해 다시 복습했습니다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;이전에 써놓았던 운영체제 정리글을 다시 한번 읽어보는 시간을 가졌습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 26 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.26-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.26-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>[#10] 프로세스 동기화-3</title>
        <description>&lt;h2 id=&quot;bounded---buffer-problemproducer---consumer-problem&quot;&gt;Bounded - Buffer Problem(Producer - Consumer Problem)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425021405828.png&quot; alt=&quot;image-20210425021405828&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;생산자가 데이터를 공유 버퍼에 넣을때, 소비자가 공유버퍼에서 데이터를 꺼내갈 때 버퍼가 비어있거나 꽉 찬 경우에 문제가 발생할 수 있다. 이 문제는 공유데이터에 Lock을 걸었다가 풀었다가 하는 방식으로 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;이 방식을 이용하기 위해 mutex와 resource count가 사용되는데 mutex는 공유 버퍼 자체에 Lock을 걸었다 풀었다 하는 방식을 사용하기 위해 필요하며 resource count는 버퍼의 크기를 관리하기 위해 사용된다. Producer와 Consumer는 포인터 형식으로 관리되며 ppt의 그림을 통해 원형 큐의 방식으로 관리될 것임을 유추할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425022704389.png&quot; alt=&quot;image-20210425022704389&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 문제를 수도코드로 표현한 것이다.&lt;/p&gt;

&lt;p&gt;full이라는 변수는 내용이 들어있는 버퍼의 개수를 세기 위한 변수, empty는 비어있는 버퍼의 개수를 세기 위한 변수이다.&lt;/p&gt;

&lt;p&gt;버퍼에 내용을 집어넣으려는 시도를 하는 Producer는 빈 버퍼가 있는지를 먼저 확인하는 작업을 거치며&lt;/p&gt;

&lt;p&gt;V(full)을 통해 내용이 들어있는 버퍼의 개수를 증가시키는 일을 한다.&lt;/p&gt;

&lt;p&gt;Consumer는 내용이 들어있는 버퍼가 있는지를 먼저 확인한 뒤 V(empty)를 통해 비어있는 버퍼의 개수를 증가시킨다.&lt;/p&gt;

&lt;h2 id=&quot;readers-and-writers-problem&quot;&gt;Readers and Writers Problem&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425112421207.png&quot; alt=&quot;image-20210425112421207&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;쓰기 작업은 다른 process와 동시에 하면 안되지만 읽기 작업은 많은 프로세스가 동시에 시도해도 무관하다.&lt;/p&gt;

&lt;p&gt;하지만 쓰기 작업을 하면서 Lock을 거는 방식을 사용하면 단지 읽기만 하려했던 프로세스들이 공유 데이터(DB)에 접근할 수 없게되는 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425113106309.png&quot; alt=&quot;image-20210425113106309&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 코드에서 DB는 공유 데이터를 나타내며 db는 DB에 Lock을 걸기위한 semaphore 변수이다.&lt;/p&gt;

&lt;p&gt;Reader의 경우에 DB에 Writer와 같은 방식으로 Lock을 걸었다 풀었다 하는 작업을 하는 대신 (비효율적이므로)&lt;/p&gt;

&lt;p&gt;readcount라는 변수를 두어서 현재 reader의 수를 관리한다. (readcount라는 변수도 공유변수이기 때문에 mutex를 이용하여 관리한다.)&lt;/p&gt;

&lt;p&gt;만약 자신이 마지막 reader였다면 DB의 Lock을 그제서야 풀어주는 방식을 사용하는데 이러한 방식은 Writer의 Starvation 문제를 불러올 수 있다. 이러한 문제는 Timer 방식과 유사하게 해결할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;dining---philosophers-problem&quot;&gt;Dining - Philosophers Problem&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425113838761.png&quot; alt=&quot;image-20210425113838761&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;철학자가 하는 일은 생각하기, 밥먹기&lt;/p&gt;

&lt;p&gt;왼쪽과 오른쪽의 젓가락을 모두 잡아야 밥을 먹을 수 있다고 가정&lt;/p&gt;

&lt;p&gt;젓가락을 잡는 연산은 P(chopstick[i]) (왼쪽 젓가락을 잡는 작업)과 P(chopstick[i+1]%5) (오른쪽 젓가락을 잡는 작업) 으로 진행된다.&lt;/p&gt;

&lt;p&gt;위 방식의 문제점은 deadlock 현상이 발생할 수 있다는 것인데 모두가 동시에 왼쪽 젓가락을 드는 순간 그 누구도 밥을 먹을 수 없는 상황이 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425114125945.png&quot; alt=&quot;image-20210425114125945&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;deadlock 현상을 해결하기 위한 방안들&lt;/p&gt;

&lt;p&gt;4명만이 동시에 식탁에 앉도록 하여 해결&lt;/p&gt;

&lt;p&gt;모든 젓가락을 잡을 수 있음이 확실시 된 상황에서만 젓가락을 집을 수 있도록 하여 해결&lt;/p&gt;

&lt;p&gt;짝수, 홀수 번호를 구분하여 해결&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425114544075.png&quot; alt=&quot;image-20210425114544075&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;철학자 i가 실행하는 함수는 pickup, eat, putdown, think&lt;/p&gt;

&lt;p&gt;self 배열은 양쪽 젓가락을 모두 잡을 수 있는지를 판단하는 변수이다. 0이면 불가 1이면 가능 등..&lt;/p&gt;

&lt;p&gt;state를 나타내는 enum 변수는 코딩을 돕기 위해 철학자의 현재 상태를 나타낸다.&lt;/p&gt;

&lt;p&gt;state도 공유변수로 사용되므로 Lock을 걸어주는 작업이 필요하다&lt;/p&gt;

&lt;p&gt;test 함수는 젓가락을 내려놓을 때 인접한 위치의 철학자들이 젓가락 pickup을 위해 기다리고 있던 상황이라면 그 철학자가 젓가락을 얻을 수 있도록 해준다. (semaphore에 약간 어긋나는 부분이 있다.)&lt;/p&gt;

&lt;h2 id=&quot;monitor&quot;&gt;Monitor&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425114332082.png&quot; alt=&quot;image-20210425114332082&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425115642342.png&quot; alt=&quot;image-20210425115642342&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Semaphore는 여러 불편한 점들이 있는데&lt;/p&gt;

&lt;p&gt;프로그래머가 실수를 하면 안된다는 치명적인 문제를 가지고 있다&lt;/p&gt;

&lt;p&gt;한번의 실수가 시스템에 치명적이며 이러한 버그가 발생했을 때 고치기가 쉽지 않다&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해 Monitor 방식을 사용하면 이러한 문제들을 어느정도 해결할 수  있다&lt;/p&gt;

&lt;p&gt;monitor안에는 하나의 process만 monitor 내부에 들어올 수 있다&lt;/p&gt;

&lt;p&gt;monitor에 들어가있는 프로세스가 0개이거나&lt;/p&gt;

&lt;p&gt;monitor 안에 있던 프로세스가 여러 사유에 의해 condition이 만족되지 않아 wait상태가 되면 그제서야 queue에 있던 프로세스들이 하나하나 들어올 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425115147111.png&quot; alt=&quot;image-20210425115147111&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모니터는 프로그래밍 언어 차원에서 동기화 문제를 해결하는 high level 해결 방식이다.&lt;/p&gt;

&lt;p&gt;OOP에서 객체를 기반으로 변수에 접근하는 것처럼&lt;/p&gt;

&lt;p&gt;공유데이터는 외부에서 접근할 수 없고 monitor 안에서만 접근할 수 있도록 해둔 것인데 (private 함수로 monitor 내부에서만 관리)&lt;/p&gt;

&lt;p&gt;프로그램 입장에서 이런 방식을 사용하면 Lock을 거는 작업을 프로그래머가 해줄 필요가 없다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425115346199.png&quot; alt=&quot;image-20210425115346199&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;monitor 방식에서 자원의 개수를 세는 작업은 condition 변수를 사용한다&lt;/p&gt;

&lt;p&gt;condition 변수는 wait 연산과 signal 연산을 지원하는데&lt;/p&gt;

&lt;p&gt;wait 함수는 프로세스를 잠들게 하는 역할을 한다 (x, y는 조건에 해당하며 x라는 조건을 만족하지 못한 경우 x의 queue에 가서 줄을 서게 된다.)&lt;/p&gt;

&lt;p&gt;wait 상태에서 signal을 통해 깨워진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425115503129.png&quot; alt=&quot;image-20210425115503129&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;monitor에서는 Lock을 걸고 푸는 복잡한 작업이 필요하지 않다 (공유 버퍼에 들어와서 코드를 실행하는 도중에 다른 프로세스의 접근은 모니터가 막아준다.)&lt;/p&gt;

&lt;p&gt;둘 이상의 생산자나 소비자가 접근하는 문제가 발생하지 않는다.&lt;/p&gt;

&lt;p&gt;condition 변수 full은 내용이 들어있는 버퍼를 기다리며 잠들게 하는 역할을 하고 empty는 내용이 들어있는 버퍼를 기다리며 잠들게 하는 역할을 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425114448312.png&quot; alt=&quot;image-20210425114448312&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;식사하는 철학자 문제를 Semaphore가 아닌 Monitor 방식으로 바꾸어보면 다음과 같은 코드를 작성할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sun, 25 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/10-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3-%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA-3/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/10-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3-%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA-3/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>2021년 04월 22일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;UIViewController 관련 문서들 정독
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiviewcontroller/&quot;&gt;UIViewController&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457&quot;&gt;View Controller Programming Guide for iOS&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiview/positioning_content_relative_to_the_safe_area&quot;&gt;Positioning Content Relative to the Safe Area&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Delegate 관련 문서들 정독
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://magi82.github.io/ios-delegate/&quot;&gt;마기님의 delegate pattern 정리글&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 22 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.22-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.22-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>[#9] 프로세스 동기화-2</title>
        <description>&lt;h2 id=&quot;critical-section-관리-알고리즘의-발전&quot;&gt;Critical Section 관리 알고리즘의 발전&lt;/h2&gt;

&lt;h3 id=&quot;critical-section을-사용하기-위해-만족해야-하는-몇가지-조건들&quot;&gt;Critical Section을 사용하기 위해 만족해야 하는 몇가지 조건들&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Mutual Exclusion(상호 배제)
    &lt;ul&gt;
      &lt;li&gt;프로세스 P_i가 critical section 부분을 수행중이면 다른 모든 프로세스들은 그들의 critical section에 들어가면 안된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Progress(진행)
    &lt;ul&gt;
      &lt;li&gt;아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 프로세스가 있으면 critical section에 들어가게 해주어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Bounded Waiting(유한 대기)
    &lt;ul&gt;
      &lt;li&gt;프로세스가 critical section에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 critical section에 들어가는 횟수에 한계가 있어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;가정&quot;&gt;가정&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;모든 프로세스의 수행 속도는 0보다 크다.&lt;/li&gt;
  &lt;li&gt;프로세스들 간의 상대적인 수행 속도는 가정하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;알고리즘-1&quot;&gt;알고리즘 1&lt;/h3&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// code for P_0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* My turn? */&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... critical section ...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* Now it's P_1's turn */&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... remainder section ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;critical section에 들어가기 위해 본인의 차례인지 확인 (turn이라는 변수를 통해)&lt;/li&gt;
  &lt;li&gt;만약 자신의 차례가 아니라면 기다림&lt;/li&gt;
  &lt;li&gt;자신의 차례가 오면 들어가서 작업 수행, 나올 때 turn을 상대편 차례에 맞게 바꿔줌&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문제점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;critical section에 반드시 교대로 들어가야함. (나 혼자 계속 못들어감, 상대편이 안들어가주면 영원히 내 차례 안옴)&lt;/li&gt;
  &lt;li&gt;critical section에 들어가고자 하는 빈도의 차이가 있을 때 한계점이 분명함.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만족하는 조건 : Mutual Exclusion&lt;/p&gt;

&lt;p&gt;만족하지 못하는 조건: Progress, Bounded Waiting&lt;/p&gt;

&lt;h3 id=&quot;알고리즘-2&quot;&gt;알고리즘 2&lt;/h3&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... critical section ...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...remainder section&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;flag 배열로 입장 가능 여부 관리&lt;/li&gt;
  &lt;li&gt;critical section에 입장하고 싶을 때 flag[i]를 true로 바꾸고 시작함&lt;/li&gt;
  &lt;li&gt;자신의 차례가 와서 작업이 끝났다면 flag[i]를 꺼주고(false로 만들고) 나감&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문제점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;flag를 여러개 들어 놓으면 계속 기다리는 상태가 됨 (critical section에 들어가기 전에 flag를 켜고 시작하므로)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만족하는 조건 : Mutual Exclusion&lt;/p&gt;

&lt;p&gt;만족하지 못하는 조건: Progress, Bounded Waiting&lt;/p&gt;

&lt;h3 id=&quot;피터슨-알고리즘&quot;&gt;피터슨 알고리즘&lt;/h3&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... critical section ...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... remainder section ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;flag는 입장 희망 여부 배열&lt;/li&gt;
  &lt;li&gt;turn은 현재 사용중인 프로세스를 나타냄&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만족하는 조건 : Mutual Exclusion, Progress, Bounded Waiting&lt;/p&gt;

&lt;p&gt;한계 : Busy Waiting 방식이기 때문에 계속 CPU와 memory를 쓰면서 wait&lt;/p&gt;

&lt;h2 id=&quot;하드웨어적-해결&quot;&gt;하드웨어적 해결&lt;/h2&gt;

&lt;h3 id=&quot;하드웨어를-사용한-critical-section-문제해결&quot;&gt;하드웨어를 사용한 critical section 문제해결&lt;/h3&gt;

&lt;p&gt;critical section 관련 문제 발생의 이유 : 메모리에 읽는 작업 + 쓰는 작업을 하나의 instruction으로 쓸 수 없기 때문에&lt;/p&gt;

&lt;p&gt;만약 instruction 하나로 실행할 수 있다면? 문제는 쉽게 해결할 수 있음&lt;/p&gt;

&lt;h3 id=&quot;test_and_set&quot;&gt;Test_and_set&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/OS/9/1.png&quot; alt=&quot;1&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Test_and_set은 읽어오는 작업과 동시에 쓰는 작업을 실행할 수 있음 (하드웨어적 해결)&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Test_and_Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... critical section ...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... remainder section ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;semaphores를-통한-추상화&quot;&gt;Semaphores를 통한 추상화&lt;/h2&gt;

&lt;h3 id=&quot;추상-자료형-semaphore&quot;&gt;추상 자료형 Semaphore&lt;/h3&gt;

&lt;p&gt;Semaphore는 정수 변수를 가질 수 있으며 아래의 두 가지 atomic 연산에 의해서만 접근 가능&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// If positive, decrement &amp;amp; enter&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Othrewise, wait until positive (busy-wait)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;P: 공유 데이터를 획득하는 과정&lt;/p&gt;

&lt;p&gt;S: 공유 데이터를 반납하는 과정&lt;/p&gt;

&lt;h3 id=&quot;semaphore를-사용하는-이유&quot;&gt;Semaphore를 사용하는 이유&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;lock을 걸고 lock을 푸는 것을 간단하게 만들어줌&lt;/li&gt;
  &lt;li&gt;공유자원을 획득, 반납하는 과정을 내부적으로 처리해줌&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;semaphore를-통한-critical-section-문제-해결&quot;&gt;Semaphore를 통한 Critical Section 문제 해결&lt;/h3&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... critical section ...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ... remainer section ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로그래머가 일일이 코딩하지 않고 Semaphore를 이용하여 쉽게 해결할 수 있음&lt;/p&gt;

&lt;p&gt;개선 방안&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;효율적이지 못한 busy-wait(spin lock) 방식 대신 Block &amp;amp; Wakeup 방식으로 개선&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;block--wakeup-방식의-semaphore-구현&quot;&gt;Block &amp;amp; Wakeup 방식의 Semaphore 구현&lt;/h2&gt;

&lt;h3 id=&quot;semaphore-자료형의-정의&quot;&gt;Semaphore 자료형의 정의&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/OS/9/2.png&quot; alt=&quot;1&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;process&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Semaphore 때문에 잠들어있는 프로세스들을 연결시키는 큐가 생김&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;semaphore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;block()&lt;/strong&gt; 연산&lt;/p&gt;

&lt;p&gt;커널은 block을 호출한 프로세스를 suspend 시킴&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;wakeup(P)&lt;/strong&gt; 연산&lt;/p&gt;

&lt;p&gt;block 된 프로세스 P를 wakeup 시킴&lt;/p&gt;

&lt;p&gt;이 프로세스의 PCB를 ready queue로 옮김&lt;/p&gt;

&lt;h3 id=&quot;p-연산과-v-연산의-정의&quot;&gt;P 연산과 V 연산의 정의&lt;/h3&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Semaphore&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;wakeup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;busy-wait-vs-blockwakeup&quot;&gt;Busy-wait v.s. Block/wakeup&lt;/h2&gt;

&lt;h3 id=&quot;blockwakeup-방식의-단점&quot;&gt;Block/wakeup 방식의 단점&lt;/h3&gt;

&lt;p&gt;block하고 깨우는 과정에서 오버헤드가 발생함&lt;/p&gt;

&lt;h3 id=&quot;busy-wait의-단점&quot;&gt;Busy-wait의 단점&lt;/h3&gt;

&lt;p&gt;critical section의 길이가 길어지면 starvation 현상이 발생함&lt;/p&gt;

&lt;h3 id=&quot;해결방안-섞어쓰기&quot;&gt;해결방안 (섞어쓰기)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Critical section의 길이가 긴 경우에는 Block/wakeup이 적합&lt;/li&gt;
  &lt;li&gt;Critical section의 길이가 매우 짧은 경우에는 Busy-wait 방식이 적합&lt;/li&gt;
  &lt;li&gt;일반적으로는 Block/wakeup을 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;두-가지-종류의-semaphores&quot;&gt;두 가지 종류의 Semaphores&lt;/h2&gt;

&lt;h3 id=&quot;counting-semaphore&quot;&gt;Counting semaphore&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;도메인이 0 이상인 임의의 정수값&lt;/li&gt;
  &lt;li&gt;주로 resource counting에 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;binary-semaphore--mutex&quot;&gt;Binary semaphore (= mutex)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;0 또는 1 값만 가질 수 있는 semaphore&lt;/li&gt;
  &lt;li&gt;주로 mutual exclusion (lock/unlock)에 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;deadlock-and-starvation&quot;&gt;Deadlock and Starvation&lt;/h2&gt;

&lt;h3 id=&quot;deadlock-현상&quot;&gt;Deadlock 현상&lt;/h3&gt;

&lt;p&gt;둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상을 Deadlock 현상이라 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/OS/9/3.png&quot; alt=&quot;1&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 처럼 P연산이 연달아 일어나지만 실행되지 못하고 기다리는 경우&lt;/p&gt;

&lt;p&gt;V연산이 실행되지 못하기 때문에 영원히 기다리는 Deadlock 현상이 발생&lt;/p&gt;

&lt;h3 id=&quot;starvation-현상&quot;&gt;Starvation 현상&lt;/h3&gt;

&lt;p&gt;프로세스가  semaphore 큐에서 빠져나갈 수 없어서 무기한 blocking이 일어나는 경우를 Starvation 현상이라 말한다.&lt;/p&gt;

</description>
        <pubDate>Sun, 18 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/9-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3-%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA-2/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/9-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3-%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA-2/</guid>
        
        <category>OS</category>
        
        <category>운영체제</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>2021년 04월 15일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;os_log에 대해 간략히 알아봤습니다.&lt;/li&gt;
  &lt;li&gt;만국 박람회 프로젝트의 refactoring이 계속되었습니다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 15 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/2021.04.15-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/2021.04.15-TIL/</guid>
        
        
      </item>
    
      <item>
        <title>2021년 04월 13일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;시청한 영상: &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2020/10027/&quot;&gt;WWDC20 Modern cell configuration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UITableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cellForRowAt&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IndexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dequeueReusableCell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;withIdentifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;KoreanItemCell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;identifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as?&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;KoreanItemCell&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UITableViewCell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;koreanItemData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;koreanItemsData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;itemImageView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;named&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;koreanItemData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imageName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;titleLabel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;koreanItemData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shortDescriptionLabel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;koreanItemData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shortDescription&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;vs&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UITableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cellForRowAt&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IndexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UITableViewCell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;defaultContentConfiguration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;koreanItemData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;koreanItemsData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UIImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;named&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;koreanItemData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imageName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;koreanItemData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;secondaryText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;koreanItemData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shortDescription&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contentConfiguration&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Tue, 13 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.13-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.13-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
  </channel>
</rss>
