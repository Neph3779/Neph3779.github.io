<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Neph's Blog</title>
    <description>Write code with my soul.</description>
    <link>https://neph3779.github.io/</link>
    <atom:link href="https://neph3779.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 18 Jul 2021 11:34:20 +0900</pubDate>
    <lastBuildDate>Sun, 18 Jul 2021 11:34:20 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>escaping 클로저</title>
        <description>&lt;h2 id=&quot;escaping-closure를-사용하는-방법&quot;&gt;Escaping Closure를 사용하는 방법&lt;/h2&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getImages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;completionHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;UIImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;클로저의 타입 앞에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@escaping&lt;/code&gt; 키워드를 붙여주면 해당 클로저는 escaping closure로 사용할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;escaping-vs-non-escaping&quot;&gt;Escaping vs Non-Escaping&lt;/h2&gt;

&lt;p&gt;클로저를 함수 내부에서 사용할 때, 함수가 종료되었더라도 클로저가 사용될 수 있도록 해주는 키워드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@escaping&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;함수가 종료되었는데 전달인자로 받은 클로저를 실행해야되는 경우로는 아래와 같은 예시들이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;비동기 작업으로 인해 클로저가 나중에 실행되는 경우&lt;/li&gt;
  &lt;li&gt;return 값으로 다시 그 클로저를 반환하는 경우&lt;/li&gt;
  &lt;li&gt;외부 변수에 클로저를 저장해야하는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@escaping&lt;/code&gt; 키워드를 사용했지만 클로저를 밖에서 쓰지 않았다고 warning이나 error가 발생하지는 않는다. 다만 성능 개선을 위해서 가능한 경우에는 life cycle 명확한 non-escaping closure를 사용하는 것이 바람직하다.&lt;/p&gt;

&lt;h2 id=&quot;주의할-점&quot;&gt;주의할 점&lt;/h2&gt;

&lt;p&gt;Escaping closure은 함수의 전달인자로 전달하게 되는데 이 말은 클로저의 구현부는 다른 곳에 존재한다는 것이다.&lt;/p&gt;

&lt;p&gt;클로저를 구현할 때 내부에서 사용할 reference는 항상 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;weak&lt;/code&gt;으로 참조하여 사용해야한다. 이는 retain cycle을 통한 memory leak을 막기 위함이다. 보통 self를 사용하는 경우가 많으므로 클로저의 앞 부분에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[weak self]&lt;/code&gt;를 붙여줌으로써 메모리 누수를 막는다.&lt;/p&gt;

&lt;h2 id=&quot;참고한-링크&quot;&gt;참고한 링크&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;https://www.youtube.com/watch?v=xiS5gJOIQxI&amp;amp;ab_channel=SeanAllen&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 15 Jul 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/ios/WhatIsEscapingClosure/</link>
        <guid isPermaLink="true">https://neph3779.github.io/ios/WhatIsEscapingClosure/</guid>
        
        <category>closure</category>
        
        <category>escaping closure</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>App Bundle의 구조와 역할</title>
        <description>&lt;h2 id=&quot;bundle-vs-package&quot;&gt;Bundle vs Package&lt;/h2&gt;

&lt;h3 id=&quot;번들&quot;&gt;번들&lt;/h3&gt;

&lt;p&gt;알려진 것들로 이루어진 디렉토리, 실행 가능한 코드와 그 코드가 사용하는 자원들을 포함하고 있다.&lt;/p&gt;

&lt;p&gt;코드와 자원을 모으는 구조를 제공하여 개발자 경험을 향상시키는 것을 가장 우선시 하는데, 이 구조는 코드나 자원의 예측 가능한 로딩뿐만 아니라 지역화 같은 시스템 차원의 기능도 허용한다.&lt;/p&gt;

&lt;p&gt;번들은 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;앱 번들&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프레임워크 번들&lt;/code&gt;,  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Loadable 번들&lt;/code&gt;로 나눌 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;앱 번들&lt;/code&gt;은 실행될 수 있는 executable과 그 executable을 설명하는 Info.plist 파일 그리고 executable에서 사용되는 launch 이미지를 포함한 asset과 자원, 인터페이스 파일, string 파일, 데이터 파일로 이루어져 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프레임워크 번들&lt;/code&gt;은 dynamic shared library 라 불리는 동적 공유 라이브러리에서 사용되는 코드와 자원을 포함하고 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Loadable 번들&lt;/code&gt;은 앱의 기능성을 확장시켜주는 실행 가능한 코드와 자원을 포함하고 있고 플러그인이 대표적인 예시이다.&lt;/p&gt;

&lt;p&gt;번들의 컨텐츠는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bundle.main&lt;/code&gt;을 사용해서 접근할 수 있으며 대부분의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;url(forResource:withExtension:)&lt;/code&gt;메서드를 사용하여 특정 자원의 위치를 알아낼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;forResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Photo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;withExtension&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;jpg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;모든 앱 번들은 앱에 대한 정보가 담긴 Info.plist 파일을 가지며 bundleURL과 bundleIdentifier를 포함한 몇몇 메타 데이터는  아래와 같이도 접근할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;bundle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;bundle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bundleURL&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 앱의 저장위치&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bundle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bundleIdentifier&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// identifier&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;패키지&quot;&gt;패키지&lt;/h3&gt;

&lt;p&gt;파인더를 통해 봤을 때 파일처럼 보이는 디렉토리이다. 패키지는 관련있는 자원들을 하나의 유닛으로 압축시키고 연결시키는 작업을 통해 사용자 경험을 향상하기 위해 만들어졌다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디렉토리에 .app, .playground, .plugin과 같은 특별한 확장자를 가지고 있는 파일이 있는 경우&lt;/li&gt;
  &lt;li&gt;디렉토리에 document 타입으로 등록된 앱의 확장자가 존재하는 경우&lt;/li&gt;
  &lt;li&gt;디렉토리에 그 자체를 패키지로 보여지게 하는 확장된 attribute가 존재하는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 세 가지의 경우에 해당 디렉토리를 패키지라고 생각할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;정리&quot;&gt;정리&lt;/h3&gt;

&lt;p&gt;패키지는 누군가 봉인해둔 하나의 박스라면 번들은 백팩과 같은 느낌이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210711145044.svg&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;출처: https://nshipster.co.kr/bundles-and-packages/&lt;/p&gt;

&lt;h2 id=&quot;app-bundle이란&quot;&gt;App Bundle이란?&lt;/h2&gt;

&lt;p&gt;앱 번들은 개발자가 생성하는 가장 일반적인 유형의 번들로, 어플리케이션의 성공적인 작동에 필요한 모든 것들을 저장한다. 구조는 어플리케이션 플랫폼이 iOS냐 MacOS냐에 따라 다르지만, 사용하는 방법은 동일하다.&lt;/p&gt;

&lt;h2 id=&quot;앱-번들의-구성요소&quot;&gt;앱 번들의 구성요소&lt;/h2&gt;

&lt;p&gt;앱 번들에는 Info.plist, 실행파일, 리소스 파일, 기타 서포트 파일 등이 포함되어있는데 각각 아래와 같은 역할을 수행한다.&lt;/p&gt;

&lt;h3 id=&quot;infoplist&quot;&gt;Info.plist&lt;/h3&gt;

&lt;p&gt;어플리케이션에 대한 구성 정보가 들어있는 구조화된 파일로, 시스템은 이 파일에 의존하여 어플리케이션 및 파일에 대한 관련 정보를 식별한다.&lt;/p&gt;

&lt;h3 id=&quot;실행파일&quot;&gt;실행파일&lt;/h3&gt;

&lt;p&gt;모든 응용 프로그램에 존재하는 실행파일로 어플리케이션의 메인 entry point와 어플리케이션 타겟에 정적으로 연결된 모든 코드가 포함되어 있다.&lt;/p&gt;

&lt;h3 id=&quot;리소스-파일&quot;&gt;리소스 파일&lt;/h3&gt;

&lt;p&gt;리소스는 어플리케이션의 실행 파일 외부에 있는 데이터 파일이다. 리소스는 일반적으로 이미지, 아이콘, 소리, nib파일, 문자열 파일, 설정 파일 및 데이터 파일 등으로 구성된다. 대부분 localized될 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;기타-서포트-파일&quot;&gt;기타 서포트 파일&lt;/h3&gt;

&lt;p&gt;커스텀 데이터 리소스 등이 포함 되어있다.&lt;/p&gt;

&lt;p&gt;iOS의 번들 구조를 이해하면 사용자 지정 파일을 저장할 위치를 결정하는데 도움이 된다. iOS 어플의 번들 구조는 모바일 장치에 적합하게 이루어져 있다. 외부 디렉토리가 거의 없는 평평한 구조를 사용하여 디스크 공간을 절약하고 파일에 대한 접근과정을 간소화한다.&lt;/p&gt;

&lt;h2 id=&quot;참고한-링크&quot;&gt;참고한 링크&lt;/h2&gt;

&lt;p&gt;https://nshipster.co.kr/bundles-and-packages/&lt;/p&gt;

&lt;p&gt;https://melod-it.gitbook.io/sagwa/documentation-archive/bundle-programming-guide/bundle-structures&lt;/p&gt;

&lt;p&gt;https://ios-development.tistory.com/339&lt;/p&gt;

&lt;p&gt;https://hcn1519.github.io/articles/2018-12/bundle&lt;/p&gt;

&lt;p&gt;https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/AboutBundles/AboutBundles.html#//apple_ref/doc/uid/10000123i-CH100-SW1&lt;/p&gt;

&lt;p&gt;https://woongsios.tistory.com/92&lt;/p&gt;

&lt;p&gt;https://developer.apple.com/documentation/foundation/bundle&lt;/p&gt;

&lt;p&gt;https://www.notion.so/App-Bundle-650ff04e917c4ef4980237d4f68f09a3&lt;/p&gt;

&lt;p&gt;https://github.com/jwonyLee/TIL/blob/master/iOS/Interview/AppBundle.md&lt;/p&gt;
</description>
        <pubDate>Sun, 11 Jul 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/ios/WhatIsAppBundle/</link>
        <guid isPermaLink="true">https://neph3779.github.io/ios/WhatIsAppBundle/</guid>
        
        <category>iOS</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>UIViewController</title>
        <description>&lt;h2 id=&quot;uiviewcontroller의-역할&quot;&gt;UIViewController의 역할&lt;/h2&gt;

&lt;p&gt;View Controller는 앱 내부 구조의 기반으로 모든 앱은 최소 하나 이상의 뷰컨트롤러를 가진다. 뷰컨트롤러는 UI, 인터페이스, 데이터간의 상호작용을 맡으며 UI간의 전환에도 도움을 준다.&lt;/p&gt;

&lt;h3 id=&quot;view의-계층-관리&quot;&gt;View의 계층 관리&lt;/h3&gt;

&lt;p&gt;각각의 View Controller는 View의 계층을 관리한다. 이 계층의 가장 근원이 되는 것이 root view이며 모든 view controller는 한개의 root view를 가진다.&lt;/p&gt;

&lt;h3 id=&quot;view와-관련된-notification-관리&quot;&gt;View와 관련된 Notification 관리&lt;/h3&gt;

&lt;p&gt;ViewController 객체는 UIView 객체들의 생성, 소멸, 이벤트 발생 등을 관리한다. View는 나타나기 직전, 나타난 후, 사라지기 직전, 사라진 후 4단계에 걸쳐서 UIViewController에게 내용을 전달한다.&lt;/p&gt;

&lt;h3 id=&quot;user-interaction-처리&quot;&gt;User Interaction 처리&lt;/h3&gt;

&lt;p&gt;뷰컨트롤러는 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/Responder.html#//apple_ref/doc/uid/TP40009071-CH1&quot;&gt;responder objects&lt;/a&gt;로서 responder chain으로부터 내려오는 이벤트를 핸들링할 수 있지만 일반적으로 터치 이벤트를 직접 핸들링하지 않고 뷰가 대신 이벤트를 감지하여 델리게이트나 타겟 오브젝트(일반적으로 뷰컨트롤러)에 보고한다.&lt;/p&gt;

&lt;p&gt;따라서 대부분의 뷰컨트롤러에 대한 이벤트는 델리게이트 메서드나 액션 메서드(&lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html#//apple_ref/doc/uid/TP40009071-CH3&quot;&gt;action methods&lt;/a&gt;) 로 핸들링된다.&lt;/p&gt;

&lt;h3 id=&quot;viewcontroller의-두-가지-종류&quot;&gt;ViewController의 두 가지 종류&lt;/h3&gt;

&lt;p&gt;View Controller는 두 가지 종류로 구분되는데 하나는 content view controller로 앱의 컨텐츠를 관리하는 기본 타입, 다른 하나는 컨테이너 뷰컨트롤러로 다른 뷰컨트롤러를 관리하는 뷰컨트롤러이다.&lt;/p&gt;

&lt;h3 id=&quot;view-management&quot;&gt;View Management&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210711192638.png&quot; alt=&quot;image: ../Art/VCPG_ControllerHierarchy_fig_1-1_2x.png&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/th&gt;
      &lt;th&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210711192908.png&quot; alt=&quot;image: ../Art/VCPG_ContainerViewController_fig_1-2_2x.png&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;뷰 컨트롤러의 가장 중요한 역할을 뷰 계층을 관리하는 것이다. 뷰컨트롤러는 모든 컨텐트를 감싸는 루트뷰를 갖고 있으며 디스플레이하고 싶은 다른 뷰를 추가할 수 있다. 뷰컨트롤러는 언제나 루트뷰의 레퍼런스를 소유하고 각 뷰는 서브뷰들의 스트롱 레퍼런스(strong references) 를 소유한다.&lt;/p&gt;

&lt;p&gt;뷰컨트롤러의 뷰계층에서 다른 뷰에 접근하려면 아웃렛(&lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/Outlet.html#//apple_ref/doc/uid/TP40009071-CH4&quot;&gt;outlets&lt;/a&gt;) 이 일반적인 방법이다. 뷰컨트롤러는 모든 뷰의 컨텐트를 관리하고 아웃렛은 뷰에 대한 레퍼런스를 저장한다. 아웃렛은 뷰가 스토리보드에 로드될 때 자동으로 실제 뷰 오브젝트에 연결된다.&lt;/p&gt;

&lt;p&gt;컨텐트 뷰컨트롤러는 속한 모든 뷰를 직접 관리한다. 컨테이너 뷰컨트롤러는 직접 소유한 뷰와 차일드 뷰컨트롤러의 루트뷰를 관리한다. 컨테이너는 자식뷰의 컨텐트를 관리하지 않으며 오직 컨테이너의 디자인에 따라 루트뷰의 사이즈와 위치 등을 관리한다. 아래 스플릿 뷰컨트롤러(split view controller) 는 차일드뷰의 사이즈와 포지션을 관리하지만 차일드 뷰컨트롤러는 실제 컨텐츠를 관리한다.&lt;/p&gt;

&lt;h3 id=&quot;data-marshing-데이터-중계&quot;&gt;Data Marshing (데이터 중계)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210711194741.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;뷰컨트롤러는 관리하는 뷰와 데이터간의 중계자 역할을 수행한다. &lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiviewcontroller&quot;&gt;UIViewController&lt;/a&gt; 의 메서드와 프로프터로 앱의 비주얼을 관리할 수 있고 서브클래스의 데이터를 관리할 수 있는 변수를 추가할 수 있다. 커스텀 변수를 추가하는 것은 아래 그림과 같은 관계를 만들어 내는데, 뷰컨트롤러는 데이터와 그것을 나타내는 뷰의 레퍼런스를 소유한다.&lt;/p&gt;

&lt;p&gt;개발자는 뷰컨트롤러와 데이터 오브젝트간의 책임을 명확하게 분리해야 한다. 뷰컨트롤러는 뷰로부터 얻는 인풋을 검증하고 데이터 오브젝트가 필요로 하는 포맷으로 패키징한다. 하지만 실제 데이터를 관리함에 있어서 뷰컨트롤러의 역할은 최소화되어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uidocument&quot;&gt;UIDocument&lt;/a&gt; 오브젝트는 데이터를 뷰컨트롤러로부터 분리하여 관리하는 방법중 한가지이다. 그것은 컨트롤러 오브젝트로서 데이터를 영구 저장소로부터 읽고 쓰는 방법을 알고 있다. 서브클래싱하면 데이터를 추출하고 전달하는 로직이나 메서드를 추가할 수 있다. 뷰컨트롤러는 뷰의 업데이트가 용이하도록 데이터의 복사본을 저장하지만 도큐먼트를 원본데이터를 소유한다.&lt;/p&gt;

&lt;h3 id=&quot;resource-관리&quot;&gt;Resource 관리&lt;/h3&gt;

&lt;p&gt;뷰컨트롤러는 자신 위에 올라오는 모든 뷰들을 관리한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;didReceiveMemoryWarning&lt;/code&gt; 메서드를 통해서 메모리 워닝이 발생했는지를 체크하고 뷰를 삭제함으로써 메모리 공간을 확보한다.&lt;/p&gt;

&lt;p&gt;View Controller의&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본 데이터의 변경에 대한 응답으로 뷰의 콘텐츠를 업데이트&lt;/li&gt;
  &lt;li&gt;뷰와 사용자 상호 작용에 응답&lt;/li&gt;
  &lt;li&gt;뷰 크기 조정 및 전체 인터페이스의 레이아웃 관리&lt;/li&gt;
  &lt;li&gt;앱에서 다른 뷰 컨트롤러를 포함한 다른 객체와 조정&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;adaptivity-관리&quot;&gt;Adaptivity 관리&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210711195332.png&quot; alt=&quot;image: ../Art/VCPG_SizeClassChanges_fig_1-4_2x.png&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;뷰컨트롤러는 속한 뷰의 환경에 따라 적응을 한다. iOS앱은 아이패드나 여러가지 아이폰에서 실행이 가능하다. 여러개의 뷰컨트롤러로 개별 기기를 지원하기보다는 하나의 뷰컨트롤러만 가지고 뷰의 사이즈를 조절한다. 뷰컨트롤러의 traits, size class(compact, regular)가 바뀌면 그에 맞게 컨텐츠를 배치해준다.&lt;/p&gt;

&lt;h2 id=&quot;참고한-링크&quot;&gt;참고한 링크&lt;/h2&gt;

&lt;p&gt;https://ahyeonlog.tistory.com/17&lt;/p&gt;

&lt;p&gt;https://sibalja.tistory.com/25&lt;/p&gt;

&lt;p&gt;http://www.appleofeyes.com/role-view-controllers-xcode-%EC%97%91%EC%8A%A4%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-%EB%B7%B0%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC%EC%9D%98-%EC%97%AD%ED%95%A0/&lt;/p&gt;
</description>
        <pubDate>Sun, 11 Jul 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/ios/WhatDoesViewControllerDo/</link>
        <guid isPermaLink="true">https://neph3779.github.io/ios/WhatDoesViewControllerDo/</guid>
        
        <category>UIResponder</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>App Life Cycle</title>
        <description>&lt;h2 id=&quot;app-life-cycle&quot;&gt;App Life Cycle&lt;/h2&gt;

&lt;h3 id=&quot;앱의-시작&quot;&gt;앱의 시작&lt;/h3&gt;

&lt;p&gt;iOS는 C언어 기반을 토대로 작동하기 때문에 앱이 시작되면 가장 처음으로 main 함수가 불린다. main 함수는 UIKit framework이 관리하며 UIApplication 객체를 생성한다. 이를 통해 개발자는 앱의 실행에 부분적으로 관여할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;main-run-loop&quot;&gt;Main Run Loop&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210711155954.PNG&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이벤트의 처리 과정은 다음과 같이 정리할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;유저가 이벤트를 발생시킨다.&lt;/li&gt;
  &lt;li&gt;시스템을 통해 이벤트가 생성된다.&lt;/li&gt;
  &lt;li&gt;UIKit에 의해 생성된 Port가 이벤트를 이벤트 큐에 삽입한다.&lt;/li&gt;
  &lt;li&gt;이벤트 큐의 이벤트가 하나씩 Main Run Loop에 매핑된다.&lt;/li&gt;
  &lt;li&gt;UIApplication instance는 이벤트를 전달받을 객체를 선정한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;앱의-상태-변화&quot;&gt;앱의 상태 변화&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210711160214.PNG&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/th&gt;
      &lt;th&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210711160423.png&quot; alt=&quot;123540849-04b7c100-d77c-11eb-9b13-a08e8daf0ed9&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;not-running&quot;&gt;Not Running&lt;/h3&gt;

&lt;p&gt;말 그대로 앱을 실행하지 않은 상태이다. 이 시점에 호출되는 메서드는 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623032-application&quot;&gt;application(_:willFinishLaunchingWithOptions:)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;앱 실행을 준비하는 메서드로 필요한 주요 객체들을 생성, 앱 실행 준비가 끝나기 직전에 호출된다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622921-application&quot;&gt;application(_:didFinishLaunchingWithOptions:)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;앱 실행을 위한 모든 준비가 끝난 후 화면이 사용자에게 보여지기 직전에 호출되는 메서드로, 초기화 코드를 이곳에 작성한다.&lt;/p&gt;

&lt;p&gt;이 메서드의 return value가 반환된 이후, 다른 app delegate의 메서드가 실행되어 forground state로 진입한다.&lt;/p&gt;

&lt;p&gt;launch option을 사용할 수 있는 마지막 장소이다.&lt;/p&gt;

&lt;p&gt;애플에서는 다음과 같은 당부를 전달한다. (didFinish.. 메서드 대신  willFinish.. 메서드를 이용할 것을 권장한다는 내용)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Important&lt;/p&gt;

  &lt;p&gt;For app initialization, it is highly recommended that you use this method and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application(_:willFinishLaunchingWithOptions:)&lt;/code&gt; method and do not use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applicationDidFinishLaunching(_:)&lt;/code&gt; method, which is intended only for apps that run on older versions of iOS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623111-applicationwillterminate&quot;&gt;applicationWillTerminate(_:)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;앱이 종료되기 직전에 호출되는 메서드로 app의 task를 clean-up하거나 공유 자원의 free, user data의 저장, timer의 초기화 등의 작업을 위한 코드를 이곳에 작성한다.&lt;/p&gt;

&lt;p&gt;다만 메모리 확보를 위해 suspended 상태에 있는 앱이 종료되는 경우, background 상태에서 사용자에 의해 종료되는 경우, 오류로 인해 앱이 종료되는 경우에 이 메서드는 호출되지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;inactive&quot;&gt;InActive&lt;/h3&gt;

&lt;p&gt;앱이 실행되면서 foreground에 진입하거나 foreground에서 background로 이동하는 시점. 어떠한 이벤트도 받지 않는 상태이며 다음과 같은 메서드들이 호출된다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623076-applicationwillenterforeground&quot;&gt;sceneWillEnterForeground(&lt;em&gt;:)](https://developer.apple.com/documentation/uikit/uiscenedelegate/3197918-scenewillenterforeground) or  [applicationWillEnterForeground(&lt;/em&gt;:)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;앱이 실행되며 foreground에 진입하기 직전 호출되는 메서드이다.&lt;/p&gt;

&lt;p&gt;전자의 메서드가 호출되는 경우는 UISceneDelegate이 구현되어있는 경우이다. 만약 전자의 메서드가 호출되었다면 후자는 호출되지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622950-applicationwillresignactive&quot;&gt;sceneWillResignActive(&lt;em&gt;:)](https://developer.apple.com/documentation/uikit/uiscenedelegate/3197919-scenewillresignactive) or  [applicationWillResignActive(&lt;/em&gt;:)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;앱이 background로 진입하기 직전 호출되는 메서드이다. 위의 경우와 마찬가지로 UISceneDelegate의 구현여부에 따라 호출될 메서드가 결정된다.&lt;/p&gt;

&lt;p&gt;홈화면으로 이동하는 경우, 화면이 앱 실행 도중 잠기는 경우, 다른 앱으로 이동한 경우 등의 상황에서 앱은 background로 진입하게 되며&lt;/p&gt;

&lt;p&gt;멀티윈도우 상태, 알림센터나 제어센터를 보는 경우 등의 상황에서는 InActive 상태를 유지한채로 있는다.&lt;/p&gt;

&lt;h3 id=&quot;active&quot;&gt;Active&lt;/h3&gt;

&lt;p&gt;앱이 실행중이며 foreground에 있고 이벤트를 받고 있는 상태&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622956-applicationdidbecomeactive&quot;&gt;sceneDidBecomeActive(&lt;em&gt;:)](https://developer.apple.com/documentation/uikit/uiscenedelegate/3197915-scenedidbecomeactive) or [applicationDidBecomeActive(&lt;/em&gt;:)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위의 메서드에서 content를 refresh하거나 frame rate를 올리는 등의 작업을 실행해줄 수 있다. (실행될 메서드는 UISceneDelegate 구현 여부에 따라 결정됨)&lt;/p&gt;

&lt;h3 id=&quot;background&quot;&gt;Background&lt;/h3&gt;

&lt;p&gt;앱이 background에 있으며 다른 앱으로 전환되었거나 홈 버튼을 통해 밖으로 나갔을 때의 상태&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiscenedelegate/3197917-scenedidenterbackground?language=objc&quot;&gt;sceneDidEnterBackground(_:)&lt;/a&gt; or &lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622997-applicationdidenterbackground?language=objc&quot;&gt;applicationDidEnterBackground:&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;suspended&quot;&gt;Suspended&lt;/h3&gt;

&lt;p&gt;background에서 특별한 작업이 없을 경우 전환되는 상태&lt;/p&gt;

&lt;h2 id=&quot;참고한-링크&quot;&gt;참고한 링크&lt;/h2&gt;

&lt;p&gt;https://hcn1519.github.io/articles/2017-09/ios_app_lifeCycle&lt;/p&gt;

&lt;p&gt;https://fomaios.tistory.com/entry/%EC%95%B1-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0App-LifeCycle-1&lt;/p&gt;

&lt;p&gt;https://nsios.tistory.com/60&lt;/p&gt;

</description>
        <pubDate>Sun, 11 Jul 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/ios/AppLifeCycle/</link>
        <guid isPermaLink="true">https://neph3779.github.io/ios/AppLifeCycle/</guid>
        
        <category>app life cycle</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>접근 제어자의 종류</title>
        <description>&lt;h2 id=&quot;module이란&quot;&gt;Module이란?&lt;/h2&gt;

&lt;p&gt;접근제어에 대해 이해하기 위해서는 모듈의 개념에 대해 알아야한다.&lt;/p&gt;

&lt;p&gt;모듈은 코드의 묶음 단위로 프레임워크, 라이브러리, 어플리케이션처럼 배포할 코드들의 묶음을 나타낸다. 즉, 하나의 프레임워크는 하나의 모듈이고 일반적으로 만드는 프로젝트도 역시 하나의 모듈이다. import를 통해 모듈을 사용할 수 있다. 프로젝트 하위에 위치한 target들도 하나의 모듈에 해당한다.&lt;/p&gt;

&lt;h2 id=&quot;access-level&quot;&gt;Access Level&lt;/h2&gt;

&lt;h3 id=&quot;open&quot;&gt;open&lt;/h3&gt;

&lt;p&gt;다른 모듈에서 사용할 수 있음을 넘어 sub classing까지도 가능한 접근제어자&lt;/p&gt;

&lt;h3 id=&quot;public&quot;&gt;public&lt;/h3&gt;

&lt;p&gt;프로젝트 내의 모든 module의 entity에 접근할 수 있는 접근제어자&lt;/p&gt;

&lt;h3 id=&quot;internal&quot;&gt;internal&lt;/h3&gt;

&lt;p&gt;default값으로 지정되어있는 접근제어자로 entity가 작성된 module에서만 접근할 수 있는 접근제어자&lt;/p&gt;

&lt;h3 id=&quot;fileprivate&quot;&gt;fileprivate&lt;/h3&gt;

&lt;p&gt;entity가 작성된 source file내에서만 접근할 수 있는 접근제어자&lt;/p&gt;

&lt;h3 id=&quot;private&quot;&gt;private&lt;/h3&gt;

&lt;p&gt;특정 객체에서만 사용할 수 있도록 지정한 가장 제한적인 접근제어자&lt;/p&gt;

&lt;h2 id=&quot;기타&quot;&gt;기타&lt;/h2&gt;

&lt;h3 id=&quot;제한적-setter-private-setter&quot;&gt;제한적 setter (private setter)&lt;/h3&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;private(set)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;fileprivate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;과 같은 문법을 적용할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;접근제어자간의-충돌&quot;&gt;접근제어자간의 충돌&lt;/h3&gt;

&lt;p&gt;public으로 선언되어있는 객체의 멤버는 open으로 선언될 수 없다.&lt;/p&gt;

&lt;p&gt;즉, 바깥의 접근제어 수준보다 높은 수준의 내부 요소는 존재할 수 없다.&lt;/p&gt;

&lt;p&gt;특정 접근 제어 수준의 타입이 함수의 매개변수나 반환되는 타입일 경우 함수는 해당 값의 접근제어보다 높을 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;참고한-링크&quot;&gt;참고한 링크&lt;/h2&gt;

&lt;p&gt;https://hcn1519.github.io/articles/2018-01/Swift_AccessControl&lt;/p&gt;

&lt;p&gt;https://baked-corn.tistory.com/80&lt;/p&gt;
</description>
        <pubDate>Sun, 11 Jul 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/ios/AccessControlmd/</link>
        <guid isPermaLink="true">https://neph3779.github.io/ios/AccessControlmd/</guid>
        
        <category>접근 제어 지정자</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>[#2] 당근마켓 화면 분석-1</title>
        <description>&lt;h2 id=&quot;당근마켓-클론코딩을-목표로-하는-화면&quot;&gt;당근마켓 클론코딩을 목표로 하는 화면&lt;/h2&gt;

&lt;h3 id=&quot;내-근처-탭&quot;&gt;“내 근처” 탭&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210708192923.jpeg&quot; alt=&quot;IMG_6FB09D3842B8-1&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210708193047.jpeg&quot; alt=&quot;IMG_00AAE9892BE6-1&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210708193101.jpeg&quot; alt=&quot;IMG_711A55BD70C1-1&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;화면의-구성-및-특징&quot;&gt;화면의 구성 및 특징&lt;/h2&gt;

&lt;h3 id=&quot;기본구성&quot;&gt;기본구성&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;UITabBarController를 활용하여 5개의 탭을 사용하고 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;UINavigationController가 UITabBarController 바로 위에 위치하고 있다.&lt;/li&gt;
  &lt;li&gt;Seach Bar를 포함하고 있는 부분(header view)과 아래의 부분(collection view)이 명확히 구분되어있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;새로고침-화면&quot;&gt;새로고침 화면&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210708215402.jpeg&quot; alt=&quot;IMG_D4988E27B7B6-1&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210708215504.jpeg&quot; alt=&quot;IMG_EBFDD6618D93-1&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;새로고침 화면 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;새로고침 화면 2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;화면을 아래로 당기면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;새로고침&lt;/code&gt;이 실행된다.&lt;/p&gt;

&lt;p&gt;&lt;del&gt;이 때 화면을 잡아당기는 정도에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;주황색 로딩 인디케이터&lt;/code&gt;가 서서히 채워지는데 이 로딩 인디케이터가 모두 채워질 정도로 잡아당겨야 비로소 새로고침이 된다.&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;(화면 1에서는 아직 로딩 인디케이터가 다 채워지지 않아서 저 상태에서 손을 떼면 새로고침이 이루어지지 않고 화면 2처럼 끝까지 당겨야 새로고침이 이루어진다.)&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;로딩 인디케이터가 채워지는 것과 관계없이 아주 빠르게 드래그를 하는 경우에도 새로고침이 이루어진다.&lt;/p&gt;

&lt;h4 id=&quot;새로고침이-되지-않는-경우&quot;&gt;새로고침이 되지 않는 경우&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210708215745.jpeg&quot; alt=&quot;IMG_888B81AE5527-1&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;새로고침이 정상적으로 이루어지지 않는 모습&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;어떨 때에는 화면을 밑으로 당겨도 새로고침이 제대로 이루어지지 않는다. 어떤 조건에 의해 새로고침이 이루어지는지 파악이 필요해보인다.&lt;/p&gt;

&lt;h3 id=&quot;로딩-화면&quot;&gt;로딩 화면&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210708193305.jpeg&quot; alt=&quot;IMG_6AFE4DD1C6F6-1&quot; style=&quot;zoom:33%;&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;로딩 화면&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;로딩시에는 placeholder를 통해 화면에 나타날 것들의 위치를 미리 표시해준다.&lt;/p&gt;

&lt;p&gt;특이한 점은 collection view의 첫번째 section으로 추정되는 위치에는 저렇게 placeholder가 들어있지만 두번째 section부터의 placeholder는 나타나지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;navigationbar&quot;&gt;NavigationBar&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;th&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210708221822.png&quot; alt=&quot;image-20210708221803474&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210709001155.png&quot; alt=&quot;image-20210708221909760&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그림 1&lt;/code&gt;은 기본 navigation bar의 모습이다.&lt;/p&gt;

&lt;p&gt;collection view의 두번째 section이 표시되는 순간부터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그림 2&lt;/code&gt;에서 보이는 것처럼 돋보기 모양 아이콘이 추가된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210709001210.png&quot; alt=&quot;image-20210708222019028&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;검색 화면&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;검색 화면은 다음과 같이 구성되어있다. 최근 검색한 내용이 캐시데이터로 저장되는 모양이고, 추천 검색어는 더이상 좌우 스크롤을 통해 확인하는 형태가 아닌 하나의 section에 스크롤 없이 담겨있는 모습이다.&lt;/p&gt;
</description>
        <pubDate>Thu, 08 Jul 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%B7%A8%EC%97%85%EC%A4%80%EB%B9%84/PrepareToJoinDanggn-2/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%B7%A8%EC%97%85%EC%A4%80%EB%B9%84/PrepareToJoinDanggn-2/</guid>
        
        <category>취업준비</category>
        
        <category>당근마켓 인턴</category>
        
        
        <category>취업준비</category>
        
      </item>
    
      <item>
        <title>[#1] 당근마켓 iOS인턴 준비</title>
        <description>&lt;h2 id=&quot;당근마켓-인턴-지원-계획&quot;&gt;당근마켓 인턴 지원 계획&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;클론코딩 + 포트폴리오 준비기간은 4주로 한다. (0708 ~ 0808)&lt;/li&gt;
  &lt;li&gt;프로젝트를 진행하며 지금까지 배웠던 기본들에 대해 다시 정리하며 진행한다.&lt;/li&gt;
  &lt;li&gt;외부 라이브러리는 사용하지 않되, 이러한 라이브러리를 왜 사용하는지, 사용했을 때의 장점은 무엇인지, 단점은 무엇인지, 당근마켓에서 단점을 극복한 사례나 후기가 있는지 등에 대해 조사한다.&lt;/li&gt;
  &lt;li&gt;모든 코드는 testable하게 짜는것을 목표로 진행한다.&lt;/li&gt;
  &lt;li&gt;mock data를 data asset등을 통해 활용하여 1차적으로 프로젝트를 진행하되, 이번 project manager 프로젝트에서 배운 vapor를 활용해 간단한 서버를 구축하고, 그 서버와 통신하는 내용을 구성하는 것을 최종 목표로 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1주차-목표-0708--0714&quot;&gt;1주차 목표 (0708 ~ 0714)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;당근마켓 앱을 분석하는 것을 시작으로 한다. 당근마켓의 화면 구성, 접근성 등에 대해 분석한 뒤 화면을 구성할 계획을 세운다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UICollectionView에 대해 더 깊게 공부해서 화면의 각 영역마다 어떤식의 구성방법을 사용할 것인지에 대해 결정한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2주차-목표&quot;&gt;2주차 목표&lt;/h3&gt;

&lt;p&gt;미정&lt;/p&gt;

&lt;h3 id=&quot;3주차-목표&quot;&gt;3주차 목표&lt;/h3&gt;

&lt;p&gt;미정&lt;/p&gt;

&lt;h3 id=&quot;4주차-목표&quot;&gt;4주차 목표&lt;/h3&gt;

&lt;p&gt;미정&lt;/p&gt;

&lt;h2 id=&quot;당근마켓-최소지원-버전-ios-120&quot;&gt;당근마켓 최소지원 버전 iOS 12.0&lt;/h2&gt;

&lt;h3 id=&quot;최소-지원-ios-120-이상의-의미&quot;&gt;최소 지원 iOS 12.0 이상의 의미&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Diffable Datasource등을 사용할 수 없다.&lt;/li&gt;
  &lt;li&gt;Scene Session을 사용할 수 없다.&lt;/li&gt;
  &lt;li&gt;추가 예정&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 08 Jul 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%B7%A8%EC%97%85%EC%A4%80%EB%B9%84/PrepareToJoinDanggn-1/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%B7%A8%EC%97%85%EC%A4%80%EB%B9%84/PrepareToJoinDanggn-1/</guid>
        
        <category>취업준비</category>
        
        <category>당근마켓 인턴</category>
        
        
        <category>취업준비</category>
        
      </item>
    
      <item>
        <title>UIWindow의 역할</title>
        <description>&lt;h2 id=&quot;uiwindow란&quot;&gt;UIWindow란?&lt;/h2&gt;

&lt;p&gt;UIWindow는 UIView의 하위 클래스로 앱의 배경과 이벤트를 View로 전달하는 객체이다.&lt;/p&gt;

&lt;p&gt;눈에 보이는 내용은 없지만 앱의 View에 기본 컨테이너를 제공하여 하며 rootViewController에서 관리하는 하나 이상의 View를 보여주는 역할을 한다.&lt;/p&gt;

&lt;p&gt;또한 터치 이벤트를 View와 다른 어플리케이션 객체들에게 전달하는데, 터치 이벤트는 발생한 window로 전달되지만, 좌표값이 없는 이벤트는 키보드 이벤트, 터치와 관련되지 않은 이벤트를 받는 window인 key window로 전달된다.&lt;/p&gt;

&lt;p&gt;key window는 하나의 window로만 구성되며, isKeyWindow 프로퍼티를 이용해 key window인지 아닌지를 알 수 있다. 대부분 app의 메인 windonw가 key window이다.&lt;/p&gt;

&lt;p&gt;iOS 12 까지는 하나의 window만 사용할 수 있었지만 iOS 13부터는 Scene Delegate을 활용해 여러개의 window들을 사용할 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;Window는 foreground일 때뿐만 아니라 background일 때도 사용해야한다. foreground일때는 makeKeyAndVisible() 메서드를 통해 window를 보여주고 해당 window를 key window로 만들어준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210704150620.png&quot; alt=&quot;?scode=mtistory2&amp;amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FGqjjH%2FbtqNF9btI9V%2FOnIOQkbfrEwDZEEu7m80Gk%2Fimg&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;window-객체를-만드는-경우--방법&quot;&gt;window 객체를 만드는 경우 &amp;amp; 방법&lt;/h2&gt;

&lt;h3 id=&quot;만드는-경우&quot;&gt;만드는 경우&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;스토리보드를 사용하지 않는 경우에 main window를 직접 생성해야 한다.&lt;/li&gt;
  &lt;li&gt;외부 디스플레이를 사용하는 경우 새로운 window를 만들어서 보여줄 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;만드는-방법&quot;&gt;만드는 방법&lt;/h3&gt;

&lt;p&gt;메인 window 객체는 코드와 인터페이스 빌더 중 하나로 생성할 수 있다. 이 때 lazily create을 통해 필요할 때 생성되도록 해야한다.&lt;/p&gt;

&lt;p&gt;AppDelegate나 SceneDelegate에서 UIWindow의 instance(window)를 프로퍼티로 넣어준 뒤 window의 rootViewController를 설정해주면 된다.&lt;/p&gt;

&lt;h2 id=&quot;uiwindow를-상속받아-사용하는-경우&quot;&gt;UIWindow를 상속받아 사용하는 경우&lt;/h2&gt;

&lt;p&gt;매우 드문일이지만 위의 메서드를 재정의해서 사용하고 싶은 경우 UIWindow의 subclass를 제작할 수 있다. becomeKey()나 resignKey()에 추가적인 동작을 명시하는 것이 대부분이다.&lt;/p&gt;

&lt;h4 id=&quot;참고한-링크&quot;&gt;참고한 링크&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;https://wnstkdyu.github.io/2017/12/29/uiwindow/&lt;/li&gt;
  &lt;li&gt;https://zeddios.tistory.com/283&lt;/li&gt;
  &lt;li&gt;https://developer.apple.com/documentation/uikit/uiwindow&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;왜-uiwindow는-uiview의-subclass일까&quot;&gt;왜 UIWindow는 UIView의 subclass일까?&lt;/h3&gt;

&lt;p&gt;https://stackoverflow.com/questions/830785/why-is-uiwindow-a-child-and-also-a-parent-of-uview&lt;/p&gt;

</description>
        <pubDate>Sun, 04 Jul 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/WhatIsUIWindow/</link>
        <guid isPermaLink="true">https://neph3779.github.io/WhatIsUIWindow/</guid>
        
        
      </item>
    
      <item>
        <title>하나의 ViewController에 여러개의 TableView 쓰기</title>
        <description>&lt;h2 id=&quot;table-view&quot;&gt;Table View&lt;/h2&gt;

&lt;p&gt;우선 테이블뷰를 사용하기 위해서는 아래의 작업들이 필요하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cell 등록 (register)&lt;/li&gt;
  &lt;li&gt;datasource, delegate 지정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;cell register는 각각의 tableView 마다 register를 해주면 되기에 문제가 되지 않는다. (스토리보드를 사용한다면 cell을 자동으로 등록해주기 때문에 register cell을 직접적으로 해주지 않아도 된다.)&lt;/p&gt;

&lt;p&gt;하나의 뷰 컨트롤러에서 여러개의 tableView를 쓸 때 가장 문제인건 datasource와 delegate 메서드를 공유한다는 점이다. 이를 해결하기 위해선 아래와 같이 메서드 내에서의 분기를 통해 해결할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UITableView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cellForRowAt&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;indexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IndexPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UITableViewCell&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tableView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tableView1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tableView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tableView2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 04 Jul 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/UseMultipleTableViewInOneViewController/</link>
        <guid isPermaLink="true">https://neph3779.github.io/UseMultipleTableViewInOneViewController/</guid>
        
        
      </item>
    
      <item>
        <title>스토리보드의 장단점</title>
        <description>&lt;h2 id=&quot;스토리보드의-장점&quot;&gt;스토리보드의 장점&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;빠른 초기화&lt;/li&gt;
  &lt;li&gt;시각화&lt;/li&gt;
  &lt;li&gt;낮은 진입장벽&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;개발 환경에서 화면이 직접 눈에 보인다는게 최대 장점이다. 아무리 가독성 좋은 코드로 UI를 만든다한들 직접 실행해보지 않고도 화면을 정확하게 떠올리는 것은 쉽지않다. 하지만 스토리보드를 통해서는 이것이 가능하다.&lt;/p&gt;

&lt;p&gt;또한 View를 만드는 시간이 적게 걸린다고 한다. (사실 이건 잘 모르겠다. 큰 차이는 안날 것 같은데..)&lt;/p&gt;

&lt;p&gt;그리고 마지막 장점은 진입장벽이 낮다는 점이다! 사실 나도 iOS 개발을 처음 시작하게 된 계기가 스토리보드를 보고서였다. 저런 것도 있구나 싶었다. (C만 해봤던 나에겐 신세계였다..)&lt;/p&gt;

&lt;h2 id=&quot;스토리보드의-단점&quot;&gt;스토리보드의 단점&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;긴 로딩시간&lt;/li&gt;
  &lt;li&gt;유지보수, 재사용의 어려움&lt;/li&gt;
  &lt;li&gt;Merge Conflict 해결 매우 어려움&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;앱이 커지다보면 스토리보드의 로딩시간이 매우~ 길어진다. 단순히 로딩시간을 기다리면 해결되는 문제라고 하기엔 개발자에게 있어서 작업효율과 시간이란 중요한 것이기 때문에 무시할 수 없는 부분 중 하나이다.&lt;/p&gt;

&lt;p&gt;또한 유지보수, 재사용이 매우 어렵다. 눈에 보이지 않는 수많은 constraint들과 코드가 아닌 스토리보드에서 지정해준 속성값들을 수정하기란 매우 어려운 일이다.&lt;/p&gt;

&lt;p&gt;게다가 한 스토리보드 파일을 두 명 이상이 작업하다 conflict가 발생하면 xml파일로 이루어진 스토리보드 파일을 손봐야하는데 이보다 끔찍한건 있을 수 없다.&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Jul 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/ios/StoryboardProsAndCons/</link>
        <guid isPermaLink="true">https://neph3779.github.io/ios/StoryboardProsAndCons/</guid>
        
        <category>storyboard</category>
        
        
        <category>iOS</category>
        
      </item>
    
  </channel>
</rss>
