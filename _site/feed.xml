<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Neph's Blog</title>
    <description>Write code with my soul.</description>
    <link>https://neph3779.github.io/</link>
    <atom:link href="https://neph3779.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 07 May 2021 16:27:57 +0900</pubDate>
    <lastBuildDate>Fri, 07 May 2021 16:27:57 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Frame과 Bounds의 차이</title>
        <description>&lt;h2 id=&quot;frame&quot;&gt;Frame&lt;/h2&gt;

&lt;p&gt;Frame은 SuperView의 좌표시스템 안에서의 View의 위치와 크기이다.&lt;/p&gt;

&lt;p&gt;frame은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SuperView의 origin&lt;/code&gt;을 기준으로 움직이며 여기서 origin은 SuperView의 좌상단 꼭짓점이다.&lt;/p&gt;

&lt;p&gt;일반적인 좌표계와 달리 원점이 좌상단 꼭짓점이며 x에 대한 양의 방향은 오른쪽, y에 대한 양의 방향은 아래쪽이다.&lt;/p&gt;

&lt;h2 id=&quot;bounds&quot;&gt;Bounds&lt;/h2&gt;

&lt;p&gt;Bounds는 어떤 View가 지닌 origin의 위치이다.&lt;/p&gt;

&lt;p&gt;기본값은 (0,0)이며 Bounds를 조절하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SubView의 위치&lt;/code&gt;가 변하게 된다.&lt;/p&gt;

&lt;p&gt;이는 SubView의 위치가 SuperView의 origin을 기준으로 결정되기 때문이다.&lt;/p&gt;

&lt;p&gt;다시 말해 Bounds를 바꿔주면 SuperView의 위치는 그대로 둔 채로 SubView의 위치만 변경된다.&lt;/p&gt;

&lt;p&gt;이는 ScrollView의 핵심이 되는데 ScrollView의 Bounds의 y좌표나 x좌표를 양수로 주게 되면 어떤 일이 일어날지 상상해보자.&lt;/p&gt;

&lt;p&gt;ScrollView의 origin을 기준으로 Content가 표시되고 있는 상황에서 origin의 좌표가 바뀌었다면 SubView의 상대적인 위치가 변경되어야 할 것임을 쉽게 유추해볼 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;그림을-통한-이해&quot;&gt;그림을 통한 이해&lt;/h2&gt;

&lt;p&gt;그림을 통해 이해를 해보자&lt;/p&gt;

&lt;p&gt;그림의 출처는 항상 좋은 글들로 도움을 주시는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zedd&lt;/code&gt;님 &lt;a href=&quot;https://zeddios.tistory.com/203&quot;&gt;원문 글 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210507122232.png&quot; alt=&quot;image-20210507122231343&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Content View는 저 광활한 그림 전체다.&lt;/p&gt;

&lt;p&gt;현재 Content View의 frame은 (0,0)이며&lt;/p&gt;

&lt;p&gt;Scroll View의 bounds도 (0,0)이다. (지금 이 문장이 이해가 가지 않는다면 위에 써놓은 설명을 찬찬히 다시 읽어보자)&lt;/p&gt;

&lt;p&gt;만약 여기서 Scroll View의 bounds를 (300, 500)으로 바꿔주면 어떤 상황이 될까?&lt;/p&gt;

&lt;p&gt;Scroll View의 origin이 (0, 0)에서 (300, 500)으로 변경될 것이고&lt;/p&gt;

&lt;p&gt;이로 인해 SuperView의 origin을 기준으로 표시되던 Content View의 위치도 변경될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210507122714.png&quot; alt=&quot;image-20210507122713275&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;바로 이렇게 말이다.&lt;/p&gt;

&lt;h2 id=&quot;추가적으로-생각해볼-것들&quot;&gt;추가적으로 생각해볼 것들&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ScrollView의 frame 값을 바꾸면 어떤 일이 일어날까?
    &lt;ul&gt;
      &lt;li&gt;ScrollView의 SuperView는 누구일까?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Content View의 frame 값을 바꾸면 어떤 일이 일어날까?&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 07 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/ios/frame-bounds-difference/</link>
        <guid isPermaLink="true">https://neph3779.github.io/ios/frame-bounds-difference/</guid>
        
        <category>frame</category>
        
        <category>bound</category>
        
        <category>origin</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>2021년 05월 04일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;TDD
    &lt;ul&gt;
      &lt;li&gt;TDD의 용어에 대해 알아보고 실제 Unit Test 코드에 적용시켜보는 과정 진행&lt;/li&gt;
      &lt;li&gt;읽어본 글 : &lt;a href=&quot;https://saad-eloulladi.medium.com/unit-tests-swift-mocking-the-right-way-65488848a3fc&quot;&gt;Mock, Stub, Spy, Fake가 뭔지에 대해 Swift 코드 예제로 설명해주는 글&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CS
    &lt;ul&gt;
      &lt;li&gt;읽어본 글 : &lt;a href=&quot;https://kingofbackend.tistory.com/119?fbclid=IwAR3LZY-KEbPyL_IqWy7s1rGGf01Bkd7h2jF5RyQiPJmLH06vF8eaGKidlZg&quot;&gt;프로세스와 스레드의 차이에 대해 설명해놓은 글&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;은행창구 프로젝트
    &lt;ul&gt;
      &lt;li&gt;protocol을 사용하여 책임을 분리하는 작업 진행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 04 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.05.04-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.05.04-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>2021년 05월 03일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ARC와 Memory Structure&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;ARC는 자동으로 Reference count를 관리하는 기능&lt;/li&gt;
      &lt;li&gt;Memory Structure에는 Code, Data, Stack, Heap 영역이 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Retain Cycle과 Dead Lock&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Retain Cycle의 예시를 볼 수 있는 App (godrm님의 프로젝트) &lt;a href=&quot;https://github.com/godrm/RetainCycleApp&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;ARC 공식문서의 Strong retain cycle에 대해&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;참조타입이랑 값타입이랑 뭐가 다르지?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;retain count는 누가 관리해주지?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;retain count를 관리해주는 애들은 모두 heap에 간다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;값타입이 선호되는 이유 (성능에 왜 유리할까)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;catch문에 error를 변수로 선언해서 쓰는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://nshipster.com/swift-foundation-error-protocols/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;extension 에다가만 protocol 채택해서 쓰는것 그냥 처음부터 채택하는거랑 뭐가 다르지?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;이미 구현되어있는 애에다가 프로토콜을 주입할 수 있음 (의존성 주입)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이게 왜 되는거지?&lt;/p&gt;

    &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;mutating&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;closeBank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;totalCustomerNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;closeTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;CFAbsoluteTimeGetCurrent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;spentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSpentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
          
        &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;numberOfCustomers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalCustomerNumber&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BankManagerError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failToGetTotalCustomerNumber&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
          
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;업무가 마감되었습니다. 오늘 업무를 처리한 고객은 총 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numberOfCustomers&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;명이며, 총 업무시간은 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spentTime&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;초입니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSpentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;openTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;close&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;closeTime&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BankManagerError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failToCaclulateSpentTime&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
          
        &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;spentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;formatTimeDuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spentTime&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;왜 try에 do - catch가 없는데도 정상 동작할까? -&amp;gt; Error Description을 자동으로 String으로 바꿔주는건가? 흠…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;setUp, tearDown을 쓰는 이유&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;메모리를 위해서&lt;/li&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;병렬성은 같은 작업을 여러개의 CPU가 동시에 하는 것&lt;/p&gt;

&lt;p&gt;우리가 하는 것은 여러개의 ‘다른’ 작업이기 때문에 동시성 프로그래밍이다 (병렬성 아님)&lt;/p&gt;

&lt;p&gt;코어가 여러개 일때만 병렬 프로그래밍이 가능하다.&lt;/p&gt;
</description>
        <pubDate>Mon, 03 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.05.03-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.05.03-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>Typora 이미지 쉽게 업로드 하기 for mac</title>
        <description>&lt;h2 id=&quot;사건의-발단&quot;&gt;사건의 발단&lt;/h2&gt;

&lt;p&gt;Typora를 통해 깃허브 블로그 글을 쓰다보면 이미지 첨부하는 작업이 매우 귀찮다고 느끼시는 분들이 많으실 것 같아요. 이미지의 상대경로를 지정해주고 깃헙 블로그 레포의 어떤 폴더에 캡쳐한 스크린샷을 담는 과정은 상당히 귀찮은 작업이죠..&lt;/p&gt;

&lt;p&gt;이러한 문제를 해결할 수 있는 방안(이미지를 링크로 변환하여 업로드)을 오늘 알려드리겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;내가-찍은-스크린샷이-weibo에-익명으로-올라가는-것을-참을-수-있어&quot;&gt;내가 찍은 스크린샷이 weibo에 익명으로 올라가는 것을 참을 수 있어!&lt;/h4&gt;

&lt;p&gt;하시는 분들은 밑의 내용을 읽으실 필요 없이&lt;/p&gt;

&lt;p&gt;Typora의 이미지 설정 부분에 가셔서 Image Uploader을 upic으로 설정해주신 뒤&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;brew install upic&lt;/code&gt; 커맨드를 통해 upic을 다운받아주시기만 하면 간단하게 해결할 수 있습니다&lt;/p&gt;

&lt;h2 id=&quot;그래서-어떻게-하면-되는데&quot;&gt;그래서 어떻게 하면 되는데?&lt;/h2&gt;

&lt;h3 id=&quot;1-typora의-언어-중국어로-변경하기&quot;&gt;1. Typora의 언어 중국어로 변경하기&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502223128.png&quot; alt=&quot;image-20210502223124947&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502223414.png&quot; alt=&quot;image-20210502223410704&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우선 Typora의 언어를 중국어로 바꾸는 것부터 시작합니다&lt;/p&gt;

&lt;p&gt;???:   🧐 웬 뜬금없이 중국어?&lt;/p&gt;

&lt;p&gt;하시는 분들이 많으실텐데 이번 포스트의 핵심이 될 Picgo가 중국어만을 지원하기 때문에 진행해야하는 작업입니다!&lt;/p&gt;

&lt;p&gt;과정이 끝난 뒤에는 다시 한국어로 설정해도 전혀 문제가 없으니 걱정하지 마세요! 😆&lt;/p&gt;

&lt;p&gt;중국어로 설정해주신 뒤 command + q를 이용해 typora를 완전 종료해줬다가 다시 켜주세요.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-picgoapp-다운로드-하기&quot;&gt;2. PicGo.app 다운로드 하기&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502223553.png&quot; alt=&quot;image-20210502223551901&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;중국어로 바꿔주셨다면 이미지 업로더의 종류에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PicGo.app&lt;/code&gt;이 추가된 것을 보실 수 있으실거에요&lt;/p&gt;

&lt;p&gt;PicGo.app은 중국어만 지원하는 앱이기 때문에 언어를 중국어로 설정했을 경우에만 노출되도록 Typora가 지정해놨습니다.&lt;/p&gt;

&lt;p&gt;이제 PicGo.app 다운로드하기 버튼을 누르셔서 (아래 하 + 어려운 한자 버튼이 다운로드 버튼입니다.)&lt;/p&gt;

&lt;p&gt;다운로드를 진행해주세요 (꼭 저 버튼을 통해 하실 필요는 없고 PicGo 깃헙으로 가셔서 dmg 파일을 받으셔도 됩니다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-github에-이미지가-저장될-repository-만들기-토큰-받아오기&quot;&gt;3. Github에 이미지가 저장될 Repository 만들기, 토큰 받아오기&lt;/h3&gt;

&lt;p&gt;이 부분의 스크린샷은 생략하도록 하겠습니다!&lt;/p&gt;

&lt;p&gt;Repo를 만들어 주시고 토큰을 받아와주세요&lt;/p&gt;

&lt;p&gt;토큰을 받아오는 과정은 &lt;a href=&quot;https://taeuk-gang.github.io/wiki/Typora%20%EC%8B%A0%EA%B8%B0%EB%8A%A5%20-%20%EC%9D%B4%EB%AF%B8%EC%A7%80%20%EC%9E%90%EB%8F%99%20%EC%97%85%EB%A1%9C%EB%93%9C/&quot;&gt;이 블로그 글&lt;/a&gt;에 잘 설명되어있으니 참고하시면 좋을 것 같습니다!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-picgoapp-설정하기&quot;&gt;4. PicGo.app 설정하기&lt;/h3&gt;

&lt;p&gt;이제부터는 제가 보여드리는 스크린샷을 그대로 따라해주시면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502223852.png&quot; alt=&quot;image-20210502223850730&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Custom에 불이 들어오도록 버튼을 눌러주세요!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210503101050.png&quot; alt=&quot;image-20210503101048818&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;톱니바퀴 모양 cell을 눌러서 이 화면에 들어와 주신 뒤&lt;/p&gt;

&lt;p&gt;제 설정대로 stepper을 On/Off 해주세요&lt;/p&gt;

&lt;p&gt;다만! 위에서 4번째에 있는 stepper을 On 해주면 이미지를 업로드 할때 매번 업로드될 이름을 정해줄 수 있어요!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210502225855.png&quot; alt=&quot;20210502225608&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;왼쪽 ScrollView에 있는 GitHub뭐시기 버튼을 눌러 이 화면에 와주신 뒤 TextField를 채워주시면 됩니다!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;첫 칸에는 본인의 깃허브 닉네임/레포이름 을 적어주세요!&lt;/p&gt;

&lt;p&gt;두번째 칸에는 저장할 레포의 어떤 브랜치에 이미지를 업로드할지 설정해주는 작업인데, 여기서 master branch가 아닌 다른 브랜치로 설정해주셔야 무분별한 commit들이 쌓이지 않습니다!&lt;/p&gt;

&lt;p&gt;사용하기로 한 깃헙 레포에 추가적인 브랜치를 만들어주세요! 저의 경우에는 master branch가 아닌 forUpload라는 이름의 브랜치에 이미지가 업로드 되도록 한 상황입니다!&lt;/p&gt;

&lt;p&gt;세번째 칸에는 아까 받아온 토큰을 넣어주시면 됩니다.&lt;/p&gt;

&lt;p&gt;네번째 칸에는 이미지의 경로를 적어주시면 되는데 repo내의 폴더라고 보시면 될 것 같아요&lt;/p&gt;

&lt;p&gt;(제가 설정한 것은 Neph3779라는 유저의 Blog-Image라는 레포의 img 폴더에 내가 찍은 스크린샷을 저장해! 가 되겠네요)&lt;/p&gt;

&lt;p&gt;이 작업이 끝나셨다면 밑의 파란색 버튼과 초록색 버튼을 눌러주시면 됩니다 (초록 버튼은 눌러지지 않을 수 있는데 문제 없어요!)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그럼 이제 드디어 타이포라에 와서 이미지를 업로드 해볼까요?&lt;/p&gt;

&lt;p&gt;(타이포라의 언어 설정은 한국어로 다시 바꿔주셔도 됩니다!)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5-typora를-통해-이미지-업로드-하기&quot;&gt;5. Typora를 통해 이미지 업로드 하기&lt;/h3&gt;

&lt;p&gt;찍은 스크린샷을 단순히 command + v로 타이포라에 붙여넣기 하면 아래의 사진처럼 내 맥북에 저장된 경로를 통해 이미지가 업로드 됩니다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502224745.png&quot; alt=&quot;image-20210502224715666&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 상태에서 사진을 우클릭 하신 뒤 Upload Image라는 버튼을 누르시면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20210502225842.png&quot; alt=&quot;image-20210502224818354&quot; /&gt;&lt;/p&gt;

&lt;p&gt;짜잔 보이는것처럼 나의 깃헙 레포와 연동된 링크를 통해 이미지가 들어가는 것을 볼 수 있어요!&lt;/p&gt;

&lt;p&gt;개인적으로 이 작업을 해놓고 나니 사진을 업로드 하는게 너무나도 편해졌어요!&lt;/p&gt;

&lt;p&gt;게다가 upic은 weibo에 나의 소중한 스크린샷들이 익명으로 올라가는게 마음에 걸렸었는데&lt;/p&gt;

&lt;p&gt;이 방법을 쓰면 내 깃허브 레포에만 저장되고 이미지가 유출되지 않으니 좋은 것 같습니다&lt;/p&gt;

&lt;p&gt;Mac 사용자를 위한 튜토리얼이 없길래 글을 써봤는데 도움이 되셨으면 좋겠어요!&lt;/p&gt;
</description>
        <pubDate>Sun, 02 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9D%BC%EC%83%81/TyporaEasyImageUpload/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9D%BC%EC%83%81/TyporaEasyImageUpload/</guid>
        
        <category>Typora</category>
        
        <category>Picgo</category>
        
        
        <category>일상</category>
        
      </item>
    
      <item>
        <title>[#11] Deadlock(데드락)</title>
        <description>&lt;h2 id=&quot;교착상태deadlock&quot;&gt;교착상태(deadlock)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502181946.png&quot; alt=&quot;2&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어느 누구도 양보를 하지 않으면 더이상 진행되지 않는 상태를 deadlock(교착상태)라고 한다.&lt;/p&gt;

&lt;p&gt;Resource는 하드웨어 자원과 소프트웨어 자원을 모두 칭하는 개념으로 자신의 자원을 내놓지 않고 상대방의 자원을 서로 차지하려는 시도에 의해 deadlock 상태가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;프로세스가 자원을 사용하는 절차는 다음과 같이 이루어진다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;요청 (Request)&lt;/li&gt;
  &lt;li&gt;획득 (Allocate)&lt;/li&gt;
  &lt;li&gt;사용 (Use)&lt;/li&gt;
  &lt;li&gt;반납 (Release)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;deadlock-발생의-4가지-조건&quot;&gt;Deadlock 발생의 4가지 조건&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502182005.png&quot; alt=&quot;3&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;데드락은 다음 4가지 조건에 의해 발생한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Mutual Exclusion (상호 배제)&lt;/p&gt;

    &lt;p&gt;어떤 자원을 가지고 있는 동안에 그 자원을 독점적으로 쓴다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;No preemption (비선점)&lt;/p&gt;

    &lt;p&gt;자원을 강제로 빼앗을 수 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hold and wait (보유 대기)&lt;/p&gt;

    &lt;p&gt;자원을 가지고 있는 프로세스가 다른 자원을 기다릴 때 자신의 자원을 내놓지 않는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Circular wait (순환 대기)&lt;/p&gt;

    &lt;p&gt;자원을 기다리는 프로세스간의 cycle이 형성된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자원-할당-그래프&quot;&gt;자원 할당 그래프&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502182013.png&quot; alt=&quot;4&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Process에서 나가는 화살표는 Resource를 요청하고 있는 상태를 나타낸다.&lt;/p&gt;

&lt;p&gt;Resource에서 나가는 화살표는 해당 Resource를 Process가 보유하고 있음을 나타낸다.&lt;/p&gt;

&lt;p&gt;Resource는 하나의 Block에 여러개가 있을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502182019.png&quot; alt=&quot;5&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자원 할당 그래프(Resource Allocation Graph)를 통해 deadlock 상태인지 아닌지를 판가름할 수 있다.&lt;/p&gt;

&lt;p&gt;그래프에 cycle이 없다면 모든 경우에 deadlock이 아니다.&lt;/p&gt;

&lt;p&gt;그래프에 cycle이 있고 모든 Resouce Block에 자원이 하나씩만 있다면 반드시 deadlock 상태이다.&lt;/p&gt;

&lt;p&gt;그래프에 cycle이 있지만 모든 Resoucr Block의 자원이 하나씩만 있는 것이 아니라면 (여러개가 있는 Block이 존재한다면) deadlock일 수도 있고 아닐수도 있다. (추가적 검증 필요)&lt;/p&gt;

&lt;p&gt;참고)&lt;/p&gt;

&lt;p&gt;ppt의 왼쪽 그림은 deadlock 상태이다.&lt;/p&gt;

&lt;p&gt;ppt의 오른쪽 그림은 cycle이 형성되어있지만 deadlock 상태가 아니다.&lt;/p&gt;

&lt;h2 id=&quot;deadlock의-처리-방법&quot;&gt;Deadlock의 처리 방법&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502182024.png&quot; alt=&quot;6&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Deadlock을 해결하는 방법에는 크게 4가지가 있다. 가장 강한 처리 방법부터 약한 처리방법을 순차적으로 나열하였다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Deadlock Prevention&lt;/p&gt;

    &lt;p&gt;Deadlock의 4가지 조건 중 만족하지 않는 조건이 있도록 만드는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Deadlock Avoidance&lt;/p&gt;

    &lt;p&gt;Deadlock 발생 조건을 따져본 뒤 발생 가능성이 없는 경우에만 자원을 할당&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Deadlock Detection and recovery&lt;/p&gt;

    &lt;p&gt;Deadlock이 발생하면 해당 지점을 파악하여 recover하는 방식&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Deadlock Ignorance&lt;/p&gt;

    &lt;p&gt;OS는 deadlock에 대해 관여하지 않음. deadlock은 빈번히 발생하는 현상이 아니기 때문에 deadlock 처리 방법의 overhead를 처리하는 cost가 더 높다 판단하여 현대의 OS들은 대부분 Deadlock Ignorance를 채택하고 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;deadlock-prevention&quot;&gt;Deadlock Prevention&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502182036.png&quot; alt=&quot;7&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 4가지 조건 중 하나를 차단하면 deadlock 발생을 막을 수 있다.&lt;/p&gt;

&lt;p&gt;Mutual Exclusion은 사실상 직접 차단하는 것이 어렵다.&lt;/p&gt;

&lt;p&gt;Hold and Wait은 두 가지 방법으로 차단할 수 있는데 방법 1의 경우에는 자원의 비효율성이 높아지므로 잘 사용하지 않는다.&lt;/p&gt;

&lt;p&gt;반면 방법2는 보유 자원을 모두 내려놓은 상태에서만 자원 요청을 할 수 있게 만드는 방법이므로 자원 비효율성이 높지 않다.&lt;/p&gt;

&lt;p&gt;No Preemption의 경우 자원을 뺏었을 때 문제가 없는 구조여야만 차단할 수 있다. CPU 스케쥴링과 다르게 자원을 빼았긴 후 다시 되찾았을 때 이전 작업을 이어서 하기가 어렵기 때문이다.&lt;/p&gt;

&lt;p&gt;Circular Wait는 자원마다 번호를 매겨서 정해진 순서대로만 자원을 획득할 수 있도록 처리하면 쌍방향으로의 자원 요구가 이루어질 수 없으므로 Cycle이 생길 우려가 사라진다.&lt;/p&gt;

&lt;p&gt;하지만 위의 방법들은 자원 이용률 저하, starvation 현상 등이 발생한다.&lt;/p&gt;

&lt;h2 id=&quot;deadlock-avoidance&quot;&gt;Deadlock Avoidance&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502183735.png&quot; alt=&quot;image-20210502183734195&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Process가 시작되어 종료될 때까지 써야하는 최대의 자원량을 알고 있다고 가정한다.&lt;/p&gt;

&lt;p&gt;모든 경우의 수를 따져보고 자원 할당으로부터 안전한 경우에만 자원을 할당해준다. (자원의 여분이 있음에도)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502184158.png&quot; alt=&quot;image-20210502184152926&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자원당 하나의 instance를 가지고 있다면 자원 할당 그래프 알고리즘(deadlock 발생 여부를 찾아줌)을 이용해 막아줄 수 있고&lt;/p&gt;

&lt;p&gt;자원당 여러개의 instance를 가지고 있는 경우에는 Banker’s 알고리즘을 통해 deadlock을 막아줄 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;resource-allocation-graph-algorithm&quot;&gt;Resource Allocation Graph algorithm&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502190017.png&quot; alt=&quot;image-20210502190015537&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자원당 instance가 하나만 있는 상황에서 deadlock을 피하는 방법&lt;/p&gt;

&lt;p&gt;자원에서 프로세스로 뻗어있는 화살표는 프로세스가 해당 자원을 보유하고 있다는 의미&lt;/p&gt;

&lt;p&gt;프로세스에서 자원으로 뻗어있는 화살표는 프로세스가 해당 자원을 요청했다는 의미&lt;/p&gt;

&lt;p&gt;점선으로 이루어진 화살표는 프로세스가 평생에 거쳐 해당 자원을 요청할 가능성이 있음을 나타냄&lt;/p&gt;

&lt;p&gt;deadlock의 위험성이 있으면 자원을 주지 않고 막는다.&lt;/p&gt;

&lt;h2 id=&quot;bankers-algorithm&quot;&gt;Banker’s Algorithm&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502191103.png&quot; alt=&quot;image-20210502191101848&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502191140.png&quot; alt=&quot;image-20210502191138729&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자원당 instance가 여러개 있는 경우 Banker’s Algorithm을 적용할 수 있다.&lt;/p&gt;

&lt;p&gt;ppt의 예시는 Process가 5개 있고&lt;/p&gt;

&lt;p&gt;Resource A,B,C는 instance를 각각 10개, 5개, 7개 가지고 있다.&lt;/p&gt;

&lt;p&gt;Allocation은 현재 할당된 instance를 나타내는 것이고&lt;/p&gt;

&lt;p&gt;Max는 최대로 요청할 수 있는 (프로세스 평생에 걸쳐) instance의 수를 나타낸 것이다.&lt;/p&gt;

&lt;p&gt;현재 남아있는 자원은 Available section에 보이는 것처럼 A 3개, B 3개, C 2개인 상황에서&lt;/p&gt;

&lt;p&gt;프로세스들이 자원을 요청했을 때 처리하는 방식에 대해 알아보자&lt;/p&gt;

&lt;p&gt;현재 가용자원만 가지고도(Available) 어떤 프로세스의 Max를 충족할 수 있다면 자원을 할당해준다&lt;/p&gt;

&lt;p&gt;하지만 이것이 불가능한 경우에는 deadlock을 피하기 위해 자원을 할당해주지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502193527.png&quot; alt=&quot;image-20210502193525439&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스의 Need (현재 상태에서 최대로 요청할 수 있는 resource instance의 양)보다 Available한 자원이 더 많은 경우에만 자원을 할당해주면 deadlock을 막을 수 있다.&lt;/p&gt;

&lt;p&gt;이 때 요청한 자원의 양과 Need는 서로 다른 개념임을 기억하자.&lt;/p&gt;

&lt;p&gt;적어도 Need 이상의 양을 요청하지 않는다는 전제 때문에 가능한 상황이다.&lt;/p&gt;

&lt;h2 id=&quot;deadlock-detection&quot;&gt;Deadlock Detection&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502194954.png&quot; alt=&quot;image-20210502194952896&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Deadlock Detection은 Deadlock Avoidance와 마찬가지로 모든 Resource의 instance가 하나인 경우에는 자원 할당 그래프를 사용해 deadlock을 탐지할 수 있다.&lt;/p&gt;

&lt;p&gt;instance가 여러개인 경우에는 Banker’s algorithm과 유사한 방법으로 처리할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502195232.png&quot; alt=&quot;image-20210502195223354&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스에서 프로세스로 뻗어나간 화살표는 자원 할당 그래프를 더 간편하게 그리기 위한 방안으로 화살표의 목적지에 해당하는 프로세스가 가진 자원을 화살표의 시작지에 해당하는 프로세스가 요청하고 있음을 나타낸다.&lt;/p&gt;

&lt;p&gt;process가 n개일 때 wait for graph에서 cycle을 찾는 overhead는 O(n^2)에 해당한다.&lt;/p&gt;

&lt;p&gt;node가 n개일 때 edge의 maximum은 n(n-1)개이므로 이 edge들을 모두 다 따라가보면 O(n^2)의 시간복잡도가 걸림을 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502200422.png&quot; alt=&quot;image-20210502200419205&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 상황은 자원당 instance가 여러개인 경우를 나타낸 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502200728.png&quot; alt=&quot;image-20210502200726350&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;deadlock-recovery&quot;&gt;Deadlock Recovery&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Neph3779/Blog-Image/master/img/20210502200920.png&quot; alt=&quot;image-20210502200918555&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Deadlock을 recover하는 방법에는 크게 두가지가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Deadlock에 연루된 process들을 없애기 (한꺼번에 kill)&lt;/li&gt;
  &lt;li&gt;Deadlock에 연루된 process들을 하나씩 없애보기 (Deadlock이 없어질때까지)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위와 같은 방식으로 safe state가 되면 다시 process를 시작하면 된다.&lt;/p&gt;

&lt;p&gt;동일한 프로세스가 계속해서 victim(process가 deadlock에 연루되어서 죽는 경우)이 되는 경우&lt;/p&gt;

&lt;p&gt;starvation 문제를 야기할 수 있으므로 이 부분도 같이 고려를 해야한다.&lt;/p&gt;
</description>
        <pubDate>Sun, 02 May 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/11-Deadlock/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/11-Deadlock/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>2021년 04월 29일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Allen의 동시성 프로그래밍 특강을 들었습니다. 동기/비동기에 관해서 많은 것을 알 수 있었습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위의 특강을 토대로 Step1의 수정이 이루어졌습니다. protocol에 집착하던 것을 버린 것과 Operation을 Subclassing하여 OperationQueue에 단순한 BlockOperation을 넣지 않은 점이 이전과 가장 많이 달라진 부분입니다.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/yagom-academy/ios-bank-manager/pull/33&quot;&gt;PR 링크&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;오늘의-고민내일-공부할-내용들&quot;&gt;오늘의 고민(내일 공부할 내용들)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Completion Handler v.s. return 값 있는 함수
    &lt;ul&gt;
      &lt;li&gt;왜 비동기 작업에서는 return형 함수를 쓰면 안되는가? URL Session이 비동기처리라는 것을 유념하며 생각해보자!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클로저 - 캡처리스트 이게 뭐지?&lt;/li&gt;
  &lt;li&gt;콜백 함수의 개념에 대해서&lt;/li&gt;
  &lt;li&gt;고차함수의 정의가 뭐지?&lt;/li&gt;
  &lt;li&gt;enum + CaseIterable + random enum에 random함수를 깔끔하게 넣어서 이용하는 방법이 있던 것 같은데..&lt;/li&gt;
  &lt;li&gt;struct와 mutating 등에 대해 알아봐야 할 것 같다. (class로 했을때는 문제가 없던 것이 struct로 바꾸니 결과가 원하는대로 나오질 않네..)&lt;/li&gt;
  &lt;li&gt;XCTest의 setUp, tearDown 메서드에 대해 알아보자! instance의 생명주기가 어떻게 되는거지?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;내일-알아볼-링크들&quot;&gt;내일 알아볼 링크들&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;https://agostini.tech/2017/07/30/understanding-operation-and-operationqueue-in-swift/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;https://effectivecode.tistory.com/932&lt;/li&gt;
  &lt;li&gt;https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4_%EC%8B%A0%ED%98%B8&lt;/li&gt;
  &lt;li&gt;https://jcsoohwancho.github.io/2019-11-02-Message-Dispatch/&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 29 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.29-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.29-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>2021년 04월 27일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;은행 창구 프로젝트&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;as를 통한 type casting과 initializer를 통한 타입 변환이 서로 다르단 것을 다시 한 번 인지했습니다.&lt;/p&gt;

        &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userInput&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;inputNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* input as? Int와는 전혀 다른 문법 */&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;은행창구 프로젝트에 POP를 적용하기 위해 팀원과 노력했습니다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;해당 과정은 PR메세지와 README에 기록될 것 같습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 27 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.27-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.27-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>2021년 04월 26일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;새로운 프로젝트 (은행 창구 매니저 프로젝트) 시작&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;팀 그라운드 룰 작성 및 진행방향에 대해 이야기했습니다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;Jay가 알려준 github의 issue기능을 활용하여 커밋들을 관리하기로 했습니다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;프로토콜 지향 프로그래밍을 공부해봤습니다&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/408/&quot;&gt;Protocol-Oriented Programming in Swift&lt;/a&gt; WWDC 영상을 시청했습니다.&lt;/li&gt;
          &lt;li&gt;야곰의 스위프트 프로그래밍 책의 23장(프로토콜 지향 프로그래밍)을 정독했습니다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;활동학습을 통해 CPU 스케쥴링 기법에 대해 다시 복습했습니다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;이전에 써놓았던 운영체제 정리글을 다시 한번 읽어보는 시간을 가졌습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 26 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.26-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.26-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
      <item>
        <title>[#10] 프로세스 동기화-3</title>
        <description>&lt;h2 id=&quot;bounded---buffer-problemproducer---consumer-problem&quot;&gt;Bounded - Buffer Problem(Producer - Consumer Problem)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425021405828.png&quot; alt=&quot;image-20210425021405828&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;생산자가 데이터를 공유 버퍼에 넣을때, 소비자가 공유버퍼에서 데이터를 꺼내갈 때 버퍼가 비어있거나 꽉 찬 경우에 문제가 발생할 수 있다. 이 문제는 공유데이터에 Lock을 걸었다가 풀었다가 하는 방식으로 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;이 방식을 이용하기 위해 mutex와 resource count가 사용되는데 mutex는 공유 버퍼 자체에 Lock을 걸었다 풀었다 하는 방식을 사용하기 위해 필요하며 resource count는 버퍼의 크기를 관리하기 위해 사용된다. Producer와 Consumer는 포인터 형식으로 관리되며 ppt의 그림을 통해 원형 큐의 방식으로 관리될 것임을 유추할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425022704389.png&quot; alt=&quot;image-20210425022704389&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 문제를 수도코드로 표현한 것이다.&lt;/p&gt;

&lt;p&gt;full이라는 변수는 내용이 들어있는 버퍼의 개수를 세기 위한 변수, empty는 비어있는 버퍼의 개수를 세기 위한 변수이다.&lt;/p&gt;

&lt;p&gt;버퍼에 내용을 집어넣으려는 시도를 하는 Producer는 빈 버퍼가 있는지를 먼저 확인하는 작업을 거치며&lt;/p&gt;

&lt;p&gt;V(full)을 통해 내용이 들어있는 버퍼의 개수를 증가시키는 일을 한다.&lt;/p&gt;

&lt;p&gt;Consumer는 내용이 들어있는 버퍼가 있는지를 먼저 확인한 뒤 V(empty)를 통해 비어있는 버퍼의 개수를 증가시킨다.&lt;/p&gt;

&lt;h2 id=&quot;readers-and-writers-problem&quot;&gt;Readers and Writers Problem&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425112421207.png&quot; alt=&quot;image-20210425112421207&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;쓰기 작업은 다른 process와 동시에 하면 안되지만 읽기 작업은 많은 프로세스가 동시에 시도해도 무관하다.&lt;/p&gt;

&lt;p&gt;하지만 쓰기 작업을 하면서 Lock을 거는 방식을 사용하면 단지 읽기만 하려했던 프로세스들이 공유 데이터(DB)에 접근할 수 없게되는 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425113106309.png&quot; alt=&quot;image-20210425113106309&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 코드에서 DB는 공유 데이터를 나타내며 db는 DB에 Lock을 걸기위한 semaphore 변수이다.&lt;/p&gt;

&lt;p&gt;Reader의 경우에 DB에 Writer와 같은 방식으로 Lock을 걸었다 풀었다 하는 작업을 하는 대신 (비효율적이므로)&lt;/p&gt;

&lt;p&gt;readcount라는 변수를 두어서 현재 reader의 수를 관리한다. (readcount라는 변수도 공유변수이기 때문에 mutex를 이용하여 관리한다.)&lt;/p&gt;

&lt;p&gt;만약 자신이 마지막 reader였다면 DB의 Lock을 그제서야 풀어주는 방식을 사용하는데 이러한 방식은 Writer의 Starvation 문제를 불러올 수 있다. 이러한 문제는 Timer 방식과 유사하게 해결할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;dining---philosophers-problem&quot;&gt;Dining - Philosophers Problem&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425113838761.png&quot; alt=&quot;image-20210425113838761&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;철학자가 하는 일은 생각하기, 밥먹기&lt;/p&gt;

&lt;p&gt;왼쪽과 오른쪽의 젓가락을 모두 잡아야 밥을 먹을 수 있다고 가정&lt;/p&gt;

&lt;p&gt;젓가락을 잡는 연산은 P(chopstick[i]) (왼쪽 젓가락을 잡는 작업)과 P(chopstick[i+1]%5) (오른쪽 젓가락을 잡는 작업) 으로 진행된다.&lt;/p&gt;

&lt;p&gt;위 방식의 문제점은 deadlock 현상이 발생할 수 있다는 것인데 모두가 동시에 왼쪽 젓가락을 드는 순간 그 누구도 밥을 먹을 수 없는 상황이 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425114125945.png&quot; alt=&quot;image-20210425114125945&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;deadlock 현상을 해결하기 위한 방안들&lt;/p&gt;

&lt;p&gt;4명만이 동시에 식탁에 앉도록 하여 해결&lt;/p&gt;

&lt;p&gt;모든 젓가락을 잡을 수 있음이 확실시 된 상황에서만 젓가락을 집을 수 있도록 하여 해결&lt;/p&gt;

&lt;p&gt;짝수, 홀수 번호를 구분하여 해결&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425114544075.png&quot; alt=&quot;image-20210425114544075&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;철학자 i가 실행하는 함수는 pickup, eat, putdown, think&lt;/p&gt;

&lt;p&gt;self 배열은 양쪽 젓가락을 모두 잡을 수 있는지를 판단하는 변수이다. 0이면 불가 1이면 가능 등..&lt;/p&gt;

&lt;p&gt;state를 나타내는 enum 변수는 코딩을 돕기 위해 철학자의 현재 상태를 나타낸다.&lt;/p&gt;

&lt;p&gt;state도 공유변수로 사용되므로 Lock을 걸어주는 작업이 필요하다&lt;/p&gt;

&lt;p&gt;test 함수는 젓가락을 내려놓을 때 인접한 위치의 철학자들이 젓가락 pickup을 위해 기다리고 있던 상황이라면 그 철학자가 젓가락을 얻을 수 있도록 해준다. (semaphore에 약간 어긋나는 부분이 있다.)&lt;/p&gt;

&lt;h2 id=&quot;monitor&quot;&gt;Monitor&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425114332082.png&quot; alt=&quot;image-20210425114332082&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425115642342.png&quot; alt=&quot;image-20210425115642342&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Semaphore는 여러 불편한 점들이 있는데&lt;/p&gt;

&lt;p&gt;프로그래머가 실수를 하면 안된다는 치명적인 문제를 가지고 있다&lt;/p&gt;

&lt;p&gt;한번의 실수가 시스템에 치명적이며 이러한 버그가 발생했을 때 고치기가 쉽지 않다&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해 Monitor 방식을 사용하면 이러한 문제들을 어느정도 해결할 수  있다&lt;/p&gt;

&lt;p&gt;monitor안에는 하나의 process만 monitor 내부에 들어올 수 있다&lt;/p&gt;

&lt;p&gt;monitor에 들어가있는 프로세스가 0개이거나&lt;/p&gt;

&lt;p&gt;monitor 안에 있던 프로세스가 여러 사유에 의해 condition이 만족되지 않아 wait상태가 되면 그제서야 queue에 있던 프로세스들이 하나하나 들어올 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425115147111.png&quot; alt=&quot;image-20210425115147111&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모니터는 프로그래밍 언어 차원에서 동기화 문제를 해결하는 high level 해결 방식이다.&lt;/p&gt;

&lt;p&gt;OOP에서 객체를 기반으로 변수에 접근하는 것처럼&lt;/p&gt;

&lt;p&gt;공유데이터는 외부에서 접근할 수 없고 monitor 안에서만 접근할 수 있도록 해둔 것인데 (private 함수로 monitor 내부에서만 관리)&lt;/p&gt;

&lt;p&gt;프로그램 입장에서 이런 방식을 사용하면 Lock을 거는 작업을 프로그래머가 해줄 필요가 없다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425115346199.png&quot; alt=&quot;image-20210425115346199&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;monitor 방식에서 자원의 개수를 세는 작업은 condition 변수를 사용한다&lt;/p&gt;

&lt;p&gt;condition 변수는 wait 연산과 signal 연산을 지원하는데&lt;/p&gt;

&lt;p&gt;wait 함수는 프로세스를 잠들게 하는 역할을 한다 (x, y는 조건에 해당하며 x라는 조건을 만족하지 못한 경우 x의 queue에 가서 줄을 서게 된다.)&lt;/p&gt;

&lt;p&gt;wait 상태에서 signal을 통해 깨워진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425115503129.png&quot; alt=&quot;image-20210425115503129&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;monitor에서는 Lock을 걸고 푸는 복잡한 작업이 필요하지 않다 (공유 버퍼에 들어와서 코드를 실행하는 도중에 다른 프로세스의 접근은 모니터가 막아준다.)&lt;/p&gt;

&lt;p&gt;둘 이상의 생산자나 소비자가 접근하는 문제가 발생하지 않는다.&lt;/p&gt;

&lt;p&gt;condition 변수 full은 내용이 들어있는 버퍼를 기다리며 잠들게 하는 역할을 하고 empty는 내용이 들어있는 버퍼를 기다리며 잠들게 하는 역할을 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/chunsoohyun/Library/Application%20Support/typora-user-images/image-20210425114448312.png&quot; alt=&quot;image-20210425114448312&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;식사하는 철학자 문제를 Semaphore가 아닌 Monitor 방식으로 바꾸어보면 다음과 같은 코드를 작성할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sun, 25 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/10-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3-%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA-3/</link>
        <guid isPermaLink="true">https://neph3779.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/10-%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3-%E1%84%83%E1%85%A9%E1%86%BC%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA-3/</guid>
        
        <category>운영체제</category>
        
        <category>OS</category>
        
        
        <category>운영체제</category>
        
      </item>
    
      <item>
        <title>2021년 04월 22일 공부일지</title>
        <description>&lt;h2 id=&quot;오늘-공부한-내용&quot;&gt;오늘 공부한 내용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;UIViewController 관련 문서들 정독
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiviewcontroller/&quot;&gt;UIViewController&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457&quot;&gt;View Controller Programming Guide for iOS&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiview/positioning_content_relative_to_the_safe_area&quot;&gt;Positioning Content Relative to the Safe Area&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Delegate 관련 문서들 정독
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://magi82.github.io/ios-delegate/&quot;&gt;마기님의 delegate pattern 정리글&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 22 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://neph3779.github.io/til/2021.04.22-TIL/</link>
        <guid isPermaLink="true">https://neph3779.github.io/til/2021.04.22-TIL/</guid>
        
        <category>TIL</category>
        
        
        <category>TIL</category>
        
      </item>
    
  </channel>
</rss>
